<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于 Python 实现微信公众号爬虫]]></title>
    <url>%2F2018%2F01%2F15%2Fjuejin-liuzhijun-PythonCrawler%2F</url>
    <content type="text"><![CDATA[爬虫的基本原理爬虫就是一个自动化数据采集工具，你只要告诉它要采集哪些数据，丢给它一个 URL，就能自动地抓取数据了。其背后的基本原理就是爬虫程序向目标服务器发起 HTTP 请求，然后目标服务器返回响应结果，爬虫客户端收到响应并从中提取数据，再进行数据清洗、数据存储工作。 爬虫的基本流程爬虫的基本流程其实就是一个 HTTP 请求的过程，以浏览器访问一个网址为例，从用户输入 URL 开始，客户端通过 DNS 解析查询到目标服务器的 IP 地址，然后与之建立 TCP 连接，连接成功后，浏览器构造一个 HTTP 请求发送给服务器，服务器收到请求之后，从数据库查到相应的数据并封装成一个 HTTP 响应，然后将响应结果返回给浏览器，浏览器对响应内容进行数据解析、提取、渲染并最终展示在你面前。 HTTP 协议的请求和响应都必须遵循固定的格式，只有遵循统一的 HTTP 请求格式，服务器才能正确解析不同客户端发的请求，同样地，服务器遵循统一的响应格式，客户端才得以正确解析不同网站发过来的响应。]]></content>
  </entry>
  <entry>
    <title><![CDATA[吴恩达 - 机器学习]]></title>
    <url>%2F2017%2F12%2F30%2Fcoursera-of-Machine-Learning%2F</url>
    <content type="text"><![CDATA[第一周介绍： 本周，我们介绍了一种核心理念，教计算机在没有明确编程的情况下使用数据学习概念。 我们将从一个变量的线性回归开始。线性回归预测一个基于输入值的实值输出。摘要讨论了线性回归对房价预测的应用，提出了成本函数的概念，并引入了梯度下降法。 我们还会有一些可选的课程，提供关于线性代数概念的复习。对线性代数的基本理解是必要的，特别是当我们开始讨论有多个变量的模型时。如果你对自己对线性代数的理解有信心，可以在论坛上休息或帮助其他学生。 单词linear regression ：线性回归 notion ：概念 cost function ：成本函数 gradient descent ：梯度下降 refresher ： 复习 linear algebra ： 线性代数 cover : 讨论 forums ： 论坛 properties of algorithms : 算法的属性 Scenario 1: Code to delete 场景1:删除代码 fails the grader ：不及格]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F12%2F21%2FLiaoXueFeng-Python%2F</url>
    <content type="text"><![CDATA[原文地址：中文，免费，零起点，完整示例，基于最新的Python 3版本。 from：马超 廖雪峰的 Python 教程，不懂得地方再查资料去补充。 找一个实际的项目去练手。写一个爬虫项目。 找到一个已经会 Python 的司机。让他给你指出一条路子，同时在遇到卡壳的地方就找他指点。 要学会看别人代码，查看官方文档。 其实只要你想学习，什么时候开始都不晚，不要担心这担心那，你只需要努力，剩下的交给时间，而你之所以没有变强，只因你还不够努力，要记得付出不亚于任何人的努力。 Python 简介用Python可以做什么？可以做日常任务，比如自动备份你的MP3；可以做网站，很多著名的网站包括YouTube就是Python写的；可以做网络游戏的后台，很多在线游戏的后台都是Python开发的。总之就是能干很多很多事啦。 Python不能写操作系统，这个只能用C语言写；不能写手机应用，只能用Swift/Objective-C（针对iPhone）和Java（针对Android）；不能写3D游戏，最好用C或C++。 Python是著名的“龟叔”Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言。 最近10年最常用的10种编程语言的变化图（TIOBE排行榜）： 总的来说，这几种编程语言各有千秋。C语言是可以用来编写操作系统的贴近硬件的语言，所以，C语言适合开发那些追求运行速度、充分发挥硬件性能的程序。而Python是用来编写应用程序的高级编程语言。 高级编程语言通常都会提供一个比较完善的基础代码库，让你能直接调用，比如，针对电子邮件协议的SMTP库，针对桌面环境的GUI库，在这些已有的代码库的基础上开发，一个电子邮件客户端几天就能开发出来。 Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池（batteries included）”。用Python开发，许多功能不必从零编写，直接使用现成的即可。 除了内置的库外，Python还有大量的第三方库，也就是别人开发的，供你直接使用的东西。当然，如果你开发的代码通过很好的封装，也可以作为第三方库给别人使用。 许多大型网站就是用Python开发的，例如YouTube、Instagram，还有国内的豆瓣。很多大公司，包括Google、Yahoo等，甚至NASA（美国航空航天局）都大量地使用Python。 那Python适合开发哪些类型的应用呢？ 首选是网络应用，包括网站、后台服务等等； 其次是许多日常需要的小工具，包括系统管理员需要的脚本任务等等； 另外就是把其他语言开发的程序再包装起来，方便使用。 任何编程语言都有缺点，Python也不例外。优点说过了，那Python有哪些缺点呢？ 第一个缺点就是运行速度慢，和C程序相比非常慢，因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。 第二个缺点就是代码不能加密。如果要发布你的Python程序，实际上就是发布源代码，这一点跟C语言不同，C语言不用发布源代码，只需要把编译后的机器码（也就是你在Windows上常见的xxx.exe文件）发布出去。要从机器码反推出C代码是不可能的，所以，凡是编译型的语言，都没有这个问题，而解释型的语言，则必须把源码发布出去。 这个缺点仅限于你要编写的软件需要卖给别人挣钱的时候。好消息是目前的互联网时代，靠卖软件授权的商业模式越来越少了，靠网站和移动应用卖服务的模式越来越多了，后一种模式不需要把源码给别人。 当然，Python还有其他若干小缺点，请自行忽略，就不一一列举了。 安装 Python要开始学习Python编程，首先就得把Python安装到你的电脑里。安装后，你会得到Python解释器（就是负责运行Python程序的），一个命令行交互环境，还有一个简单的集成开发环境。 目前，Python有两个版本，一个是2.x版，一个是3.x版，这两个版本是不兼容的。由于3.x版越来越普及，我们的教程将以最新的Python 3.6版本为基础。请确保你的电脑上安装的Python版本是最新的3.6.x，这样，你才能无痛学习这个教程。 Python解释器当我们编写Python代码时，我们得到的是一个包含Python代码的以.py为扩展名的文本文件。要运行代码，就需要Python解释器去执行.py文件。 Python的解释器很多，但使用最广泛的还是CPython。如果要和Java或.Net平台交互，最好的办法是通过网络调用来交互，确保各程序之间的独立性，而不是用Jython或IronPython。 当你在终端或者cmd里输入python3的时候, 就是启动了CPython解释器, 安装了Python会默认带一个IDLE, 该软件就是基于CPython做的一个IDE. pycharm是一个IDE，类似Python自带的IDLE、Spyder、Sublime等等，它们都只是编辑器，是用来编写代码的，而CPython、IPython、PyPy等，这些是解释器，是用来执行Python代码的，这两者是不一样的。 命令行模式和Python交互模式命令行模式： 在Windows开始菜单选择“命令提示符”，就进入到命令行模式，它的提示符类似C:\&gt;， 在命令行模式下，可以执行python进入Python交互式环境，也可以执行python hello.py运行一个.py文件。 执行一个.py文件只能在命令行模式执行。 Python交互模式： 在命令行模式下敲命令python，就看到类似如下的一堆文本输出，然后就进入到Python交互模式，它的提示符是&gt;&gt;&gt;。 在Python交互模式下输入exit()并回车，就退出了Python交互模式，并回到命令行模式。 Python交互模式的代码是输入一行，执行一行，而命令行模式下直接运行.py文件是一次性执行该文件内的所有代码。可见，Python交互模式主要是为了调试Python代码用的，也便于初学者学习，它不是正式运行Python代码的环境！ 使用文本编辑器py文件名只能是英文字母、数字和下划线的组合。 用Python开发程序，完全可以一边在文本编辑器里写代码，一边开一个交互式命令窗口，在写代码的过程中，把部分代码粘到命令行去验证，事半功倍！前提是得有个27’的超大显示器！ Python代码运行助手Python代码运行助手可以让你在线输入Python代码，然后通过本机运行的一个Python脚本来执行代码。原理如下： 在网页输入代码; 点击Run按钮，代码被发送到本机正在运行的Python代码运行助手； Python代码运行助手将代码保存为临时文件，然后调用Python解释器执行代码； 网页显示代码执行结果。 下载地址：learning.py 运行： 在存放learning.py的目录下运行命令： 1C:\Users\michael\Downloads&gt; python3 learning.py 如果看到Ready for Python code on port 39093...表示运行成功，不要关闭命令行窗口，最小化放到后台运行即可。 输入和输出输出用print()在括号中加上字符串，就可以向屏幕上输出指定的文字。用print()在括号中加上字符串，就可以向屏幕上输出指定的文字。print()遇到逗号“,”会输出一个空格： 12&gt;&gt;&gt; print('The quick brown fox', 'jumps over', 'the lazy dog')The quick brown fox jumps over the lazy dog print()也可以打印整数，或者计算结果： 12&gt;&gt;&gt; print('100 + 200 =', 100 + 200)100 + 200 = 300 输入Python提供了一个input()，可以让用户输入字符串，并存放到一个变量里。比如输入用户的名字。 输出用print()在括号中加上字符串，就可以向屏幕上输出指定的文字。比如输出&#39;hello, world&#39;，用代码实现如下： 1&gt;&gt;&gt; print(&apos;hello, world&apos;) print()函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出： 12&gt;&gt;&gt; print(&apos;The quick brown fox&apos;, &apos;jumps over&apos;, &apos;the lazy dog&apos;)The quick brown fox jumps over the lazy dog print()会依次打印每个字符串，遇到逗号“,”会输出一个空格，因此，输出的字符串是这样拼起来的： print()也可以打印整数，或者计算结果： 1234&gt;&gt;&gt; print(300)300&gt;&gt;&gt; print(100 + 200)300 因此，我们可以把计算100 + 200的结果打印得更漂亮一点： 12&gt;&gt;&gt; print(&apos;100 + 200 =&apos;, 100 + 200)100 + 200 = 300 注意，对于100 + 200，Python解释器自动计算出结果300，但是，&#39;100 + 200 =&#39;是字符串而非数学公式，Python把它视为字符串，请自行解释上述打印结果。 输入现在，你已经可以用print()输出你想要的结果了。但是，如果要让用户从电脑输入一些字符怎么办？Python提供了一个input()，可以让用户输入字符串，并存放到一个变量里。比如输入用户的名字： 12&gt;&gt;&gt; name = input()Michael 输入完成后，不会有任何提示，Python交互式命令行又回到&gt;&gt;&gt;状态了。那我们刚才输入的内容到哪去了？答案是存放到name变量里了。可以直接输入name查看变量内容： 12&gt;&gt;&gt; name'Michael' 要打印出name变量的内容，除了直接写name然后按回车外，还可以用print()函数： 12&gt;&gt;&gt; print(name)Michael input()可以让你显示一个字符串来提示用户，于是我们把代码改成： 12name = input('please enter your name: ')print('hello,', name) 运行结果： 123C:\Workspace&gt; python hello.pyplease enter your name: Michaelhello, Michael Pycharm 的配置 配置Python解释器版本为Python3.6 点击运行倒三角前要配置项目的脚本入口，就是项目所在的文件路径 不需要配置这个，正确建立项目之后，直接点 run 就行了 小结 Python 是解释型语言 pycharm是一个IDE，类似Python自带的IDLE、Spyder、Sublime等等，它们都只是编辑器，是用来编写代码的，而CPython、IPython、PyPy等，这些是解释器，是用来执行Python代码的 输入是Input，输出是Output，因此，我们把输入输出统称为Input/Output，或者简写为IO。 input()和print()是在命令行下面最基本的输入和输出，但是，用户也可以通过其他更高级的图形界面完成输入和输出，比如，在网页上的一个文本框输入自己的名字，点击“确定”后在网页上看到输出信息。 input()可以让你显示一个字符串来提示用户，name = input(‘please enter your name: ‘) print()会依次打印每个字符串，遇到逗号“,”会输出一个空格，print(‘hello,’, name) Python基础任何一种编程语言都有自己的一套语法，编译器或者解释器就是负责把符合语法的程序代码转换成CPU能够执行的机器码，然后执行。 Python的语法比较简单，使用缩进来组织代码块，以#开头的语句是注释，解释器会忽略掉注释。其他每一行都是一个语句，当语句以冒号:结尾时，缩进的语句视为代码块，缩进使用4个空格。 缩进的坏处就是“复制－粘贴”功能失效了，这是最坑爹的地方。当你重构代码时，粘贴过去的代码必须重新检查缩进是否正确。此外，IDE很难像格式化Java代码那样格式化Python代码。 最后，请务必注意，Python程序是大小写敏感的。 数据类型####数据类型转换 Python内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数： 1234567891011121314&gt;&gt;&gt; int('123')123&gt;&gt;&gt; int(12.34)12&gt;&gt;&gt; float('12.34')12.34&gt;&gt;&gt; str(1.23)'1.23'&gt;&gt;&gt; str(100)'100'&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool('')False 列表如下: 方法 说明 int(x [,base ]) 将x转换为一个整数 long(x [,base ]) 将x转换为一个长整数 float(x ) 将x转换到一个浮点数 complex(real [,imag ]) 创建一个复数 str(x ) 将对象 x 转换为字符串 repr(x ) 将对象 x 转换为表达式字符串 eval(str ) 用来计算在字符串中的有效 Python 表达式,并返回一个对象 tuple(s ) 将序列 s 转换为一个元组 list(s ) 将序列 s 转换为一个列表 chr(x ) 将一个整数转换为一个字符 unichr(x ) 将一个整数转换为 Unicode 字符 ord(x ) 将一个字符转换为它的整数值 hex(x ) 将一个整数转换为一个十六进制字符串 oct(x ) 将一个整数转换为一个八进制字符串 在Python中，能够直接处理的数据类型有以下几种： 整数在Python中有4种类型的数——整数、长整数、浮点数和复数。 浮点型字符串如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用r&#39;&#39;表示&#39;&#39;内部的字符串默认不转义，可以自己试试： 1234&gt;&gt;&gt; print('\\\t\\')\ \&gt;&gt;&gt; print(r'\\\t\\')\\\t\\ 如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用&#39;&#39;&#39;字符串&#39;&#39;&#39;的格式表示多行内容，可以自己试试： 12345678print('''line1line2line3''')结果：line1line2line3 多行字符串&#39;&#39;&#39;字符串&#39;&#39;&#39;还可以在前面加上r使用： 123456print(r'''hello,\nworld''')结果：hello,\nworld 布尔值在Python中，布尔类型还可以与其他数据类型做 and、or和not运算，请看下面的代码： 12a = Trueprint(a and &apos;a=T&apos; or &apos;a=F&apos;) 计算结果不是布尔类型，而是字符串 ‘a=T’，这是为什么呢？ 因为Python把0、空字符串&#39;&#39;和None看成 False，其他数值和非空字符串都看成 True，所以： 12True and &apos;a=T&apos; 计算结果是 &apos;a=T&apos;继续计算 &apos;a=T&apos; or &apos;a=F&apos; 计算结果还是 &apos;a=T&apos; 要解释上述结果，又涉及到 and 和 or 运算的一条重要法则：短路计算。 在计算a and b时，如果 a 是 False，则根据与运算法则，整个结果必定为 False，因此返回 a；如果 a 是 True，则整个计算结果必定取决与 b，因此返回 b。 在计算a or b时，如果 a 是 True，则根据或运算法则，整个计算结果必定为 True，因此返回 a；如果 a 是 False，则整个计算结果必定取决于 b，因此返回 b。 所以Python解释器在做布尔运算时，只要能提前确定计算结果，它就不会往后算了，直接返回结果。 空值空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。 此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。 变量变量的创建和赋值在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量 1234a = 123 # a是整数print(a)a = 'ABC' # a变为字符串print(a) 这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言。 执行a = &#39;ABC&#39;，解释器创建了字符串&#39;ABC&#39;和变量a，并把a指向&#39;ABC&#39;： 执行b = a，解释器创建了变量b，并把b指向a指向的字符串&#39;ABC&#39;： 执行a = &#39;XYZ&#39;，解释器创建了字符串’XYZ’，并把a的指向改为&#39;XYZ&#39;，但b并没有更改： 所以，最后打印变量b的结果自然是&#39;ABC&#39;了。 变量的指向问题我们来看下这段代码，发现最后打印出来的变量 b 是 Hello Python 。 这主要是变量 a 一开始是指向了字符串 Hello Python ，b=a 创建了变量 b ,变量 b 也指向了a 指向的字符串 Hello Python，最后 a=123，把 变量 a 重新指向了 123，所以最后输出变量 b 是 Hello Python 多个变量赋值Python 允许同时为多个变量赋值。例如： 1a = b = c = 1 以上实例，创建一个整型对象，值为 1，三个变量被分配到相同的内存空间上。 当然也可以为多个对象指定多个变量。例如： 1a, b, c = 1, 2, &quot;wangzhuning&quot; 以上实例，两个整型对象 1 和 2 的分配给变量 a 和 b，字符串对象 “wangzhu” 分配给变量 c。 常量在Python中，通常用全部大写的变量名表示常量。但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变。 最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是/： 12&gt;&gt;&gt; 10 / 33.3333333333333335 /除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数： 12&gt;&gt;&gt; 9 / 33.0 还有一种除法是//，称为地板除，两个整数的除法仍然是整数： 12&gt;&gt;&gt; 10 // 33 你没有看错，整数的地板除//永远是整数，即使除不尽。要做精确的除法，使用/就可以。 因为//除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数： 12&gt;&gt;&gt; 10 % 31 无论整数做//除法还是取余数，结果永远是整数。 小结Python支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。 对变量赋值x = y是把变量x指向真正的对象，该对象是变量y所指向的。随后对变量y的赋值不影响变量x的指向。 注意：Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在-2147483648-2147483647。 Python的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。 任务计算十进制整数 45678 和十六进制整数 0x12fd2 之和。 1234#Enter a codeinteger = 45678integer2 = 0x12fd2print(integer + integer2) py可以直接计算十进制和十六进制。 字符串和编码字符编码字符串也是一种数据类型，但是，字符串比较特殊的是还有一个编码问题。 最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。 由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。 Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。 字母A用ASCII编码是十进制的65，二进制的01000001； 字符0用ASCII编码是十进制的48，二进制的00110000，注意字符&#39;0&#39;和整数0是不同的； 汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。 你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。 本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间。 搞清楚了ASCII、Unicode、UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式 在计算机内存中，字符串统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件： 浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器： Python的字符串在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言。 对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符： 12345678&gt;&gt;&gt; ord('A')65&gt;&gt;&gt; ord('中') 20013&gt;&gt;&gt; chr(66)'B'&gt;&gt;&gt; chr(25991)'文' 如果知道字符的整数编码，还可以用十六进制这么写str： 12&gt;&gt;&gt; '\u4e2d\u6587''中文' 两种写法完全是等价的。 Python对bytes类型的数据用带b前缀的单引号或双引号表示： 1x = b'ABC' 要注意区分&#39;ABC&#39;和b&#39;ABC&#39;，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。 如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法： 1234&gt;&gt;&gt; b'ABC'.decode('ascii')'ABC'&gt;&gt;&gt; b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')'中文' 如果bytes中包含无法解码的字节，decode()方法会报错： 1234&gt;&gt;&gt; b'\xe4\xb8\xad\xff'.decode('utf-8')Traceback (most recent call last): ...UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 3: invalid start byte 如果bytes中只有一小部分无效的字节，可以传入errors=&#39;ignore&#39;忽略错误的字节： 12&gt;&gt;&gt; b'\xe4\xb8\xad\xff'.decode('utf-8', errors='ignore')'中' 要计算str包含多少个字符，可以用len()函数： 1234&gt;&gt;&gt; len('ABC')3&gt;&gt;&gt; len('中文')2 len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数： 123456&gt;&gt;&gt; len(b'ABC')3&gt;&gt;&gt; len(b'\xe4\xb8\xad\xe6\x96\x87')6&gt;&gt;&gt; len('中文'.encode('utf-8'))6 可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。 当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行： 12#!/usr/bin/env python3# -*- coding: utf-8 -*- 第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释； 第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。 申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码。 如果.py文件本身使用UTF-8编码，并且也申明了# -*- coding: utf-8 -*-，打开命令提示符测试就可以正常显示中文。 纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如： 12345678&gt;&gt;&gt; 'ABC'.encode('ascii')b'ABC'&gt;&gt;&gt; '中文'.encode('utf-8')b'\xe4\xb8\xad\xe6\x96\x87'&gt;&gt;&gt; '中文'.encode('ascii')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128) 在bytes中，无法显示为ASCII字符的字节，用\x##显示。 小结：Python 的字符串 str 类型和bytes类型的之间有以下几个函数： chr()函数把编码转换为对应的字符 ord()函数获取字符的整数表示 bytes类型的数据用带b前缀的单引号或双引号表示 把bytes变为str，就需要用decode() 以Unicode表示的str通过encode()方法可以编码为指定的bytes 计算str包含多少个字符，可以用len()函数 格式化在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下： 1234&gt;&gt;&gt; 'Hello, %s' % 'world''Hello, world'&gt;&gt;&gt; 'Hi, %s, you have $%d.' % ('Michael', 1000000)'Hi, Michael, you have $1000000.' 你可能猜到了，%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。 123456print('%2d-%02d'%(3,5))print('%.2f'%3.1415)结果： 3-053.14 常见的占位符有： 占位符 替换内容 %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数： 如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串： 12&gt;&gt;&gt; 'Age: %s. Gender: %s' % (25, True)'Age: 25. Gender: True' 有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%： 12&gt;&gt;&gt; 'growth rate: %d %%' % 7'growth rate: 7 %' format()另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多： 12&gt;&gt;&gt; 'Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%'.format('小明', 17.125)'Hello, 小明, 成绩提升了 17.1%' 小结Python 3 的字符串使用Unicode，直接支持多语言。 当str和bytes互相转换时，需要指定编码。最常用的编码是UTF-8。 格式化字符串的时候，可以用Python的交互式环境测试，方便快捷。 任务12345678910111213141516#!/usr/bin/env python3# -*- coding: utf-8 -*-print &apos;&apos;&apos;静夜思床前明月光，疑是地上霜。举头望明月，低头思故乡。&apos;&apos;&apos;运行成功静夜思床前明月光，疑是地上霜。举头望明月，低头思故乡。 条件判断if语句的完整形式就是： 12345678if &lt;条件判断1&gt;: &lt;执行1&gt;elif &lt;条件判断2&gt;: &lt;执行2&gt;elif &lt;条件判断3&gt;: &lt;执行3&gt;else: &lt;执行4&gt; 根据Python的缩进规则，如果if语句判断是True，就把缩进语句都执行了，注意不要少写了冒号:。if语句执行有个特点，它是从上往下判断，如果在某个判断上是True，把该判断对应的语句执行后，就忽略掉剩下的elif和else。 if判断条件还可以简写，比如写： 12if x: print('True') 只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False。 循环 for x in ...循环就是把每个元素代入变量x，然后执行缩进块的语句。 while循环，只要条件满足，就不断循环，条件不满足时退出循环。 Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数： 12&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4] range(101)就可以生成0-100的整数序列。 123456sum = 0for x in range(101): sum = sum + xprint(sum)结果：5050 break语句可以在循环过程中直接退出循环，而continue语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都必须配合if语句使用。 要特别注意，不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到break和continue语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉break和continue语句。 使用list和tuplelistlist是一种Python内置的数据类型–列表，可以随时添加和删除其中的元素。 比如，列出班里所有同学的名字，就可以用一个list表示： 123&gt;&gt;&gt; classmates = ['Michael', 'Bob', 'Tracy']&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy'] 变量classmates就是一个list。用len()函数可以获得list元素的个数： 12&gt;&gt;&gt; len(classmates)3 用索引来访问list中每一个位置的元素，记得索引是从0开始的。 12345678910&gt;&gt;&gt; classmates[0]'Michael'&gt;&gt;&gt; classmates[1]'Bob'&gt;&gt;&gt; classmates[2]'Tracy'&gt;&gt;&gt; classmates[3]Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;IndexError: list index out of range 当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，记得最后一个元素的索引是len(classmates) - 1。 如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素： 12&gt;&gt;&gt; classmates[-1]'Tracy' 以此类推，可以获取倒数第2个、倒数第3个： 12345678&gt;&gt;&gt; classmates[-2]'Bob'&gt;&gt;&gt; classmates[-3]'Michael'&gt;&gt;&gt; classmates[-4]Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;IndexError: list index out of range 当然，倒数第4个就越界了。 list是一个可变的有序表，所以，可以往list中追加元素到末尾： 123&gt;&gt;&gt; classmates.append('Adam')&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy', 'Adam'] 也可以把元素插入到指定的位置，比如索引号(就是下标)为1的位置： 123&gt;&gt;&gt; classmates.insert(1, 'Jack')&gt;&gt;&gt; classmates['Michael', 'Jack', 'Bob', 'Tracy', 'Adam'] 要删除list末尾的元素，用pop()方法： 1234&gt;&gt;&gt; classmates.pop()'Adam'&gt;&gt;&gt; classmates['Michael', 'Jack', 'Bob', 'Tracy'] 要删除指定位置的元素，用pop(i)方法，其中i是索引位置： 1234&gt;&gt;&gt; classmates.pop(1)'Jack'&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy'] 要把某个元素替换成别的元素，可以直接赋值给对应的索引位置： 123&gt;&gt;&gt; classmates[1] = 'Sarah'&gt;&gt;&gt; classmates['Michael', 'Sarah', 'Tracy'] list里面的元素的数据类型也可以不同，比如： 1&gt;&gt;&gt; L = ['Apple', 123, True] list元素也可以是另一个list，比如： 123&gt;&gt;&gt; s = ['python', 'java', ['asp', 'php'], 'scheme']&gt;&gt;&gt; len(s)4 要注意s只有4个元素，其中s[2]又是一个list，如果拆开写就更容易理解了： 12&gt;&gt;&gt; p = ['asp', 'php']&gt;&gt;&gt; s = ['python', 'java', p, 'scheme'] 要拿到&#39;php&#39;可以写p[1]或者s[2][1]，因此s可以看成是一个二维数组，类似的还有三维、四维……数组，不过很少用到。 如果一个list中一个元素也没有，就是一个空的list，它的长度为0： 123&gt;&gt;&gt; L = []&gt;&gt;&gt; len(L)0 tuple另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改，比如同样是列出同学的名字： 1&gt;&gt;&gt; classmates = ('Michael', 'Bob', 'Tracy') 现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。 因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。 tuple的陷阱：当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来，比如： 123&gt;&gt;&gt; t = (1, 2)&gt;&gt;&gt; t(1, 2) 如果要定义一个空的tuple，可以写成()： 123&gt;&gt;&gt; t = ()&gt;&gt;&gt; t() 但是，要定义一个只有1个元素的tuple，如果你这么定义： 123&gt;&gt;&gt; t = (1)&gt;&gt;&gt; t1 定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。 所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义： 123&gt;&gt;&gt; t = (1,)&gt;&gt;&gt; t(1,) Python在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。 最后来看一个“可变的”tuple： 12345&gt;&gt;&gt; t = ('a', 'b', ['A', 'B'])&gt;&gt;&gt; t[2][0] = 'X'&gt;&gt;&gt; t[2][1] = 'Y'&gt;&gt;&gt; t('a', 'b', ['X', 'Y']) 这个tuple定义的时候有3个元素，分别是&#39;a&#39;，&#39;b&#39;和一个list。不是说tuple一旦定义后就不可变了吗？怎么后来又变了？ 别急，我们先看看定义的时候tuple包含的3个元素： 当我们把list的元素&#39;A&#39;和&#39;B&#39;修改为&#39;X&#39;和&#39;Y&#39;后，tuple变为： 表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向&#39;a&#39;，就不能改成指向&#39;b&#39;，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！ 理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。 切片取一个list的部分元素是非常常见的操作。比如，一个list如下： 1&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] 对应上面的问题，取前3个元素，用一行代码就可以完成切片： 12&gt;&gt;&gt; L[0:3][&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。 如果第一个索引是0，还可以省略： 12&gt;&gt;&gt; L[:3][&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 也可以从索引1开始，取出2个元素出来： 12&gt;&gt;&gt; L[1:3][&apos;Lisa&apos;, &apos;Bart&apos;] 只用一个 : ，表示从头到尾： 12&gt;&gt;&gt; L[:][&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] 因此，L[:]实际上复制出了一个新list。 切片操作还可以指定第三个参数： 12&gt;&gt;&gt; L[::2][&apos;Adam&apos;, &apos;Bart&apos;] 第三个参数表示每N个取一个，上面的 L[::2] 会每两个元素取出一个来，也就是隔一个取一个。 把list换成tuple，切片操作完全相同，只是切片的结果也变成了tuple。 range(1, 101) 请利用切片，取出： 前10个数； 3的倍数； 不大于50的5的倍数。 12345L = range(1, 101)print L[:10]print L[2::3]print L[4:50:5] 注意切片的下标，L[n,m] 实际上是取的下标为 n 到下标 m-1，对应的就是第 n+1个数 和第 m 个数。 倒序切片对于list，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试： 12345678910111213&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]&gt;&gt;&gt; L[-2:][&apos;Bart&apos;, &apos;Paul&apos;]&gt;&gt;&gt; L[:-2][&apos;Adam&apos;, &apos;Lisa&apos;]&gt;&gt;&gt; L[-3:-1][&apos;Lisa&apos;, &apos;Bart&apos;]&gt;&gt;&gt; L[-4:-1:2][&apos;Adam&apos;, &apos;Bart&apos;] 记住倒数第一个元素的索引是-1。倒序切片包含起始索引，不包含结束索引。 利用倒序切片对 1 - 100 的数列取出： * 最后10个数； * 最后10个5的倍数。 12345678L = range(1, 101)print L[-10:]print L[-46::5]运行成功[91, 92, 93, 94, 95, 96, 97, 98, 99, 100][55, 60, 65, 70, 75, 80, 85, 90, 95, 100] 字符串切片字符串也可以用切片操作，只是操作结果仍是字符串。 123456&gt;&gt;&gt; &apos;ABCDEFG&apos;[:3]&apos;ABC&apos;&gt;&gt;&gt; &apos;ABCDEFG&apos;[-3:]&apos;EFG&apos;&gt;&gt;&gt; &apos;ABCDEFG&apos;[::2]&apos;ACEG&apos; 小结list和tuple是Python内置的有序集合，一个可变，一个不可变。根据需要来选择使用它们。 list 可变，tuple 不可变 list 和 tuple 都可以切片，切片操作完全相同，切片的结果分别是 list 和 tuple 。注意 使用dict和setdictPython内置了字典：dict (dictionary) 的支持，使用键-值（key-value）存储，具有极快的查找速度。 Python写一个dict如下： 123&gt;&gt;&gt; d = &#123;'Michael': 95, 'Bob': 75, 'Tracy': 85&#125;&gt;&gt;&gt; d['Michael']95 把数据放入dict的方法，除了初始化时指定外，还可以通过key放入： 123&gt;&gt;&gt; d['Adam'] = 67&gt;&gt;&gt; d['Adam']6 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉. 如果key不存在，dict就会报错： 1234&gt;&gt;&gt; d['Thomas']Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;KeyError: 'Thomas' 要避免key不存在的错误，有两种办法，一是通过in判断key是否存在： 12if 'Paul' in d: print d['Paul'] 二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value： 123&gt;&gt;&gt; d.get('Thomas')&gt;&gt;&gt; d.get('Thomas', -1)-1 要删除一个key，用pop(key)方法，对应的value也会从dict中删除： 12&gt;&gt;&gt; d.pop('Bob')75 dict内部存放的顺序和key放入的顺序是没有关系的。 和list比较，dict有以下几个特点： 查找和插入的速度极快，不会随着key的增加而变慢，但需要占用大量的内存，内存浪费多。 所以，dict是用空间来换取时间的一种方法，dict可以用在需要高速查找的很多地方。 dict 的 key 必须是不可变对象。这是因为 dict 根据 key 来计算 value 的存储位置，如果每次计算相同的 key 得出的结果不同，那 dict 内部就完全混乱了。这个通过 key 计算位置的算法称为哈希算法（Hash）。要保证hash 的正确性，作为 key 的对象就不能变。在 Python 中，字符串、整数、浮点数都是不可变的，因此，可以放心地作为 key。而list是可变的，就不能作为 key： 12345&gt;&gt;&gt; key = [1, 2, 3]&gt;&gt;&gt; d[key] = &apos;a list&apos;Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: unhashable type: &apos;list&apos; 存储的key-value序对是没有顺序的！这和list不一样： 12345d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125; 当我们试图打印这个dict时： 12&gt;&gt;&gt; print d&#123;&apos;Lisa&apos;: 85, &apos;Adam&apos;: 95, &apos;Bart&apos;: 59&#125; 打印的顺序不一定是我们创建时的顺序，而且，不同的机器打印的顺序都可能不同，这说明dict内部是无序的，不能用dict存储有序的集合。 setset和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。 set 存储的元素和 dict 的 key 类似，必须是不变对象， 要创建一个set，需要提供一个list作为输入集合： 123&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s&#123;1, 2, 3&#125; 注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。 重复元素在set中自动被过滤。 通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果： 123456&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s&#123;1, 2, 3, 4&#125;&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s&#123;1, 2, 3, 4&#125; 通过remove(key)方法可以删除元素： 123&gt;&gt;&gt; s.remove(4)&gt;&gt;&gt; s&#123;1, 2, 3&#125; set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作： 123456&gt;&gt;&gt; s1 = set([1, 2, 3])&gt;&gt;&gt; s2 = set([2, 3, 4])&gt;&gt;&gt; s1 &amp; s2&#123;2, 3&#125;&gt;&gt;&gt; s1 | s2&#123;1, 2, 3, 4&#125; set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象， 用 for 循环遍历如下的set，打印出 name: score 来。 1s = set([(&apos;Adam&apos;, 95), (&apos;Lisa&apos;, 85), (&apos;Bart&apos;, 59)]) 答案： 12345678910s = set([(&apos;Adam&apos;, 95), (&apos;Lisa&apos;, 85), (&apos;Bart&apos;, 59)])for x in s: print(x[0],&apos;:&apos;,x[1]) 运行成功Lisa : 85Adam : 95Bart : 59# 由于 set 里面的每一个元素都是 tuple 类型数据，所以可以对每个 set 里面的元素使用tuple 元素访问方式访问并读取 ####再议不可变对象 上面我们讲了，str是不变对象，而list是可变对象。 对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如： 1234&gt;&gt;&gt; a = ['c', 'b', 'a']&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a['a', 'b', 'c'] 而对于不可变对象，比如str，对str进行操作呢： 123456&gt;&gt;&gt; a = 'abc'&gt;&gt;&gt; b = a.replace('a', 'A')&gt;&gt;&gt; b'Abc'&gt;&gt;&gt; a'abc' 要始终牢记的是，a是变量，而&#39;abc&#39;才是字符串对象str ！有些时候，我们经常说，对象a的内容是&#39;abc&#39;，但其实是指，a本身是一个变量，它指向的对象的内容才是&#39;abc&#39;： 123┌───┐ ┌───────┐│ a │─────────────────&gt;│ &apos;abc&apos; │└───┘ └───────┘ 当我们调用a.replace(&#39;a&#39;, &#39;A&#39;)时，实际上调用方法replace是作用在字符串对象&#39;abc&#39;上的，而这个方法虽然名字叫replace，但却没有改变字符串&#39;abc&#39;的内容。相反，replace方法创建了一个新字符串&#39;Abc&#39;并返回，如果我们用变量b指向该新字符串，就容易理解了，变量a仍指向原有的字符串&#39;abc&#39;，但变量b却指向新字符串&#39;Abc&#39;了： 123456┌───┐ ┌───────┐│ a │─────────────────&gt;│ &apos;abc&apos; │└───┘ └───────┘┌───┐ ┌───────┐│ b │─────────────────&gt;│ &apos;Abc&apos; │└───┘ └───────┘ 所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。 小结使用key-value存储结构的dict在Python中非常有用，选择不可变对象作为key很重要，最常用的key是字符串。 tuple虽然是不变对象，但试试把(1, 2, 3)和(1, [2, 3])放入dict或set中，并解释结果。 123456789&gt;&gt;&gt; tou = (0,1,2)&gt;&gt;&gt; s1 = set(tou)&gt;&gt;&gt; s1&#123;0, 1, 2&#125;&gt;&gt;&gt; tou = (1,3,[2,4])&gt;&gt;&gt; s1 = set(tou)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: unhashable type: &apos;list&apos; 函数函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”： 123&gt;&gt;&gt; a = abs # 变量a指向abs函数&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数1 定义函数在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。 def my_abs(x): 1234if x &gt;= 0: return xelse: return -x 函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。 如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。return None可以简写为return。 如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目录下启动Python解释器，用from abstest import my_abs来导入my_abs()函数，注意abstest是文件名（不含.py扩展名）： 123456789101112131415┌────────────────────────────────────────────────────────┐│Command Prompt - python - □ x │├────────────────────────────────────────────────────────┤│&gt;&gt;&gt; from abstest import my_abs ││&gt;&gt;&gt; my_abs(-9) ││9 ││&gt;&gt;&gt; _ ││ ││ ││ ││ ││ ││ ││ │└────────────────────────────────────────────────────────┘ ####空函数 如果想定义一个什么事也不做的空函数，可以用pass语句： 12def nop(): pass pass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。 pass还可以用在其他语句里，比如： 12if age &gt;= 18: pass 缺少了pass，代码运行就会有语法错误。 参数检查调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError，如果参数类型不对，Python解释器就无法帮我们检查。对参数类型做检查，可以用内置函数isinstance()实现： 1234567def my_abs(x): if not isinstance(x, (int, float)): raise TypeError('bad operand type') if x &gt;= 0: return x else: return -x 添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误： 12345&gt;&gt;&gt; my_abs('A')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 3, in my_absTypeError: bad operand type ####返回多个值 函数可以返回多个值吗？答案是肯定的。 比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的新的坐标： 123456import mathdef move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny import math语句表示导入math包，并允许后续代码引用math包里的sin、cos等函数。 然后，我们就可以同时获得返回值： 123&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print(x, y)151.96152422706632 70.0 但其实这只是一种假象，Python函数返回的仍然是单一值： 123&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print(r)(151.96152422706632, 70.0) 原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。 Python之递归函数我们来计算阶乘 n! = 1 * 2 3 … * n，用函数 fact(n)表示，可以看出： 1fact(n) = n! = 1 * 2 * 3 * ... * (n-1) * n = (n-1)! * n = fact(n-1) * n 所以，fact(n)可以表示为 n * fact(n-1)，只有n=1时需要特殊处理。 于是，fact(n)用递归的方式写出来就是： 1234def fact(n): if n==1: return 1 return n * fact(n - 1) 如果我们计算fact(5)，可以根据函数定义看到计算过程如下： 12345678910===&gt; fact(5)===&gt; 5 * fact(4)===&gt; 5 * (4 * fact(3))===&gt; 5 * (4 * (3 * fact(2)))===&gt; 5 * (4 * (3 * (2 * fact(1))))===&gt; 5 * (4 * (3 * (2 * 1)))===&gt; 5 * (4 * (3 * 2))===&gt; 5 * (4 * 6)===&gt; 5 * 24===&gt; 120 递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。 使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试计算 fact(10000)。 汉诺塔 (http://baike.baidu.com/view/191666.htm) 的移动也可以看做是递归函数。 我们对柱子编号为a, b, c，将所有圆盘从a移到c可以描述为： 如果a只有一个圆盘，可以直接移动到c； 如果a有N个圆盘，可以看成a有1个圆盘（底盘） + (N-1)个圆盘，首先需要把 (N-1) 个圆盘移动到 b，然后，将 a的最后一个圆盘移动到c，再将b的(N-1)个圆盘移动到c。 请编写一个函数，给定输入 n, a, b, c，打印出移动的步骤： move(n, a, b, c) 例如，输入 move(2, ‘A’, ‘B’, ‘C’)，打印出： A –&gt; BA –&gt; CB –&gt; C 123456789def move(n, a, b, c): if n == 1: print a,&apos;--&gt;&apos;,c return move(n-1,a,c,b) print a,&apos;--&gt;&apos;,c move(n-1,b,a,c)move(4, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;) Python之定义可变参数如果想让一个函数能接受任意个参数，我们就可以定义一个可变参数： 12def fn(*args): print args 可变参数的名字前面有个 * 号，我们可以传入0个、1个或多个参数给可变参数： 12345678&gt;&gt;&gt; fn()()&gt;&gt;&gt; fn(&apos;a&apos;)(&apos;a&apos;,)&gt;&gt;&gt; fn(&apos;a&apos;, &apos;b&apos;)(&apos;a&apos;, &apos;b&apos;)&gt;&gt;&gt; fn(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;) 可变参数也不是很神秘，Python解释器会把传入的一组参数组装成一个tuple传递给可变参数，因此，在函数内部，直接把变量 args 看成一个 tuple 就好了。注意不传入值时，返回的是一个()，不是None，所以判断是否没有传入参数时用len(args)，不能用args == None 定义可变参数的目的也是为了简化调用。假设我们要计算任意个数的平均值，就可以定义一个可变参数： 1234567891011121314def average(*args): if(len(args) == 0): return 0 else: return (sum(args) / len(args))print(average())print(average(1, 2))print(average(1, 2, 2, 3, 4))结果：01.52.4 这样，在调用的时候，可以这样写： 123456&gt;&gt;&gt; average()0&gt;&gt;&gt; average(1, 2)1.5&gt;&gt;&gt; average(1, 2, 2, 3, 4)2.4 ####小结 定义函数时，需要确定函数名和参数个数； 如果有必要，可以先对参数的数据类型做检查； 函数体内部可以用return随时返回函数结果； 函数执行完毕也没有return语句时，自动return None。 函数可以同时返回多个值，但其实就是一个 tuple。 函数的递归调用，注意 n == 1时，处理 return语句。 函数传参时，也可以传不确定数目的参数，实际上也是一个 tuple。 迭代在Python中，如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们成为迭代（Iteration）。 Python 的 for循环不仅可以用在list或tuple上，还可以作用在其他任何可迭代对象上。 1234注意: 集合是指包含一组元素的数据结构，我们已经介绍的包括：1. 有序集合：list，tuple，str和unicode；2. 无序集合：set3. 无序集合并且具有 key-value 对：dict 而迭代是一个动词，它指的是一种操作，在Python中，就是 for 循环。 索引迭代Python中，迭代永远是取出元素本身，而非元素的索引。 对于有序集合，元素确实是有索引的。有的时候，我们确实想在 for 循环中拿到索引，怎么办？ 方法是使用 enumerate() 函数： 12345678&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]&gt;&gt;&gt; for index, name in enumerate(L):... print index, &apos;-&apos;, name... 0 - Adam1 - Lisa2 - Bart3 - Paul 使用 enumerate() 函数，我们可以在for循环中同时绑定索引index和元素name。但是，这不是 enumerate() 的特殊语法。实际上，enumerate() 函数把： 1[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] 变成了类似： 1[(0, &apos;Adam&apos;), (1, &apos;Lisa&apos;), (2, &apos;Bart&apos;), (3, &apos;Paul&apos;)] 因此，迭代的每一个元素实际上是一个tuple： 1234for t in enumerate(L): index = t[0] name = t[1] print index, &apos;-&apos;, name 如果我们知道每个tuple元素都包含两个元素，for循环又可以进一步简写为： 12for index, name in enumerate(L): print index, &apos;-&apos;, name 这样不但代码更简单，而且还少了两条赋值语句。 可见，索引迭代也不是真的按索引访问，而是由 enumerate() 函数把每个元素变成 (index, element) 这样的tuple，再迭代，就同时获得了索引和元素本身。 zip()函数可以把两个 list 变成一个 list： 12&gt;&gt;&gt; zip([10, 20, 30], [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;])[(10, &apos;A&apos;), (20, &apos;B&apos;), (30, &apos;C&apos;)] 在迭代 [‘Adam’, ‘Lisa’, ‘Bart’, ‘Paul’] 时，如果我们想打印出名次 - 名字（名次从1开始)，请考虑如何在迭代中打印出来。 123L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]for index, name in zip(range(1, len(L)+1), L): print index, &apos;-&apos;, name 迭代dict的value我们已经了解了dict对象本身就是可迭代对象，用 for 循环直接迭代 dict，可以每次拿到dict的一个key。 如果我们希望迭代 dict 对象的value，应该怎么做？ dict 对象有一个 values() 方法，这个方法把dict转换成一个包含所有value的list，这样，我们迭代的就是 dict的每一个 value： 12345678d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;print d.values()# [85, 95, 59]for v in d.values(): print v# 85# 95# 59 如果仔细阅读Python的文档，还可以发现，dict除了values()方法外，还有一个 itervalues() 方法，用 itervalues() 方法替代 values() 方法，迭代效果完全一样： 12345678d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;print d.itervalues()# &lt;dictionary-valueiterator object at 0x106adbb50&gt;for v in d.itervalues(): print v# 85# 95# 59 那这两个方法有何不同之处呢？ values() 方法实际上把一个 dict 转换成了包含 value 的list。 但是 itervalues() 方法不会转换，它会在迭代过程中依次从 dict 中取出 value，所以 itervalues() 方法比 values() 方法节省了生成 list 所需的内存。 打印 itervalues() 发现它返回一个 对象，这说明在Python中，for 循环可作用的迭代对象远不止 list，tuple，str，unicode，dict等，任何可迭代对象都可以作用于for循环，而内部如何迭代我们通常并不用关心。 如果一个对象说自己可迭代，那我们就直接用 for 循环去迭代它，可见，迭代是一种抽象的数据操作，它不对迭代对象内部的数据有任何要求。 给定一个dict： d = { ‘Adam’: 95, ‘Lisa’: 85, ‘Bart’: 59, ‘Paul’: 74 } 请计算所有同学的平均分。 123456d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59, &apos;Paul&apos;: 74 &#125;sum = 0.0for value in d.itervalues(): sum = sum + valueprint sum/len(d) 迭代dict的key和value我们了解了如何迭代 dict 的 value，那么，在一个 for 循环中，能否同时迭代 key和value？答案是肯定的。 首先，我们看看 dict 对象的 items() 方法返回的值： 123&gt;&gt;&gt; d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;&gt;&gt;&gt; print d.items()[(&apos;Lisa&apos;, 85), (&apos;Adam&apos;, 95), (&apos;Bart&apos;, 59)] 可以看到，items() 方法把dict对象转换成了包含tuple的list，我们对这个list进行迭代，可以同时获得key和value： 123456&gt;&gt;&gt; for key, value in d.items():... print key, &apos;:&apos;, value... Lisa : 85Adam : 95Bart : 59 和 values() 有一个 itervalues() 类似， items() 也有一个对应的 iteritems()，iteritems() 不把dict转换成list，而是在迭代过程中不断给出 tuple，所以， iteritems() 不占用额外的内存。 请根据dict： d = { ‘Adam’: 95, ‘Lisa’: 85, ‘Bart’: 59, ‘Paul’: 74 } 打印出 name : score，最后再打印出平均分 average : score。 1234567d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59, &apos;Paul&apos;: 74 &#125;sum = 0.0for k, v in d.iteritems(): sum = sum + v print k,&apos;:&apos;,vprint &apos;average&apos;, &apos;:&apos;, sum / len(d) 列表生成式生成列表要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，我们可以用range(1, 11)： 12&gt;&gt;&gt; range(1, 11)[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环： 123456&gt;&gt;&gt; L = []&gt;&gt;&gt; for x in range(1, 11):... L.append(x * x)... &gt;&gt;&gt; L[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list： 12&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 这种写法就是Python特有的列表生成式。利用列表生成式，可以以非常简洁的代码生成 list。 写列表生成式时，把要生成的元素 x * x 放到前面，后面跟 for 循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。 请利用列表生成式生成列表 [1x2, 3x4, 5x6, 7x8, …, 99x100] 提示：range(1, 100, 2) 可以生成list [1, 3, 5, 7, 9,…] 1print [x * (x+1) for x in range(1,100,2)] 复杂表达式使用for循环的迭代不仅可以迭代普通的list，还可以迭代dict。 假设有如下的dict： 1d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125; 完全可以通过一个复杂的列表生成式把它变成一个 HTML 表格： 12345tds = [&apos;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&apos; % (name, score) for name, score in d.iteritems()]print &apos;&lt;table&gt;&apos;print &apos;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;&apos;print &apos;\n&apos;.join(tds)print &apos;&lt;/table&gt;&apos; 注：字符串可以通过 % 进行格式化，用指定的参数替代%s。字符串的join()方法可以把一个 list 拼接成一个字符串。 把打印出来的结果保存为一个html文件，就可以在浏览器中看到效果了： 123456&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;&lt;tr&gt;&lt;td&gt;Lisa&lt;/td&gt;&lt;td&gt;85&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Adam&lt;/td&gt;&lt;td&gt;95&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Bart&lt;/td&gt;&lt;td&gt;59&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 在生成的表格中，对于没有及格的同学，请把分数标记为红色。 提示：红色可以用 实现。 123456789101112d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;def generate_tr(name, score): if score &gt; 60: return &apos;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&apos; % (name, score) else: return &apos;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td style=&quot;color:red&quot;&gt;%s&lt;/td&gt;&lt;/tr&gt;&apos; % (name, score)tds = [generate_tr(name,score) for name, score in d.iteritems()]print &apos;&lt;table border=&quot;1&quot;&gt;&apos;print &apos;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;&apos;print &apos;\n&apos;.join(tds)print &apos;&lt;/table&gt;&apos; 条件过滤列表生成式的 for 循环后面还可以加上 if 判断。例如： 12&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 如果我们只想要偶数的平方，不改动 range()的情况下，可以加上 if 来筛选： 12&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100] 有了 if 条件，只有 if 判断为 True 的时候，才把循环的当前元素添加到列表中。 请编写一个函数，它接受一个 list，然后把list中的所有字符串变成大写后返回，非字符串元素将被忽略。 提示： isinstance(x, str) 可以判断变量 x 是否是字符串； 字符串的 upper() 方法可以返回大写的字母。 1234567def toUppers(L): return [x.upper() for x in L if isinstance(x, str) ]print toUppers([&apos;Hello&apos;, &apos;world&apos;, 101])运行成功[&apos;HELLO&apos;, &apos;WORLD&apos;] 多层表达式for循环可以嵌套，因此，在列表生成式中，也可以用多层 for 循环来生成列表。 对于字符串 ‘ABC’ 和 ‘123’，可以使用两层循环，生成全排列： 12&gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;123&apos;][&apos;A1&apos;, &apos;A2&apos;, &apos;A3&apos;, &apos;B1&apos;, &apos;B2&apos;, &apos;B3&apos;, &apos;C1&apos;, &apos;C2&apos;, &apos;C3&apos;] 翻译成循环代码就像下面这样： 1234L = []for m in &apos;ABC&apos;: for n in &apos;123&apos;: L.append(m + n) 利用 3 层for循环的列表生成式，找出对称的 3 位数。例如，121 就是对称数，因为从右到左倒过来还是 121。 1print [m*100+n*10+l for m in range(1,10) for n in range(0,10) for l in range(1,10) if m == l] 问题print() 字符串的比较 Python中的高阶函数高阶函数把函数作为参数的函数就是高阶函数。 12def add(x, y, f): return f(x) + f(y) 如果传入abs作为参数f的值： 1add(-5, 9, abs) 根据函数的定义，函数执行的代码实际上是： 1abs(-5) + abs(9) 由于参数 x, y 和 f 都可以任意传入，如果 f 传入其他函数，就可以得到不同的返回值。 高阶函数任务利用add(x,y,f)函数，计算： 1234567891011import mathdef add(x, y, f): return f(x) + f(y)print add(25, 9, math.sqrt)运行成功8.0 注意：只写函数名就可以了。 Python 中的 map() 函数map()是 Py 内置的高阶函数map()是 Python 内置的高阶函数，它接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。 (注意：是 list 的每个元素，不是整个 list) 例如，对于list [1, 2, 3, 4, 5, 6, 7, 8, 9] 如果希望把list的每个元素都作平方，就可以用map()函数： 因此，我们只需要传入函数f(x)=x*x，就可以利用map()函数完成这个计算： 123def f(x): return x*xprint map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]) 输出结果： 1[1, 4, 9, 10, 25, 36, 49, 64, 81] 注意：map()函数不改变原有的 list，而是返回一个新的 list。 利用map()函数，可以把一个 list 转换为另一个 list，只需要传入转换函数。 由于list包含的元素可以是任何类型，因此，map() 不仅仅可以处理只包含数值的 list，事实上它可以处理包含任意类型的 list，只要传入的函数f可以处理这种数据类型。 map() 任务假设用户输入的英文名字不规范，没有按照首字母大写，后续字母小写的规则，请利用map()函数，把一个list（包含若干不规范的英文名字）变成一个包含规范英文名字的list： 输入：[‘adam’, ‘LISA’, ‘barT’]输出：[‘Adam’, ‘Lisa’, ‘Bart’] 12345678def format_name(s): return s.capitalize()print map(format_name, [&apos;adam&apos;, &apos;LISA&apos;, &apos;barT&apos;])运行成功[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] Python 字符串大小写转换12345678910111213str = &quot;www.runoob.com&quot;print(str.upper()) # 把所有字符中的小写字母转换成大写字母print(str.lower()) # 把所有字符中的大写字母转换成小写字母print(str.capitalize()) # 把第一个字母转化为大写字母，其余小写print(str.title()) # 把每个单词的第一个字母转化为大写，其余小写 结果：WWW.RUNOOB.COMwww.runoob.comWww.runoob.comWww.Runoob.Com python中reduce()函数reduce()函数是Py内置的高阶函数reduce()函数也是Python内置的一个高阶函数。reduce()函数接收的参数和 map()类似，一个函数 f，一个list，但行为和 map()不同，reduce()传入的函数 f 必须接收两个参数，reduce()对list的每个元素反复调用函数f，并返回最终结果值。 例如，编写一个f函数，接收x和y，返回x和y的和： 12def f(x, y): return x + y 调用 reduce(f, [1, 3, 5, 7, 9])时，reduce函数将做如下计算： 12345先计算头两个元素：f(1, 3)，结果为4；再把结果和第3个元素计算：f(4, 5)，结果为9；再把结果和第4个元素计算：f(9, 7)，结果为16；再把结果和第5个元素计算：f(16, 9)，结果为25；由于没有更多的元素了，计算结束，返回结果25。 上述计算实际上是对 list 的所有元素求和。虽然Python内置了求和函数sum()，但是，利用reduce()求和也很简单。 reduce()还可以接收第3个可选参数，作为计算的初始值。如果把初始值设为100，计算： 1reduce(f, [1, 3, 5, 7, 9], 100) 结果将变为125，因为第一轮计算是： 计算初始值和第一个元素：f(100, 1)，结果为101。 reduce() 任务Python内置了求和函数sum()，但没有求积的函数，请利用recude()来求积： 输入：[2, 4, 5, 7, 12]输出：245712的结果 12345678def prod(x, y): return x * yprint reduce(prod, [2, 4, 5, 7, 12])运行成功3360 python中filter()函数filter()函数是 Py 内置的高阶函数filter()函数接收一个函数 f 和一个list，这个函数 f 的作用是对每个元素进行判断，返回 True或 False，filter()根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list。(注意：返回的是True或 False) 例如，要从一个list [1, 4, 6, 7, 9, 12, 17]中删除偶数，保留奇数，首先，要编写一个判断奇数的函数： 12def is_odd(x): return x % 2 == 1 然后，利用filter()过滤掉偶数： 1filter(is_odd, [1, 4, 6, 7, 9, 12, 17]) 结果：[1, 7, 9, 17] 利用filter()，可以完成很多有用的功能，例如，删除 None 或者空字符串： 123def is_not_empty(s): return s and len(s.strip()) &gt; 0filter(is_not_empty, [&apos;test&apos;, None, &apos;&apos;, &apos;str&apos;, &apos; &apos;, &apos;END&apos;]) 结果：[‘test’, ‘str’, ‘END’] 注意: s.strip(rm) 删除 s 字符串中开头、结尾处的 rm 序列的字符。 当rm为空时，默认删除空白符（包括’\n’, ‘\r’, ‘\t’, ‘ ‘)，如下： 12a = &apos; 123&apos;a.strip() 结果： ‘123’ 12a=&apos;\t\t123\r\n&apos;a.strip() 结果：‘123’ filter() 任务请利用filter()过滤出1~100中平方根是整数的数，即结果应该是： [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 1234567891011import mathdef is_sqr(x): r = int(math.sqrt(x) ) return r * r == xprint filter(is_sqr, range(1, 101))运行成功[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 其他判断方法： 1return (math.sqrt(x)) % 1 == 0 1return int(r) == r py中自定义排序函数sorted()Python内置的 sorted()函数Python内置的 sorted()函数可对list进行排序： >&gt;&gt;sorted([36, 5, 12, 9, 21])[5, 9, 12, 21, 36] 但 sorted()也是一个高阶函数，它可以接收一个比较函数来实现自定义排序，比较函数的定义是，传入两个待比较的元素 x, y，如果 x 应该排在 y 的前面，返回 -1，如果 x 应该排在 y 的后面，返回 1。如果 x 和 y 相等，返回 0。 因此，如果我们要实现倒序排序，只需要编写一个reversed_cmp函数： 123456def reversed_cmp(x, y): if x &gt; y: return -1 if x &lt; y: return 1 return 0 这样，调用 sorted() 并传入 reversed_cmp 就可以实现倒序排序： 12&gt;&gt;&gt; sorted([36, 5, 12, 9, 21], reversed_cmp)[36, 21, 12, 9, 5] sorted()也可以对字符串进行排序，字符串默认按照ASCII大小来比较： 12&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;])[&apos;Credit&apos;, &apos;Zoo&apos;, &apos;about&apos;, &apos;bob&apos;] ‘Zoo’排在’about’之前是因为’Z’的ASCII码比’a’小。 sorted() 函数任务对字符串排序时，有时候忽略大小写排序更符合习惯。请利用sorted()高阶函数，实现忽略大小写排序的算法。 输入：[‘bob’, ‘about’, ‘Zoo’, ‘Credit’]输出：[‘about’, ‘bob’, ‘Credit’, ‘Zoo’] 12345678910111213def cmp_ignore_case(s1, s2): if s1.lower() &gt; s2.lower(): return 1 elif s1.lower() &lt; s2.lower(): return -1 else: return 0print sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;], cmp_ignore_case)运行成功[&apos;about&apos;, &apos;bob&apos;, &apos;Credit&apos;, &apos;Zoo&apos;] 注意： cmp() 函数在Python3.x 中已经不支持了。 sorted()函数 在Python2.x 和 Python3.x 中有所不同 python函数中返回函数返回函数Python的函数不但可以返回int、str、list、dict等数据类型，还可以返回函数！ 例如，定义一个函数 f()，我们让它返回一个函数 g，可以这样写： 1234567def f(): print &apos;call f()...&apos; # 定义函数g: def g(): print &apos;call g()...&apos; # 返回函数g: return g 仔细观察上面的函数定义，我们在函数 f 内部又定义了一个函数 g。由于函数 g 也是一个对象，函数名 g 就是指向函数 g 的变量，所以，最外层函数 f 可以返回变量 g，也就是函数 g 本身。 调用函数 f，我们会得到 f 返回的一个函数： 123456&gt;&gt;&gt; x = f() # 调用f()call f()...&gt;&gt;&gt; x # 变量x是f()返回的函数：&lt;function g at 0x1037bf320&gt;&gt;&gt;&gt; x() # x指向函数，因此可以调用call g()... # 调用x()就是执行g()函数定义的代码 请注意区分返回函数和返回值： 1234def myabs(): return abs # 返回函数def myabs2(x): return abs(x) # 返回函数调用的结果，返回值是一个数值 返回函数可以把一些计算延迟执行。例如，如果定义一个普通的求和函数： 12def calc_sum(lst): return sum(lst) 调用calc_sum()函数时，将立刻计算并得到结果： 12&gt;&gt;&gt; calc_sum([1, 2, 3, 4])10 但是，如果返回一个函数，就可以“延迟计算”： 1234def calc_sum(lst): def lazy_sum(): return sum(lst) return lazy_sum # 调用calc_sum()并没有计算出结果，而是返回函数: 123&gt;&gt;&gt; f = calc_sum([1, 2, 3, 4])&gt;&gt;&gt; f&lt;function lazy_sum at 0x1037bfaa0&gt; # 对返回的函数进行调用时，才计算出结果: 12&gt;&gt;&gt; f()10 由于可以返回函数，我们在后续代码里就可以决定到底要不要调用该函数。 返回函数任务请编写一个函数calc_prod(lst)，它接收一个list，返回一个函数，返回函数可以计算参数的乘积。 123456789101112def calc_prod(lst): def lazy_prod(): def f(x,y): return x * y return reduce(f,lst,1) return lazy_prodf = calc_prod([1, 2, 3, 4])print f()运行成功24 python中闭包在函数内部定义的函数和外部定义的函数是一样的，只是他们无法被外部访问： 123456def g(): print &apos;g()...&apos;def f(): print &apos;f()...&apos; return g 将 g 的定义移入函数 f 内部，防止其他代码调用 g： 12345def f(): print &apos;f()...&apos; def g(): print &apos;g()...&apos; return g 但是，考察上一小节定义的 calc_sum 函数： 1234def calc_sum(lst): def lazy_sum(): return sum(lst) return lazy_sum 注意: 发现没法把 lazy_sum 移到 calc_sum 的外部，因为它引用了 calc_sum 的参数 lst。 像这种内层函数引用了外层函数的变量（参数也算变量），然后返回内层函数的情况，称为闭包（Closure）。 闭包的特点是返回的函数还引用了外层函数的局部变量，所以，要正确使用闭包，就要确保引用的局部变量在函数返回后不能变。举例如下： 12345678910# 希望一次返回3个函数，分别计算1x1,2x2,3x3:def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fsf1, f2, f3 = count() 你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果全部都是 9（请自己动手验证）。 原因就是当count()函数返回了3个函数时，这3个函数所引用的变量 i 的值已经变成了3。由于f1、f2、f3并没有被调用，所以，此时他们并未计算 i*i，当 f1 被调用时： 12&gt;&gt;&gt; f1()9 # 因为f1现在才计算i*i，但现在i的值已经变为3 因此，返回函数不要引用任何循环变量，或者后续会发生变化的变量。 考察下面的函数 f: 1234def f(j): def g(): return j*j return g 它可以正确地返回一个闭包g，g所引用的变量j不是循环变量，因此将正常执行。 在count函数的循环内部，如果借助f函数，就可以避免引用循环变量i。 参考代码: 123456789101112def count(): fs = [] for i in range(1, 4): def f(j): def g(): return j*j return g r = f(i) fs.append(r) return fsf1, f2, f3 = count()print f1(), f2(), f3() 12345678910def count(): fs = [] for i in range(1, 4): def f(i): return lambda : i * i fs.append(f(i)) return fsf1, f2, f3 = count()print f1(), f2(), f3() python中匿名函数高阶函数可以接收函数做参数，有些时候，我们不需要显式地定义函数，直接传入匿名函数更方便。 在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算 f(x)=x2 时，除了定义一个f(x)的函数外，还可以直接传入匿名函数： 12&gt;&gt;&gt; map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9])[1, 4, 9, 16, 25, 36, 49, 64, 81] 通过对比可以看出，匿名函数 lambda x: x * x 实际上就是： 12def f(x): return x * x 关键字lambda 表示匿名函数，冒号前面的 x 表示函数参数。 匿名函数有个限制，就是只能有一个表达式，不写return，返回值就是该表达式的结果。 使用匿名函数，可以不必定义函数名，直接创建一个函数对象，很多时候可以简化代码： 12&gt;&gt;&gt; sorted([1, 3, 9, 5, 0], lambda x,y: -cmp(x,y))[9, 5, 3, 1, 0] 返回函数的时候，也可以返回匿名函数： 12345&gt;&gt;&gt; myabs = lambda x: -x if x &lt; 0 else x &gt;&gt;&gt; myabs(-1)1&gt;&gt;&gt; myabs(1)1 任务利用匿名函数简化以下代码： 123def is_not_empty(s): return s and len(s.strip()) &gt; 0filter(is_not_empty, [&apos;test&apos;, None, &apos;&apos;, &apos;str&apos;, &apos; &apos;, &apos;END&apos;]) 定义匿名函数时，没有return关键字，且表达式的值就是函数返回值。 参考代码: 1print filter(lambda s: s and len(s.strip())&gt;0, [&apos;test&apos;, None, &apos;&apos;, &apos;str&apos;, &apos; &apos;, &apos;END&apos;]) python中无参数decoratorPython的 decorator 本质上就是一个高阶函数，它接收一个函数作为参数，然后，返回一个新函数。 使用 decorator 用Python提供的 @ 语法，这样可以避免手动编写f = decorate(f) 这样的代码。 考察一个@log的定义： 12345def log(f): def fn(x): print &apos;call &apos; + f.__name__ + &apos;()...&apos; return f(x) return fn 对于阶乘函数，@log工作得很好： 1234@logdef factorial(n): return reduce(lambda x,y: x*y, range(1, n+1))print factorial(10) 结果： 12call factorial()...3628800 但是，对于参数不是一个的函数，调用将报错： 1234@logdef add(x, y): return x + yprint add(1, 2) 结果： 1234Traceback (most recent call last): File &quot;test.py&quot;, line 15, in &lt;module&gt; print add(1,2)TypeError: fn() takes exactly 1 argument (2 given) 因为 add() 函数需要传入两个参数，但是 @log 写死了只含一个参数的返回函数。 要让 @log 自适应任何参数定义的函数，可以利用Python的 args 和 *kw，保证任意个数的参数总是能正常调用： 12345def log(f): def fn(*args, **kw): print &apos;call &apos; + f.__name__ + &apos;()...&apos; return f(*args, **kw) return fn 现在，对于任意函数，@log 都能正常工作。 任务请编写一个@performance，它可以打印出函数调用的时间。 12345678910111213141516171819202122import timedef performance(f): def fn(*args, **kw): t1 = time.time() r = f(*args, **kw) t2 = time.time() print &apos;call %s() in %fs&apos; % (f.__name__,(t2-t1)) return r return fn @performancedef factorial(n): return reduce(lambda x,y: x*y, range(1, n+1))print factorial(10)运行成功call factorial() in 0.004240s3628800]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git 原理详解及实用指南]]></title>
    <url>%2F2017%2F12%2F18%2FJuejin-Git-renwuxian%2F</url>
    <content type="text"><![CDATA[1. 什么是版本控制系统？版本控制：最基本功能版本控制系统（Version Control System - VCS）最基本的功能是版本控制。所谓版本控制，就是在文件的修改历程中保留修改历史，让你可以方便地撤销之前对文件的修改操作。如 「撤销（Undo）」功能。当你按下「撤销」的时候，它就帮你把内容回退到上一个状态；同理，按一次是会退到上一个版本，按两次就是回退到上上一个版本。 写程序的时候同样也难免会遇到「写错」的情况，所以程序的 VCS，当然也会需要版本控制功能，这样当你发现「昨天有一行代码写错了」，你就不用凭着记忆把那段代码背出来，而只需要在 VCS 中选择撤回到昨天的那个版本。 主动提交：程序代码和普通文本的区别程序代码的修改的生命周期非常长。一次代码的修改，在几天后、几个月后、几年后都有可能需要被翻出来。如果依然采用「每次改动自动保存」的形式来保留修改历史，将会导致改动历史非常频繁和无章可循，这样，历史代码的查找、阅读和回退就会很困难了。所以，和文本编辑器的撤销功能不同，VCS 保存修改历史，使用的是主动提交改动的机制。 在你写了一段完整的代码（例如修复了一个 bug）之后，使用 commit 命令把改动和对改动的描述信息提交，这次改动就被记录到版本历史中了。之后如果你希望回退到这个版本，就可以从 VCS 的历史日志中方便地找到它。 多人合作的同步需求：中央仓库代码可以一个人写，但更多的时候会是多个人共同开发。那么自然地，就需要有一个中央仓库作为代码的存储中心：所有人的改动都会上传到这里，所有人都能也都能看到和下载到别人上传的改动。 这样，解决了同步的需求，多个人在不同的机器上开发同一个程序就成了可能。 版本控制、主动提交、中央仓库这三个要素，共同构成了版本控制系统（VCS）的核心：开发团队中的每个人向中央仓库主动提交自己的改动和同步别人的改动，并在需要的时候查看和操作历史版本，这就是版本控制系统. 中央式版本控制系统最初的版本控制系统，是中央式版本控制系统（Centralized VCS），也就是前面我讲的这种。Git 是分布式的版本控制系统（Distributed VCS），现在先说一下中央式版本控制系统的工作模型。 工作模型： 假设你在一个三人团队，你们计划开发一个软件或者系统，并决定使用中央式 VCS 来管理代码。于是： 作为项目的主工程师，你独自一人花两天时间搭建了项目的框架； 然后，你在公司的服务器（这个服务器可以是公司内的设备，也可以是你们买的云服务）上创建了一个中央仓库，并把你的代码提交到了中央仓库上； 你的两个队友从中央仓库取到了你的初始代码，从此刻开始，你们三人开始并行开发； 在之后的开发过程中，你们三人为了工作方便，总是每人独立负责开发一个功能，在这个功能开发完成后，这个人就把他的这些新代码提交到中央仓库； 每次当有人把代码提交到中央仓库的时候，另外两个人就可以选择把这些代码同步到自己的机器上，保持自己的本地代码总是最新的。 而对于团队中的每个人来说，就会更简单一点： 第一次加入团队时，把中央仓库的代码取下来； 写完的新功能提交到中央仓库； 同事提交到中央仓库的新代码，及时同步下来。 这样，一个三人的团队就成功做到了各自在自己的电脑上开发同一个项目，并且互不影响，就好像你们三个人是在同一台电脑上操作一样。 这就是中央式 VCS 最基本的工作模型。当然，实际的开发工作并没有简单到这种程度，因为你时常会需要处理代码冲突、查看版本历史、回退代码版本等；另外，Git 属于分布式 VCS，它的概念也比中央式 VCS 要复杂一些。 中央式 VCS 的中央仓库有两个主要功能：保存版本历史、同步团队代码。 2. 什么是分布式版本控制系统（DVCS）？分布式 VCS （Distributed VCS / DVCS）和中央式的区别在于，分布式 VCS 除了中央仓库之外，还有本地仓库：团队中每一个成员的机器上都有一份本地仓库，这个仓库里包含了所有的版本历史，或者换句话说，每个人在自己的机器上就可以提交代码、查看历史，而无需联网和中央仓库交互——当然，取而代之的，你需要和本地仓库交互。 中央式 VCS 的中央仓库有两个主要功能：保存版本历史、同步团队代码。而在分布式 VCS 中，保存版本历史的工作转交到了每个团队成员的本地仓库中，中央仓库就只剩下了同步团队代码这一个主要任务。它的中央仓库依然也保存了历史版本，但这份历史版本更多的是作为团队间的同步中转站。 工作模型： 依然以三人团队为例，分布式 VCS 的工作模型大致是这样： 首先，你作为主工程师，独立搭建了项目架构，并把这些代码提交到了本地仓库； 然后，你在服务器上创建了一个中央仓库，并把 1 中的提交从本地仓库推送到了服务器的中央仓库； 其他同事把中央仓库的所有内容克隆到本地，拥有了各自的本地仓库，从此刻开始，你们三人开始并行开发； 在之后的开发过程中，你们三人总是每人独立负责开发一个功能，在这个功能开发过程中，一个人会把它的每一步改动提交到本地仓库。注意：由于本地提交无需立即上传到中央仓库，所以每一步提交不必是一个完整功能，而可以是功能中的一个步骤或块。 在一个人把某个功能开发完成之后，他就可以把这个功能相关的所有提交从本地仓库推送到中央仓库； 每次当有人把新的提交推送到中央仓库的时候，另外两个人就可以选择把这些提交同步到自己的机器上，并把它们和自己的本地代码合并。 可以看出，这个工作模型和上一节讲的「中央式 VCS 的工作模型」很相似，只是把代码的提交和上传过程拆开了。 另外，和上节讲的中央式 VCS 工作模型一样，这个也只是分布式 VCS 的一个最基本的工作模型，实际的开发工作会比这个麻烦和复杂。 3. 快速上手 Git点击右上角的「New Repository」来新建远程仓库； 进入仓库设置页面填写信息：仓库名会被 GitHub 设置为你的仓库的根目录的名称，.gitignore 是 Git 仓库中的一个特殊的文本文件，它里面记录了你不希望提交到仓库的目录和文件的名称或类型，例如你的 /build 目录，然后完成远程仓库的创建。 点击右边的「Clone or download」，然后把仓库的 clone 地址复制到剪贴板。接下来就可以把远程仓库取下来了。取的方式很简单：在 Terminal 或 cmd 中切换到你希望放置项目的目录中，然后输入： 1git clone 你刚复制的地址 Git 就会把你的远程仓库 clone 到本地。你会看到你的当前目录下多了一个新的子目录，它的名字和刚才新建的 GitHub 仓库名一致：进入这个目录，你会发现这里除了你刚才添加的 LICENSE 和 .gitignore 文件外，还有一个叫做 .git 的隐藏目录。这个 .git 目录，就是你的本地仓库（Local Repository），你的所有版本信息都会存在这里。而 .git 所在的这个根目录，称为 Git 的工作目录（Working Directory），它保存了你当前从仓库中签出（checkout）的内容。现在你在项目的目录下输入：]]></content>
  </entry>
  <entry>
    <title><![CDATA[李旭口语]]></title>
    <url>%2F2017%2F11%2F26%2FPronunciation-of-Miss-Li%2F</url>
    <content type="text"><![CDATA[音标元音 = 韵母，口型固定，气流喷出 辅音 = 声母，受嘴唇、舌头、牙齿结合 发音就是 单独的元音 或 辅音 + 元音 元音分为：前元音、中元音、后元音。（单元音，双元音只是分类方法不同，意义一样） 前元音【 i 】：很短促的叫人：衣（诶） ship shit me i、y结尾 发这个【 i 】音，pig,many。y在词首部读【j】 【 i :】：等于【i】到【j】（夜）滑动的音（一夜） sheep sheet ee、ea 发这个【 i :】音 【 e 】：小口型的林黛玉式的 哎 bed best said。e 、ea、ai 发这个音 【 æ 】：大口型的 ╮(╯▽╰)╭哎 bad apple ，a 发这个音 美式发音和英式发言连读规则重音语调场景考试口语音乐]]></content>
  </entry>
  <entry>
    <title><![CDATA[Teacher Li's 大学英语六级听力之“连读”]]></title>
    <url>%2F2017%2F11%2F17%2FTeacher-Li-s-%E5%A4%A7%E5%AD%A6%E8%8B%B1%E8%AF%AD%E5%85%AD%E7%BA%A7%E5%90%AC%E5%8A%9B%E4%B9%8B%E2%80%9C%E8%BF%9E%E8%AF%BB%E2%80%9D%2F</url>
    <content type="text"><![CDATA[链接：视频：大学英语六级听力之“连读” 辅音 + 辅音失去爆破：前面一个音节以辅音结尾，通常是 p 、 k 、 t、b 、g 、d，且后面一个音节以不同的辅音开头，在一起时，要失爆。第一个辅音只做口型，不读出声音。听力中有停顿，说明可能是失去爆破。 blackboard breakfast sit down hot day good teacher bad boy could be put it down t 和 d 是两个辅音， put it down（注意，t 后面跟一个元音时，u 不发 ʌ 音，发 ə 音） 击穿针对于 h，它放词首，且不是重读音节，则不做口型，不出气，即不发音。飘出来的 「和」，除非你想强调，要读出来。 i like her in his car ask him 叠合前面结尾的辅音和后面开头的辅音一样，且不是重读音节，就是叠合现象，这时，只读其中的一个发音。除非你想强调，要读出来。 a bad dog good day take care ( 注意这个发音和 take air 一样) i like candy a tame monkey book case a big game 辅音 + 元音 （最常见）前一个音节的结尾辅音，跟后一个音节的开头元音，连在一起拼读。 knock at look into look out take up 但是还有四个，前面结尾的要发音，后面的还要连读在一起： [ r ] + 元音[ r ] 发言结尾，且后面是元音时，r （儿化音）要读出来，还要再跟后面的元音连读 Your answer are excellent. 当主语和系动词都要连时，连主语。 I have read your article. far away for instance a number of 【 l 】+ 元音[ l ] 发二分之一的了音，以下单词发这个音：l、ll、le [ l ] 发言结尾，且后面是元音时，要跟后面的元音连读。 couple of double of LED Li 读成 Llai 的音 LEE L double e i will ask him later 007: double O seven 【 n 】+ 元音[ n ] 发言结尾，且后面是元音时，要跟后面的元音连读。 an apple 必然连读，否则是错的，除非特殊强调。 an answer an article in a hotel an old lady pen and paper in an instant （发生两次连读，第一次是n + a,第二次是 n+i） open an account (发生两次连读，第一次是n + a,第二次是 n+a） 1980： nineteen eigthy 【 t 】+ 元音[ t ] + 元音，则变成介于 t 与 d 之间的弹射音 city 美国人发生音变有3个规则： [ t ] 音在音节的中间 [ t ] 音前面是一个元音 [ t ] 音不是重读音 get in get out so it is get in get it out of here put it off take it easy not at all keep it up not alone 元音 + 元音加半元音【w】当前面单词以 [əu]、[ɑu]、[u]、[u:]结尾，后面单词以元音开头，在一起连读时，要加半元音【w】,感觉像【温】音 just do it go on no end doing going who else too often you are 加半元音【j】当前面单词以 [ei]、[ɑi]、[ɔi]、[i]结尾，后面单词以元音开头，在一起连读时，要加半元音【j】,感觉像【耶】音 be on time say it see it she is try it may i i am weigh i*t u*p (两次连读，第一次是加 【j】，第二次是t变d，连读u) 连读音变 【t】 +【j】=【ʧ】 why don’t you come here? i want you nice to meet you 【d】+【j】=【ʤ】 would you please… could you please… how did you get there.. 【s】+【j】=【ʃ】 i miss you unless you know how to get there]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 使用]]></title>
    <url>%2F2017%2F11%2F09%2FAndroid-Studio-%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[快捷键上下移动代码： OXS/Win/Linux : Alt + Shift + Up/Down 删除行： OSX : Cmd + Delete Win/Linux : Ctrl + Y 快捷向下复制行： OSX : Cmd + D Win/Linux : Ctrl + D 快捷覆写方法： OSX : Ctrl + O Win/Linux : 注释代码 ( // )： OSX : Cmd + / Win/Linux : 注释代码 ( /**/ )： OSX : Cmd + Alt + / Win/Linux : 格式化代码： OSX : Cmd + Alt + L Win/Linux : 快捷最近打开： OSX : Cmd + E Win/Linux : Ctrl + E 清除无效 import ： OSX : Alt + Control + O Win/Linux:Alt + Control + O 代码补全 : OSX : Cmd + Shift + Enter Win/Linux : Ctrl + Shift + Enter 提示错误解决方案 : OSX : Alt + Enter Win/Linux : Alt + Enter 提示参数类型 : OSX : Cmd + P Win/Linux : Ctrl + P 查找+替换 : OSX : Cmd + R Win/Linux : Ctrl + R 查找 : OSX : Cmd + F Win/Linux : Ctrl + F 类注释自动生成说明类注释： 添加以下内容： 1234567/** * 项目名： $&#123;PROJECT_NAME&#125; * 包名： $&#123;PACKAGE_NAME&#125; * 文件名： $&#123;NAME&#125; * Created by $&#123;USER&#125; on $&#123;DATE&#125;. * 描述： TODO */]]></content>
      <categories>
        <category>Android</category>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[英文词串 - 英语流利说]]></title>
    <url>%2F2017%2F11%2F06%2FEnglish-word-phrase%2F</url>
    <content type="text"><![CDATA[英语六级口语考试自我介绍 语音一定要准（第一印象很重要） 语速不要过快或过慢（20秒，40-50词为最佳） 适当使用连续以增加语言的流畅度，有快有慢 不要面面俱到，找一两个方向，展开一两句即可 六级考生还要根据自己的自我介绍准备可能考官追问的问题 名字问题可以不说 自我介绍部分思考方向： 年龄，专业 大学介绍 i am from … university,she is a famous beatiful school name love in here. 性格特点 家庭背景 业余爱好 家乡景点 百度搜 地名+英文介绍可以参考 自我介绍注意停顿和连读就更好一些，每一个发言一定要准确。 先写100词的自我介绍，再按照连读规则，把施爆的地方划掉，连读音变加上，语速增加、减缓画出来，读音注意的地方画上，背下来，录下来，听哪里不好再改 老师问问题，基于你自己所说的东西问，回答的时候，挑自己会说的回答，不一定是实话。 图片 so, what do you say? 巴拉巴拉说了一堆后，询问对方的意见。]]></content>
      <categories>
        <category>英语</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[带领新手快速开发 Android App]]></title>
    <url>%2F2017%2F11%2F02%2Fimooc-Quick-develop-Android-App%2F</url>
    <content type="text"><![CDATA[借助流行的第三方 SDK 及框架，开发“生活小助手 App ”。 用户管理登录注册忘记密码语音机器人聊天微信精选文章物流及电话号码归属地查询美女相册个性化二维码扫描与生成定位与查看地图]]></content>
      <categories>
        <category>慕课网</category>
        <category>带领新手快速开发 Android App</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程小白的第一本 Python 入门书]]></title>
    <url>%2F2017%2F11%2F02%2FFirst-Python%2F</url>
    <content type="text"><![CDATA[变量定义变量的名字叫做标识符。 1a = 12 这样就完成了 a 的赋值，试着回车换行并输入 a ，再回车之后，你会看到赋值的结果是12。 注意：Python 对 大 小 写 敏 感， 也 就 是 说 “a” 和 “A” 会 是 两 个 不 同 的 变 量， 而 不 是 同 一 个。 如 果 你 不 知 道 变 量 是 什 么 类 型， 可 以 通 过 type() 函 数 来 查 看 类 型， 在 IDE 中 输 入 1print( type( word)) 中 文 注 释 会 导 致 报 错， 所 以 需 要 在 文 件 开 头 加 一 行 注 释 #coding:utf-8 ，也 可 以 在 设 置 里 面 找 到 “File Encodings” 设 置 为 UTF-8 。 转换数据类型num = int(string) 字符串定义字符串就是…… 字符串相乘123456words = &apos;爱&apos; * 3print(words)结果；爱爱爱 字符串的分片与索引字 符 串 可 以 通 过 string[ x] 的 方 式 进 行 索 引、 分 片， 也 就 是 加 一 个 [] 。字 符 串 的 分 片( slice) 实 际 上 可 以 看 作 是 从 字 符 串 中 找 出 来 你 要 截 取 的 东 西， 复 制 出 来 一 小 段 你 要 的 长 度， 储 存 在 另 一 个 地 方， 而 不 会 对 字 符 串 这 个 源 文 件 改 动。 分 片 获 得 的 每 个 字 符 串 可 以 看 作 是 原 字 符 串 的 一 个 副 本。 1234567891011121314name = &apos;My Name is Mike&apos;print(name[0])&apos;M&apos;print(name[-4])&apos;M&apos;print(name[11:14]) # from 11th to 14th, 14th one is excluded&apos;Mik&apos;print(name[11:15]) # from 11th to 15th, 15th one is excluded&apos;Mike&apos;print(name[5:]) &apos;me is Mike&apos;print(name[:5]) &apos;My Na&apos; : 两边分别代表着字符串的分割从哪里开始，并到哪里结束。 以 name[11:14] 为例，截取的编号从第11个字符开始，到位置为14但不包含第14个字符结束。 而像 name[5:] 这样的写法代表着从编号为5的字符到结束的字符串分片。 相反， name[:5] 则代表着从编号为0的字符开始到编号为5但不包含第5个字符的字符分片。 ###string.replace(） 很多时候你使用手机号在网站注册账户信息，为了保证用户的信息安全性，通常账户信息只会显示后四位，其余的用 * 来代替，我们试着用字符串的方法来完成这一个功能。 输入代码： 123phone_number = &apos;1386-666-0006&apos;hiding_number = phone_number.replace(phone_number[:9],&apos;*&apos; * 9)print(hiding_number) 其中我们使用了一个新的字符串方法 replace(）进行“遮挡”。replace 方法的括号中，第一个 phone_number[:9] 代表要被替换掉的部分，后面的 &#39;*&#39; * 9 表示将要替换成什么字符，也就是把 * 乘以9，显示9个 * 。 你会得到这样的结果：*********0006 string.find() 号码联想模拟手机通讯簿中的电话号码联想功能。 输入代码： 1234567891011search = &apos;168&apos;num_a = &apos;1386-168-0006&apos;num_b = &apos;1681-222-0006&apos;print(search + &apos; is at &apos; + str(num_a.find(search) + 1) + &apos; to &apos; + str(num_a.find(search) + len(search)) + &apos; of num_a&apos;)print(search + &apos; is at &apos; + str(num_b.find(search) + 1) + &apos; to &apos; + str(num_b.find(search) + len(search)) + &apos; of num_b&apos;)或者print(search, &apos;is at&apos;, num_a.find(search)+1,&apos;to&apos;,num_a.find(search)+len(search),&apos;of num_a&apos;)print(search, &apos;is at&apos;, num_b.find(search)+1,&apos;to&apos;,num_b.find(search)+len(search),&apos;of num_b&apos;) 你会得到这样的结果，代表了包含168的所有手机号码 12168 is at 6 to 8 of num_a168 is at 1 to 3 of num_b 字符串格式化符123____a word she can get what she ____ for. A.With B.came 这样的填空题会让我们印象深刻，当字符串中有多个这样的“空”需要填写的时候，我们可以使用 .format（） 进行批处理，它的基本使用方法有如下几种，输入代码： 123print(&apos;&#123;&#125; a word she can get what she &#123;&#125; for.&apos;.format(&apos;With&apos;,&apos;came&apos;))print(&apos;&#123;preposition&#125; a word she can get what she &#123;verb&#125; for&apos;.format(preposition = &apos;With&apos;,verb = &apos;came&apos;))print(&apos;&#123;0&#125; a word she can get what she &#123;1&#125; for.&apos;.format(&apos;With&apos;,&apos;came&apos;)) 这种字符串填空的方式使用很广泛，例如下面这段代码可以填充网址中空缺的城市数据： 12city = input(&quot;write down the name of city:&quot;)url = &quot;http://apistore.baidu.com/microservice/weather?citypinyin=&#123;&#125;&quot;.format(city) 注:这是利用百度提供的天气api实现客户端天气插件的开发的代码片段 函数###定义 函数，这里面先介绍几个常见的词： def（即 define，定义）的含义是创建函数，也就是定义一个函数。 arg （即 argument，参数）有时你还能见到这种写法：parameter，二者都是参数的意思但是稍有不同，这里不展开说了。 return 即返回结果。 好，现在我们读一遍咒语：Define a function named ‘function’ which has two arguments : arg1 and arg2，returns the result——‘Something’ 需要注意的是： def 和 return 是关键字（keyword） 闭合括号后面的冒号必不可少 如果在IDE中冒号后面回车（换行），你会自动地得到一个缩进。函数缩进后面的语句被称作是语句块（block），缩进是为了表明语句和逻辑的从属关系。具有相同缩进量的代码实际上是在共同完成相同层面的事情 现在我们看一下之前提到的摄氏度转化公式，按照上面定义函数的方法来实现一遍。我们把摄氏度转化定义为函数 fahrenheit_Converter() ，那么将输入进去的必然是摄氏度（Celsius）的数值，我们把 C 设为参数，最后返回的是华氏度（fahrenheit）的数值，我们用下面的函数来表达，输入代码： 123def fahrenheit_converter(C): fahrenheit = C * 9/5 + 32 return str(fahrenheit) + &apos;˚F&apos; 注：计算的结果类型是float，不能与字符串“ºF”相合并，所以需要先用str()函数进行转换 12C2F = fahrenheit_converter(35)print(C2F) 我们把刚才的函数按照如下进行修改： 123def fahrenheit_converter(C): fahrenheit = C * 9/5 + 32 print(str(fahrenheit) + &apos;˚F&apos;) 怎么样？看上去很相似吧？没错，我们仅仅就是把最后一行的 return 换成了 print 函数，一个很小的改动，而且似乎 IDE 也并没有对语法进行报错预警，那么我们来试一下调用函数会是什么情况吧： 12C2F = fahrenheit_converter(35)print(C2F) 运行起来的结果是这样的： 1295.0˚F None 其实，得到这样的结果是因为 print 是一个函数，并非关键字。如果你足够细心的话可以发现，在 IDE 中，虽说 print 与 return 它们都是蓝色，但实际是有区分的：一个是正常体，一个是斜体。return 作为关键字在函数中起到了返回值的作用，而 print 顾名思义，只是在函数中展示给我们打印的结果。因此上面的 95.0ºF 实际上是调用函数后产生的数值，而下面的 None正是此时变量 C2F 中所被返回到的数值——什么都没有，就因为没有关键字 return 。 没有 return 也没关系，不代表没有用，在 Python 中 return 是可选的（optional），这意味着你可以不用写 return 也可以顺利地定义一个函数并使用，只不过返回值是 ‘None’ 罢了。在后面我们还能见到不同使用方式的函数，这里只需要记住函数的基本设定即可。 在前面我们提到过，定义一个函数是使用 def（define），同时我们还能在各种教材不同版本的翻译中看到声明（declare）这个词，我们不难推测，从表达的目的上来说他们是一样的，但对于有其他语言基础的人来说，这两个词意味着两种不同的行为。其实没关系，在 Python 中 definition 和 declaration 是一体的。 传递参数与参数类型传递参数的方式有两种： 我们把函数的名称定为 trapezoid_area，也就是梯形面积，设定参数为 base_up（上底），base_down（下底），height（高），每一个都用英文输入法的逗号隔开。梯形的面积需要知道这三个值才能求得，因此对于构造梯形面积的函数来说，这三个参数缺一不可。 12def trapezoid_area(base_up, base_down, height): return 1/2 * (base_up + base_down) * height 接下来我们开始调用函数。 1trapezoid_area(1,2,3) 不难看出，填入的参数 1，2，3 分别对应着参数 base_up，base_down 和 height。 这种传入参数的方式被称作为位置参数。 接着是第二种传入方式： 1trapezoid_area(base_up=1, base_down=2, height=3) 更直观地，在调用函数的时候，我们将每个参数名称后面赋予一个我们想要传入的值。这种以名称作为一一对应的参数传入方式被称作是关键词参数。 按照下面几种方式调用函数并打印结果： 1234trapezoid_area(height=3, base_down=2, base_up=1) # RIGHT!trapezoid_area(height=3, base_down=2, 1) # WRONG!trapezoid_area(base_up=1, base_down=2, 3) # RIGHT!trapezoid_area(1, 2, height=3) # RIGHT! 第一行的函数参数按照反序传入，因为是关键词参数，所以并不影晌函数正常运作； 第二行的函数参数反序传入，但是到了第三个却变成了位置参数，遗憾的是这种方式是错误的语法，因为如果按照位置来传入，最后一个应该是参数 height 的位置。 但是前面 height 已经按照名称传入了值3，所以是冲突的。 第三行的函数参数正序传入，前两个是以关键词的方式传入，最后一个以位置参数传入，这个函数是可以正常运行的； 第四行的函数参数正序传入，前两个是以位置的方式传入，最后一个以关键词参数传入，这个函数是可以正常运行的。 ###默认参数 你只需要这样输入代码： 12def trapezoid_area(base_up, base_down, height=3): return 1/2 * (base_up + base_down) * height 给一个参数设定默认值，只需要在定义参数的时候给参数赋值即可。这样一来，我们只需要传入两个参数就可以正常进行了： 1trapezoid_area(1, 2) 默认参数是可选的，这意味着即使你上来不给它传入什么东西，函数还是可以正常运作。 之前看到的 print 函数的小把戏也正是如此，print 的可选参数 sep（意为每个打印的结果以…分开）的默认值为‘ ’空格，但是我们将其重新传入‘／n’也就是换行的意思，一句话说，也就是将每个打印的数以换行符号进行分割。下面我们来调用自己的参数： 1trapezoid_area(1, 2, height=15) 只需要传入我们想要的值就可以了，就是这么简单。 默认值并非是你掌握参数使用的必要知识，却是能帮助我们节省时间的小技巧。在实际项目中也经常会看见这样： 1requests.get(url, headers=header) 注：请求网站时 header，可填可不填 1img.save(img_new, img_format, quality=100) 注：给图片加水印的时候，默认的水印质量是100 ###练习题1. 求直角三角形的边 中级难度：设计一个求直角三角形斜边长的函数（两条直角边为参数，求最长边） 如果直角边边长分分别为3和4，那么返回的结果应该像这样： 1The right triangle third side&apos;s length is 5.0 12345678import numpydef the_longest_line(agron1,agron2): the_longest_line = numpy.sqrt(numpy.square(agron1) + numpy.square(agron2)) return the_longest_lineprint(the_longest_line(3,4)) 报错：这个错应该是因为 import numpy 导包出错 1234567891011121314151617181920212223242526Traceback (most recent call last): File &quot;/Users/yangtielong/Workspace/PythonWorkspace/string.py&quot;, line 46, in &lt;module&gt; import numpy File &quot;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/numpy/__init__.py&quot;, line 142, in &lt;module&gt; from . import add_newdocs File &quot;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/numpy/add_newdocs.py&quot;, line 13, in &lt;module&gt; from numpy.lib import add_newdoc File &quot;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/numpy/lib/__init__.py&quot;, line 8, in &lt;module&gt; from .type_check import * File &quot;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/numpy/lib/type_check.py&quot;, line 11, in &lt;module&gt; import numpy.core.numeric as _nx File &quot;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/numpy/core/__init__.py&quot;, line 74, in &lt;module&gt; from numpy.testing.nosetester import _numpy_tester File &quot;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/numpy/testing/__init__.py&quot;, line 10, in &lt;module&gt; from unittest import TestCase File &quot;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/unittest/__init__.py&quot;, line 59, in &lt;module&gt; from .case import (TestCase, FunctionTestCase, SkipTest, skip, skipIf, File &quot;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/unittest/case.py&quot;, line 6, in &lt;module&gt; import logging File &quot;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/logging/__init__.py&quot;, line 28, in &lt;module&gt; from string import Template File &quot;/Users/yangtielong/Workspace/PythonWorkspace/string.py&quot;, line 52, in &lt;module&gt; print(the_longest_line(3,4)) File &quot;/Users/yangtielong/Workspace/PythonWorkspace/string.py&quot;, line 49, in the_longest_line the_longest_line = numpy.sqrt(numpy.square(agron1) + numpy.square(agron2))AttributeError: module &apos;numpy&apos; has no attribute &apos;sqrt&apos; 假设 a=10, b=20，则运算示例如下： 这个除法是错的，正确的如下： 在Python中，有两种除法，一种除法是/： &gt;&gt;&gt; 10 / 3 3.3333333333333335 /除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数： &gt;&gt;&gt; 9 / 3 3.0 还有一种除法是//，称为地板除，两个整数的除法仍然是整数： &gt;&gt;&gt; 10 // 3 3 整数的地板除//永远是整数，即使除不尽。要做精确的除法，使用/就可以。 因为//除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数： &gt;&gt;&gt; 10 % 3 1 无论整数做//除法还是取余数，结果永远是整数。 之后用了**之后的做法： 12345678def the_longest_line(agron1, agron2): return &apos;the longest line is &#123;&#125;&apos;.format((agron2**2+agron1**2)**(1/2))print(the_longest_line(4, 3))结果：the longest line is 5.0 练习题2. 敏感词过滤open(‘file_path’,’w’)文件操作： 12345desktop_path = &apos;/Users/yangtielong/Desktop/&apos;full_path = desktop_path + name + &apos;.txt&apos;file = open(full_path,&apos;w&apos;)file.write(msg)file.close() 生成文件并过滤敏感词 lame 12345678910111213141516171819202122232425def text_create(name,msg): desktop_path = &apos;/Users/yangtielong/Desktop/&apos; full_path = desktop_path + name + &apos;.txt&apos; file = open(full_path,&apos;w&apos;) file.write(msg) file.close() print(&apos;Done&apos;)# text_create(&apos;hello&apos;,&apos;hello2018&apos;)def text_filter(word,censored_word = &apos;lame&apos;,changed_word = &apos;awesome&apos;): text = word.replace(censored_word,changed_word) return text# print(text_filter(&apos;wangzhuning is lame&apos;))def text_censored_create(name, msg): msg2 = text_filter(msg) text_create(name, msg2)text_censored_create(&apos;hello2018&apos;,&apos;2018 is lame&apos;) 循环与判断逻辑判断一一True &amp; False布尔类型（Boolean）的数据只有两种，True 和 False （需要注意的是首字母大写）。 能够产生一个布尔值的表达式为布尔表达式（Boolean Expressions）。 注：使用命令行/终端只为更快展现结果，在IDE返回布尔值仍旧需要使用 print 函数来实现。 12345671 &gt; 2 # False1 &lt; 2 &lt;3 # True42 != &apos;42&apos; # True&apos;Name&apos; == &apos;name&apos; # False&apos;M&apos; in &apos;Magic&apos; # Truenumber = 12 number is 12 # True可以看到，上面这些能够产生布尔值的方法或者公式不尽相同，那么我们来一一讲解这些运算符号的意义和用法。 Python 中任何对象都可判断其布尔值，除了 0、None 和所有空的序列与集合（列表，字典，集合）布尔值为 False 之外，其它的都为 True ，我们可以使用函数 bool() 进行判别： 12345bool(0) #Falsebool([]) #Falsebool(&apos;&apos;) #Falsebool(False) #Falsebool(None) #False 当你想设定一个变量，但又没想好它应该等于什么值时，你就可以这样： 1a_thing = None 比较运算（Comparison)对于比较运算符，顾名思义，如果比较式成立那么则返回 True，不成立则返回 False。 除了一些在数学上显而易见的事实之外，比较运算还支持更为复杂的表达方式，例如： 多条件的比较。在多条件下比较大小： 12middle = 51 &lt; middle &lt; 10 字符串的比较。其实就是对比左右两边的字符串是否完全一致，下面的代码就是不一致的，因为在 Python 中有着严格的大小写区分： 1&apos;Eddie Van Helen&apos; == &apos;eddie van helen&apos; 两个比较运算符两边会先行调用函数后再进行比较， 真结果等价于 10 &gt; 19 ： 1abs(-10) &gt; len(&apos;length of this word&apos;) 注：abs( )是一个会返回输入参数的绝对值的函数。 比较运算的一些小问题使用 “＝＝” 这种表达方式，姑且可以理解成是表达两个对象的值是相等的。 不同类型的对象不能使用“&lt;,&gt;,&lt;=,&gt;=”进行比较，却可以使用’==’和’!=’，例如字符串和数字： 12342 &gt; &apos;the answer&apos; #无法比较 42 == &apos;the answer&apos; #False42 != &apos;the answer&apos; #True 需要注意的是，浮点和整数虽是不同类型，但是不影响到比较运算： 125.0 == 5 #True3.0 &gt; 1 #True 比较了字符串、浮点、整数……还差一个类型没有进行比较：布尔类型，那么现在实验一下： 12True &gt; FalseTrue + False &gt; False + False True 和 False 对于计算机就像是1和0一样，如果在命令行中敲入 True + True + False 查看结果不难发现，True ＝ 1， False ＝ 0 也就是说，上面这段代码实际上等价于： 121 &gt; 01 + 0 &gt; 0 + 0 如果在别的教材中看到类似 1&lt;&gt;3 这种表达式也不要大惊小怪，它其实与 1!=3 是等价的 成员运算符（Membership）成员运算符的关键词是 in和not in。把 in 放在两个对象中间的含义是，测试前者是否存在于 in 后面的集合中，in 和 not in 是表示归属关系的布尔运算符号（Membership Operator）。。 创建了一个非空的列表： 1album = [&apos;Black Star&apos;,&apos;David Bowie&apos;,25,True] 使用 in 来测试字符串 ‘Black Star’ 是否在列表 album 中。如果存在则会显示 True，不存在就会显示 False 了： 1&apos;Black Star&apos; in album in 后面是一个集合形态的对象，字符串满足这种集合的特性，所以可以使用 in 来进行测试。 身份运算符（Identify Operators) is 和 is not，是表示身份鉴别（Identify Operator）的布尔运算符 在 Python 中任何一个对象都要满足身份（Identity）、类型（Type）、值 （Value）这三个点，缺一不可。is 操作符号就是来进行身份的对比的。 12345678the_Eddie = &apos;Eddie&apos;name = &apos;Eddie&apos;print(the_Eddie == name)print(the_Eddie is name)结果：TrueTrue· 布尔运算符（Boolean Operators）not、and、or 用于布尔值之间的运算，具体规则如下： and 和 or 经常用于处理复合条件，也就是两个条件同时满足。 12341 &lt; 3 and 2 &lt; 5 #True1 &lt; 3 and 2 &gt; 5 #False1 &lt; 3 or 2 &gt; 5 #True1 &gt; 3 or 2 &gt; 5 #False ###条件控制 条件控制其实就是 if…else 的使用。先来看下条件控制的基本结构： 条件（condition）指的是成立的条件，即是返回值为 True 的布尔表达式。 登录： 12345678def account_login(): password = input(&apos;Password:&apos;) if password == &apos;12345&apos;: print(&apos;Login success!&apos;) else: print(&apos;Wrong password or invalid input!&apos;) account_login() account_login() 多条件判断只需在 if 和else 之间增加上 elif。 使用 elif 语句给刚才设计的函数增加一个重置密码的功能： 123456789101112131415161718192021222324252627password_list = [&apos;12345&apos;, &apos;#*#*&apos;]def account_login(): password = input(&apos;enter your password:&apos;) if password == password_list[0]: print(&apos;login success!&apos;) elif password == password_list[1]: new_password = input(&apos;enter a new password:&apos;) print(&apos;Your password has changed successfully!&apos;) password_list[0] = new_password account_login() else: print(&apos;wrong password or invalid input!&apos;) account_login()account_login()结果：enter your password:23456wrong password or invalid input!enter your password:#*#*enter a new password:23456Your password has changed successfully!enter your password:23456login success! 在上面的代码中可以清晰地看见代码块（Code Block）。代码块的产生是由于缩进，也就是说，具有相同缩进量的代码实际上是在共同完成相同层面的事情。 ###循环（Loop) ####for循环 for 循环所做的事情概括成一句话就是：于…中的每一个元素，做…事情。 for 循环能够帮助我们做很多重复性的事情，比如批量命名、批量操作等等。 for 是关键词，后面紧接着的是一个可以容纳“每一个元素”的变量名称，变量起什么名字自己定，但切记不要和关键词重名。 在关键词 in 后面所对应的一定是具有“可迭代的”（iterable）或者说是像列表那样的集合形态的对象，即可以连续地提供其中的每一个元素的对象。 如何打印出这样的结果？ 123451 + 1 = 2 2 + 1 = 3..10 + 1 = 11 需要用到一个内置函数一一range。我们只需要在 range 函数后面的括号中填上数字，就可以得到一个具有连续整数的序列。 range(n,m)会得到 [n,m) 的一组具有连续整数的序列，不包含m，因此实际范围是n～m-1。 1234567891011121314for num in range(1, 11): print(num, &apos; + 1 = &apos;, num+1) 结果：1 + 1 = 22 + 1 = 33 + 1 = 44 + 1 = 55 + 1 = 66 + 1 = 77 + 1 = 88 + 1 = 99 + 1 = 1010 + 1 = 11 嵌套循环九九乘法表： 123456789101112for num in range(1, 10): for num2 in range(1, num+1): print(num2, &apos; * &apos;, num, &apos; = &apos;, num * num2) 1 * 1 = 11 * 2 = 22 * 2 = 41 * 3 = 32 * 3 = 63 * 3 = 91 * 4 = 4... ####while 循环 while 是在条件不成立的时候停止， for 循环会在可迭代的序列被穷尽的时候停止，因此 while 的作用概括成一句话就是：只要…条件成立，就一直做…。 在前面登录函数的基础上来实现，给登录函数增加一个新功能：输入密码错误超过3次就禁止再次输入密码。 1234567891011121314151617181920212223242526272829password_list = [&apos;12345&apos;, &apos;#*#*&apos;]def account_login(): wrong = 0 while wrong &lt; 3: password = input(&apos;enter your password:&apos;) if password == password_list[0]: print(&apos;login success!&apos;) break elif password == password_list[1]: new_password = input(&apos;enter a new password:&apos;) print(&apos;Your password has changed successfully!&apos;) password_list[0] = new_password else: wrong = wrong+1 print(&apos;wrong password or invalid input!you have only &apos;, 3-wrong, &apos;times&apos;)account_login()结果：enter your password:#*#*enter a new password:23456Your password has changed successfully!enter your password:12345wrong password or invalid input!you have only 2 timesenter your password:23456login success! 练习题1. 创建10个文本with open(desktop_path + str(num) + ‘a.txt’,’w’) as text123456789101112131415161718def text_creation(): desktop_path = &apos;/Users/yangtielong/Desktop/src/&apos; for num in range(1, 11): with open(desktop_path + str(num) + &apos;a.txt&apos;,&apos;w&apos;) as text: text.write(str(num)) text.close() print(&apos;Done&apos;)text_creation()# def text_creation():# desktop_path = &apos;/Users/yangtielong/Desktop/src/&apos;# for num in range(1, 11):# file_path = desktop_path + str(num) + &apos;.txt&apos;# file = open(file_path, &apos;w&apos;)没有close()掉# del file # 怎么删除文件 练习题2. 复利1234567891011121314151617181920def invest(amount, rate=0.05, time=8): print(&apos;principal amount: &apos;, amount) for year in range(1,time + 1): amount = amount * (rate+1) print(&apos;year &apos;, year, &apos;: $&apos;,amount)invest(100)结果：principal amount: 100year 1 : $ 105.0year 2 : $ 110.25year 3 : $ 115.7625year 4 : $ 121.55062500000001year 5 : $ 127.62815625000002year 6 : $ 134.00956406250003year 7 : $ 140.71004226562505year 8 : $ 147.74554437890632 练习题3. 打印1～100内的偶数123for odd in range(1,101): if odd%2 == 0: print(odd) 综合练习 赌博猜大小sum() 函数 sum() 函数用来对列表中的所有整数求和： 12a_list = [1,2,3]print(sum(a_list)) random.randrange(n,m)random 是 py 的内置库，使用它生成随机数：random.randrange(n,m)： 1234567import randompoint1 = random.randrange(1,7)point2 = random.randrange(1,7)point3 = random.randrange(1,7)print(point1,point2,point3) random 中的 randrange 方法使用起来就像是 range 函数一样，两个参数即可限定随机数范围。 好的程序会处理用户的非法输入。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import randomdef roll_dice(numbers=3, points=None): if points is None: points = [] while numbers &gt; 0: point = random.randrange(1,7) points.append(point) numbers = numbers-1 return pointsdef roll_result(total): isBig = 11&lt;=total&lt;=18 isSmall= 3&lt;=total&lt;=10 if isBig: return &apos;Big&apos; elif isSmall: return &apos;Small&apos;def start_game(): your_money = 1000 print(&apos;&lt;&lt;&lt;&lt;&lt; GAME STARTS! &gt;&gt;&gt;&gt;&gt;&apos;) choices = [&apos;Big&apos;, &apos;Small&apos;] while your_money &gt; 0: your_choice = input(&apos;Big or Small&apos;) if your_choice in choices: points = roll_dice() total = sum(points) youWin = your_choice ==roll_result(total) print(&apos;You have &apos;, your_money, &apos;$&apos;) bet = int(input(&apos;How much you wanna bet? &apos;)) while bet &gt; your_money: print(&apos;You don\&apos;ot have &apos;, bet) print(&apos;You have &apos;, your_money, &apos;$&apos;) bet = int(input(&apos;How much you wanna bet? &apos;)) if youWin: your_money = your_money + bet print(&apos;The points are&apos;,points,&apos;You win !&apos;) print(&apos;You gained &apos;, bet, &apos;,Now you have&apos;, your_money) else: your_money = your_money - bet print(&apos;The points are&apos;,points,&apos;You lose !&apos;) print(&apos;You lost &apos;, bet, &apos;,Now you have&apos;, your_money) else: print(&apos;Invalid words&apos;) print(&apos;GAME OVER&apos;)start_game() 综合练习 注册验证手机号码手机号码截取 0-3位 验证元素是否在列表内 12345678910111213141516171819202122232425262728293031def testify_phone_number(): while True: your_number = input(&apos;Enter your number: &apos;) CN_mobile = [134, 135, 136, 137, 138, 139, 150, 151, 152, 157, 158, 159, 182, 183, 184, 187, 188, 147, 178, 1705] CN_union = [130, 131, 132, 155, 156, 185, 186, 145, 176, 1709] CN_telecom = [133, 153, 180, 181, 189, 177, 1700] first_three = int(your_number[0:3]) first_four = int(your_number[0:4]) if len(your_number) == 11: if first_three in CN_mobile or first_four in CN_mobile: print(&apos;Operator : China Mobile&apos;) print(&apos;We\&apos;re sending verification code via text to your phone: &apos;, your_number) break elif first_three in CN_union or first_four in CN_union: print(&apos;Operator : China Union&apos;) print(&apos;We\&apos;re sending verification code via text to your phone: &apos;, your_number) break elif first_three in CN_telecom or first_four in CN_telecom: print(&apos;Operator : China Telecom&apos;) print(&apos;We\&apos;re sending verification code via text to your phone: &apos;, your_number) break else: print(&apos;Invalid number, please reinput.&apos;) else: print(&apos;Invalid length,your number should be in 11 digits&apos;)testify_phone_number() 数据结构（Data Structure)Python 称之为内置数据结构（Built-in Data Structure），有四种数据结构。 分别是：列表、字典、元组，集合。 列表中的元素使用方括号扩起来，元组则是圆括号，字典和集合是花括号。其中字典中的元素是均带有 ‘：’ 的 key 与 value 的对应关系组。 ###列表（list) 列表具有的最显著的特征是： 列表中的每一个元素都是可变的； 列表中的元素是有序的，也就是说每一个元素都有一个位置； 列表可以容纳 Python 中的任何对象。 其中，列表中的元素是可变的，这意味着我们可以在列表中添加、删除和修改元素。列表中的每一个元素都对应着一个位置，我们通过输入位置而查询该位置所对应的值。如： 12Weekday = [&apos;Monday&apos;,&apos;Tuesday&apos;,&apos;Wednesday&apos;,&apos;Thursday&apos;,&apos;Friday&apos;]print(Weekday[0]) 第三个特征是列表可以装入 Python 中所有的对象，字符串、浮点、整数、布尔类型、变量甚至是另一个列表都可以储存在列表中，看下面的例子就知道了： 12345678910all_in_list = [ 1, #整数 1.0, #浮点数 &apos;a word&apos;, #字符串 print(1), #函数 True, #布尔值 [1,2], #列表中套列表 (1,2), #元组 &#123;&apos;key&apos;:&apos;value&apos;&#125; #字典] 列表的索引列表的索引与字符串的分片十分相似，同样是分正反两种索引方式，只要输入对应的位置就会返回给你在这个位置上的值： 下面代码的功能是打印列表中第一个和最后一个元素： 1print(sample[0],sample[-1]) 列表的增删改查#####insert() 对于数据的操作，最常见的是增删改查这四类。从列表的插入方法开始，输入： 123456fruit = [&apos;pineapple&apos;,&apos;pear&apos;]fruit.insert(1,&apos;grape&apos;)print(fruit)结果：[&apos;pineapple&apos;, &apos;grape&apos;, &apos;pear&apos;] 在使用 insert 方法的时候，必须指定在列表中要插入新的元素的位置，插入元素的实际位置是在指定位置元素之前的位置，如果指定插入的位置在列表中不存在，实际上也就是超出指定列表长度，那么这个元素一定会被放在列表的最后位置。 append()使用列表的 append 方法可以向列表中添加新的元素，并且使用这种方式添加的元素会自动地排列到列表的尾部： 123456fruit = [&apos;pineapple&apos;, &apos;pear&apos;]fruit.append(&apos;orange&apos;)print(fruit)结果：[&apos;pineapple&apos;, &apos;pear&apos;, &apos;orange&apos;] 但是PyCharm不鼓励这样写。 另外使用这种方法也可以同样达到“插入”的效果： 1234567fruit = [&apos;pineapple&apos;, &apos;pear&apos;]fruit.insert(1, &apos;grape&apos;)fruit[0:0] = [&apos;orange&apos;]print(fruit)结果：[&apos;orange&apos;, &apos;pineapple&apos;, &apos;grape&apos;, &apos;pear&apos;] extend()remove()删除列表中元素的方法是使用 remove()： 123456fruit = [&apos;pinapple&apos;,&apos;pear&apos;,&apos;grape&apos;]fruit.remove(&apos;grape&apos;)print(fruit)结果：[&apos;pineapple&apos;, &apos;grape&apos;] del删除还有一种方法，那就是使用 del 关键字来声明： 12345del fruit[0:2]print(fruit)结果：[&apos;grape&apos;, &apos;pear&apos;] 修改如果要是想替换修改其中的元素可以这样： 1fruit[0] = &apos;Grapefruit&apos; 你会发现列表的索引和字符串是一样的，但是如果要是反过来，想要查看某个具体的值所在的位置，就需要用别的方法了，否则就会报错： 报错是因为列表只接受用位置进行索引。 字典（Dictionary)字典使用名称－内容进行数据的构建，在 Python 中分别对应着键（key）－值（value），习惯上称之为键值对。 字典的特征总结如下： 字典中数据必须是以键值对的形式出现的； 逻辑上讲，键是不能重复的，而值可以重复； 字典中的键（key）是不可变的，也就是无法修改的；而值（value）是可变的，可修改的，可以是任何对象。 字典的正确书写方式： 12345NASDAQ_code = &#123; &apos;BIDU&apos;:&apos;Baidu&apos;, &apos;SINA&apos;:&apos;Sina&apos;, &apos;YOKU&apos;:&apos;Youku&apos;&#125; 一个字典中键与值并不能脱离对方而存在。而且必须用一个不可变（unmutable）的元素作为 key 。 字典的增删改查增加与列表不同的是，字典并没有一个可以往里面添加单一元素的“方法”，但是我们可以通过这种方式进行添加： 123456789NASDAQ_code = &#123;&apos;BAIDU&apos;: &apos;baidu&apos;,&apos;SINA&apos;: &apos;sina&apos;&#125;print(NASDAQ_code)NASDAQ_code[&apos;FACEBOOK&apos;] = &apos;facebook&apos;print(NASDAQ_code)结果：&#123;&apos;BAIDU&apos;: &apos;baidu&apos;, &apos;SINA&apos;: &apos;sina&apos;&#125;&#123;&apos;BAIDU&apos;: &apos;baidu&apos;, &apos;SINA&apos;: &apos;sina&apos;, &apos;FACEBOOK&apos;: &apos;facebook&apos;&#125; update()列表中有用来添加多个元素的方法 extend() ，在字典中也有对应的添加多个元素的方法 update()： 12345678NASDAQ_code = &#123;&apos;BAIDU&apos;: &apos;baidu&apos;,&apos;SINA&apos;: &apos;sina&apos;&#125;print(NASDAQ_code)NASDAQ_code.update(&#123;&apos;FACEBOOK&apos;: &apos;facebook&apos;,&apos;JINGDONG&apos;: &apos;jingdong&apos;&#125;)print(NASDAQ_code)结果：&#123;&apos;BAIDU&apos;: &apos;baidu&apos;, &apos;SINA&apos;: &apos;sina&apos;&#125;&#123;&apos;BAIDU&apos;: &apos;baidu&apos;, &apos;SINA&apos;: &apos;sina&apos;, &apos;FACEBOOK&apos;: &apos;facebook&apos;, &apos;JINGDONG&apos;: &apos;jingdong&apos;&#125; 删除 del删除字典中的元素则使用 del 方法： 123456789101112NASDAQ_code = &#123;&apos;BAIDU&apos;: &apos;baidu&apos;,&apos;SINA&apos;: &apos;sina&apos;&#125;print(NASDAQ_code)NASDAQ_code.update(&#123;&apos;FACEBOOK&apos;: &apos;facebook&apos;,&apos;JINGDONG&apos;: &apos;jingdong&apos;&#125;)print(NASDAQ_code)del NASDAQ_code[&apos;FACEBOOK&apos;]print(NASDAQ_code)结果：&#123;&apos;BAIDU&apos;: &apos;baidu&apos;, &apos;SINA&apos;: &apos;sina&apos;&#125;&#123;&apos;BAIDU&apos;: &apos;baidu&apos;, &apos;SINA&apos;: &apos;sina&apos;, &apos;FACEBOOK&apos;: &apos;facebook&apos;, &apos;JINGDONG&apos;: &apos;jingdong&apos;&#125;&#123;&apos;BAIDU&apos;: &apos;baidu&apos;, &apos;SINA&apos;: &apos;sina&apos;, &apos;JINGDONG&apos;: &apos;jingdong&apos;&#125; 需要注意的是，虽说字典是使用的花括号，在索引内容的时候仍旧使用的是和列表一样的方括号进行索引，只不过在括号中放入的一定是——字典中的键，也就是说需要通过键来索引值： 1NASDAQ_code[&apos;TSLA&apos;] 同时，字典是不能够切片的，也就是说下面这样的写法应用在字典上是错误的： 1chart[1:4] # WRONG! 元组（Tuple)元组其实可以理解成一个稳固版的列表，因为元组是不可修改的，因此在列表中的存在的方法均不可以使用在元组上，但是元组是可以被查看索引的，方式就和列表一样： 12letters = (&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;)letter[0] tuple 和 list 切片操作完全相同，只是切片的结果也变成了tuple。 集合（Set)集合则更接近数学上集合的概念。每一个集合中的元素是无序的、不重复的任意对象，我们可以通过集合去判断数据的从属关系，有时还可以通过集合把数据结构中重复的元素减掉。 集合不能被切片也不能被索引，除了做集合运算之外，集合元素可以被添加还有删除： 123a_set = &#123;1,2,3,4&#125; a_set.add(5)a_set.discard(5) 数据结构的一些技巧sorted()sorted 函数按照长短、大小、英文字母的顺序给每个列表中的元素进行排序。这个函数会经常在数据的展示中使用，其中有一个非常重要的地方，sorted 函数并不会改变列表本身，你可以把它理解成是先将列表进行复制，然后再进行顺序的整理。 使用默认参数 reverse 后列表可以被按照逆序整理： 1sorted(num_list,reverse=True) zip()整理列表的过程中，如果同时需要两个列表应该怎么办？这时候就可以用到 zip 函数，比如： 12for a,b in zip(num,str): print(b,&apos;is&apos;,a) 推导式（List comprehension）列表的推导式也叫列表的解析式。 列表推导式可以看成两部分。红色虚线后面的是熟悉的 for 循环的表达式，而虚线前面的是我们想要放在列表中的元素，在这个例子中放在列表中的元素即是后面循环的每个元素本身。 为了更好地理解这句话，我们继续看几个例子： 1234a = [i**2 for i in range(1,10)] #[1, 4, 9, 16, 25, 36, 49, 64, 81]c = [j+1 for j in range(1,10)] #[2, 3, 4, 5, 6, 7, 8, 9, 10]k = [n for n in range(1,10) if n % 2 ==0] #[2, 4, 6, 8]z = [letter.lower() for letter in &apos;ABCDEFGHIGKLMN&apos;] #[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, ...] 现在我有10个元素要装进列表中，普通的写法是这样的： 1234567a = []for i in range(1,11): a.append(i)print(a)结果：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 下面换成列表解析的方式来写： 12345b = [i for i in range(1,11)]print(b)结果：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 列表解析式不仅非常方便，并且在执行效率上要远远胜过前者，我们把两种不同的列表操作方式所耗费的时间进行对比，就不难发现其效率的巨大差异： 1234567891011import timea = []t0 = time.clock()for i in range(1,20000): a.append(i)print(time.clock() - t0, seconds process time&quot;)t0 = time.clock()b = [i for i in range(1,20000)]print(time.clock() - t0, seconds process time&quot;) 得到结果： 1234568.999999999998592e-06 seconds process time0.0012320000000000005 seconds process time我的答案：0.003646999999999956 s0.0012860000000000094 s 字典推导式字典推导式的方式略有不同，主要是因为创建字典必须满足键－值的两个条件才能达成： 1234d = &#123;i:i+1 for i in range(4)&#125; #&#123;0: 1, 1: 2, 2: 3, 3: 4&#125;g = &#123;i:j for i,j in zip(range(1,6),&apos;abcde&apos;)&#125; #&#123;1: &apos;a&apos;, 2: &apos;b&apos;, 3: &apos;c&apos;, 4: &apos;d&apos;, 5: &apos;e&apos;&#125;g = &#123;i:j.upper() for i,j in zip(range(1,6),&apos;abcde&apos;)&#125; #&#123;1: &apos;A&apos;, 2: &apos;B&apos;, 3: &apos;C&apos;, 4: &apos;D&apos;, 5: &apos;E&apos;&#125; enumerate()获取元素索引 Python 中独有的函数 enumerate，在索引的时候得到每个元素的具体位置。 12345678910111213letters = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;]for num,letter in enumerate(letters): print(letter,&apos;is&apos;,num + 1) 结果：a is 1b is 2c is 3d is 4e is 5f is 6 g is 7 综合练习 统计词频split() 分离字符串使用 split 方法将字符串中的每个单词分开，得到独立的单词： 123456lyric = &apos;The night begin to shine, the night begin to shine&apos;words = lyric.split()print(words)结果：[&apos;The&apos;, &apos;night&apos;, &apos;begin&apos;, &apos;to&apos;, &apos;shine,&apos;, &apos;the&apos;, &apos;night&apos;, &apos;begin&apos;, &apos;to&apos;, &apos;shine&apos;] count() 方法计数使用 count() 统计 words 中有多少 word： 12345for word in words: print(&apos;&#123;&#125;-&#123;&#125; times&apos;.format(word,words.count(word))) 结果：the-6928 times string.punctuation 所有的标点1234567import stringprint(string.punctuation)结果：!&quot;#$%&amp;&apos;()*+,-./:;&lt;=&gt;?@[\]^_`&#123;|&#125;~ strip() 去除函数去除标点： 123456789import stringmy = &apos;i am a lazy girl!&apos;print(my.strip(string.punctuation))结果：i am a lazy girl set() 函数转换成集合1234567words = &apos;i ii am so happyinggg&apos;words_index = set(words)print(words_index)结果：&#123;&apos;i&apos;, &apos;p&apos;, &apos;y&apos;, &apos;n&apos;, &apos;m&apos;, &apos;s&apos;, &apos;o&apos;, &apos;g&apos;, &apos;h&apos;, &apos;a&apos;, &apos; &apos;&#125; 最终代码： 12345678910111213141516171819202122232425import stringpath = &apos;/Users/yangtielong/Desktop/Walden.txt&apos;with open(path, &apos;r&apos;) as text: words = [raw_word.strip(string.punctuation).lower() for raw_word in text.read().split()] words_index = set(words) counts_dic = &#123;index: words.count(index) for index in words_index&#125;for word in sorted(counts_dic,key=lambda x:counts_dic[x], reverse=True): print(&apos;&#123;&#125; -- &#123;&#125; times&apos;.format(word,counts_dic[word])) 结果：the -- 7346 timesand -- 4602 timesof -- 3492 timesto -- 3107 timesa -- 3033 timesin -- 2060 timesi -- 2011 timesit -- 1715 timesis -- 1336 times... 最后一个for循环没太看懂。 类定义一个类12class CocaCola: formula = [&apos;caffeine&apos;,&apos;sugar&apos;,&apos;water&apos;,&apos;soda&apos;] 类的实例化1234567891011coke_for_me = CocaCola()coke_for_you = CocaCola()print(CocaCola.formula)print(coke_for_me.formula)print(coke_for_you.formula)结果：[&apos;caffeine&apos;, &apos;sugar&apos;, &apos;water&apos;, &apos;soda&apos;][&apos;caffeine&apos;, &apos;sugar&apos;, &apos;water&apos;, &apos;soda&apos;][&apos;caffeine&apos;, &apos;sugar&apos;, &apos;water&apos;, &apos;soda&apos;] 类的属性会被所有类的实例共享 实例属性12345class CocaCola: formula = [&apos;caffeine&apos;,&apos;sugar&apos;,&apos;water&apos;,&apos;soda&apos;]coke_for_China = CocaCola()coke_for_China.local_logo = &apos;可口可乐&apos; #创建实例属性print(coke_for_China.local_logo) #打印实例属性引用结果 运行结果： 1&gt;&gt;&gt; 可口可乐 实例方法123456class CocaCola: formula = [&apos;caffeine&apos;,&apos;sugar&apos;,&apos;water&apos;,&apos;soda&apos;] def drink(self): print(&apos;Energy!&apos;) coke = CocaCola()coke.drink() 运行结果： 1&gt;&gt;&gt; Energy! 被实例化的对象会被编译器默默地传入后面方法的括号中，作为第一个参数。 更多参数和函数一样，类的方法也能有属于自己的参数。 12345678910class CocaCola: formula = [&apos;caffeine&apos;,&apos;sugar&apos;,&apos;water&apos;,&apos;soda&apos;] def drink(self, how_much): if how_much == &apos;a sip&apos;: print(&apos;Cool~&apos;) elif how_much == &apos;whole bottle&apos;: print(&apos;Headache!!&apos;)coke_for_me = CocaCola()coke_for_me.drink(&apos;a sip&apos;) 运行结果： 1&gt;&gt;&gt; Cool~ _init__()_init_() 是 initialize(初始化)的缩写，即使我们在创建实例的时候不去调用_init_() 方法，其中的命令也会先被自动地执行。 如果你在类里定义了它，在创建实例的时候它就能帮你自动地处理很多事情——比如新增实例属性。 12345678910class CocaCola(): formula = [&apos;caffeine&apos;,&apos;sugar&apos;,&apos;water&apos;,&apos;soda&apos;] def __init__(self): self.local_logo = &apos;可口可乐&apos; def drink(self): # HERE！ print(&apos;Energy!&apos;) coke = CocaCola()print(coke.local_logo) 运行结果： 1&gt;&gt;&gt; 可口可乐 _init_() 方法可以给类的使用提供极大的灵活性 123456789101112131415161718class CocaCola: formula = [&apos;caffeine&apos;,&apos;sugar&apos;,&apos;water&apos;,&apos;soda&apos;] def __init__(self): for element in self.formula: print(&apos;Coke has &#123;&#125;&apos;.format(element)) self.local_logo = &apos;可口可乐&apos; def drink(self): print(&apos;energy!&apos;)coke_for_me = CocaCola()结果：Coke has caffeineCoke has sugarCoke has waterCoke has soda 除了必写的self 参数之外，_init() 同样可以有自己的参数，同时也不需要这样obj.init()的方式来调用（因为是自动执行），而是在实例化的时候往类后面的括号中放进参数。 123456789101112class CocaCola: formula = [&apos;caffeine&apos;,&apos;sugar&apos;,&apos;water&apos;,&apos;soda&apos;] def __init__(self,logo_name): for element in self.formula: print(&apos;Coke has &#123;&#125;&apos;.format(element)) self.local_logo = logo_name def drink(self): print(&apos;energy!&apos;)coke_for_me = CocaCola(&apos;可口可乐&apos;)print(coke_for_me.local_logo) 运行结果： 1&gt;&gt;&gt; 可口可乐 类的继承重新定义可口可乐这个类： 12345678910111213141516171819class CocaCola: calories = 140 sodium = 45 total_carb = 39 caffeine = 34 ingredients = [ &apos;High Fructose Corn Syrup&apos;, &apos;Carbonated Water&apos;, &apos;Phosphoric Acid&apos;, &apos;Natural Flavors&apos;, &apos;Caramel Color&apos;, &apos;Caffeine&apos; ] def __init__(self,logo_name): self.local_logo = logo_name def drink(self): print(&apos;You got &#123;&#125; cal caffeine!&apos;.format(self.caffeine)) 无咖啡可乐继承自可乐： 123456789101112131415161718class CaffeineFree(CocaCola): caffeine = 0 ingredients = [ &apos;High Fructose Corn Syrup&apos;, &apos;Carbonated Water&apos;, &apos;Phosphoric Acid&apos;, &apos;Natural Flavors&apos;, &apos;Caramel Color&apos;, ]coke_a = CaffeineFree(&apos;Cocacola-FREE&apos;)print(coke_a.caffeine)print(coke_a.local_logo)结果：0Cocacola-FREE 在新的类 CaffeineFree 后面的括号中放入 CocaCola，这就表示这个类是继承于 CocaCola 这个父类的，而 CaffeineFree 则成为了 CocaCola 子类。类中的变量和方法可以完全被子类继承，但如需有特殊的改动也可以进行覆盖（override）。其他没有重写的地方，方法和属性都能照常使用。 类属性与实例属性 _dict_dict是一个类的特殊属性，它是一个字典，用于储存类或者实例的属性。即使你不去定义它，它也会存在于每一个类中。 Python 中属性的引用机制是自外而内的，当你创建了一个实例之后，准备开始引用属性，这时候编译器会先搜索该实例是否拥有该属性，如果有，则引用；如果没有，将搜索这个实例所属的类是否有这个属性，如果有，则引用，没有那就只能报错了。 我感觉这个理解的有问题 123456789101112131415class TestA: attr = 11obj_a = TestA()obj_a.attr = 12TestA.attr = 42print(TestA.attr)print(TestA.__dict__)print(obj_a.__dict__)结果：42&#123;&apos;__module__&apos;: &apos;__main__&apos;, &apos;attr&apos;: 42, &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;TestA&apos; objects&gt;, &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;TestA&apos; objects&gt;, &apos;__doc__&apos;: None&#125;&#123;&apos;attr&apos;: 12&#125; 调用类的属性，就是类的属性 123456789101112class TestA: attr = 11obj_a = TestA()print(TestA.__dict__)print(obj_a.__dict__)结果：&#123;&apos;__module__&apos;: &apos;__main__&apos;, &apos;attr&apos;: 11, &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;TestA&apos; objects&gt;, &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;TestA&apos; objects&gt;, &apos;__doc__&apos;: None&#125;&#123;&#125; 实例只是被创建的时候，是没有属性值的 1234567891011121314151617class TestA: attr = 1 def __init__(self): self.attr = 42obj_a = TestA()obj_b = TestA()print(TestA.__dict__)print(obj_a.__dict__)print(obj_b.__dict__)结果：&#123;&apos;__module__&apos;: &apos;__main__&apos;, &apos;attr&apos;: 1, &apos;__init__&apos;: &lt;function TestA.__init__ at 0x102a7ac80&gt;, &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;TestA&apos; objects&gt;, &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;TestA&apos; objects&gt;, &apos;__doc__&apos;: None&#125;&#123;&apos;attr&apos;: 42&#125;&#123;&apos;attr&apos;: 42&#125; 类的扩展理解12345678910obj1 = 1obj2 = &apos;String!&apos;obj3 = []obj4 = &#123;&#125;print(type(obj1),type(obj2),type(obj3),type(obj4))结果：&lt;class &apos;int&apos;&gt; &lt;class &apos;str&apos;&gt; &lt;class &apos;list&apos;&gt; &lt;class &apos;dict&apos;&gt; 上面的这些类型被称作内建类型，它们并不需要像我们上面一样实例化。 综合练习在使用 Python 处理数据或者是开发网站时，有时候会使用一些无意义的假数据，比如用户详情页信息。 我们来制作这样一个填充用户假数据的小工具，这个小工具的设计思路如下： 父类:FakeUser 功能: 随机姓名 a. 单字名 b. 双字名 c. 无所谓是什么反正有个名字就好了 随机性别 子类：SnsUser 功能： 随机数量的跟随者 a. few b. a lot 生成器（generator）yield生成器（generator）。简单的来说，在函数中我们只要在任意一种循环（loop）中使用 yield 返回结果，就可以得到类似于 range 函数的效果。 查看所装的第三方库查看你所装的所有第三方库。 你可以尝试使用如下方式搞清楚它究竟在哪里： 12import sysprint(sys.path) 打印出来的会是一个列表，列表中的第四个将是你的库安装路径所在，因此你也可以直接这么做： 12345import sysprint(sys.path[3])结果：/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6 使用第三方库当你想搭建网站时，可以选择功能全面的 Django、轻量的 Flask 等 web 框架；当你想写一个小游戏的时候，可以使用 PyGame 框架；当你想做一个爬虫时，可以使用 Scrapy 框架；当你想做数据统计分析时，可以使用 Pandas 数据框架。 那么，如何根据自己的需求找到相应的库呢？ 在 awesome-python 这个网站上按照分类去寻找，上面收录了比较全面的第三方库。比如当我们想找爬虫方面的库时，查看 Web Crawling 这个分类，就能看到相应的第三方库的网站与简介： 进入库的网站查看更详细的介绍。 还可以直接通过搜索引擎寻找，比如： 如果你能尝试用英文搜索，会发现更大的世界，比如 stackoverflow 上的优质讨论。 安装第三方库在 PyCharm 中安装 第一步：在 PyCharm 的菜单中选择：File &gt; Default Settings 第二步： 第三步： 在安装成功后，PyCharm 会有成功提示。你也可以在 project interpreter 这个界面中查看安装了哪些库，点-号就可以卸载不再需要的库。 使用第三方库在 PyCharm 中输入库的名字，就会自动提示补全了： 输入之后你会发现是灰色的状态 import pandas，这是因为还没有在程序中使用这个库，而不是因为库还没安装（想检查库是否安装的话，可以使用前面提到的 PyCharm 或者 pip 的方式来确认）。 学习方法既 然 笨 办 法 不 能 让 我 学 会 Python， 那 么 我 决 定 用 一 种 聪 明 方 法 来 学， 为 自 己 创 造 学 习 的 捷 径。 这 种 高 效 学 习 法 的 核 心 在 于： 精 简： 学 习 最 核 心 的 关 键 知 识； 理 解： 运 用 类 比、 视 觉 化 的 方 法 来 理 解 这 些 核 心 知 识； 实 践： 构 建 自 己 的 知 识 体 系 之 后， 再 通 过 实 践 去 逐 渐 完 善 知 识 体 系。 运 用 了 高 效 学 习 法 之 后， 我 的 编 程 学 习 速 度 突 飞 猛 进， 不 到 一 个 月 时 间 就 完 成 了 一 个 爬 虫 加 上 Django 的 网 站。 为 了 追 求 最 大 程 度 的 精 简， 我 借 用 了 许 多 强 大 的 库 和 框 架， 这 让 我 不 需 要 重 新 发 明 轮 子， 而 是 专 注 于 最 核 心 的 功 能。 在 一 次 项 目 合 作 中， 我 惊 讶 的 发 现， 我 用 70 行 代 码 实 现 的 功 能， 一 名 工 程 师 竟 然 用 了 800 行 代 码 来 实 现。 在 运 动 场 上， 第 一 名 和 最 后 一 名 的 差 距 也 许 只 有 几 十 秒。 然 而 在 编 程 这 个 竞 技 场 上， 不 同 方 法 的 效 率 竟 然 会 有 10 倍 的 差 距， 这 也 正 是 追 求 高 效 学 习 的 价 值 所 在。 先 用 这 些 关 键 的 知 识 构 建 你 的 知 识 体 系 会 让 学 习 效 率 加 速， 这 是 比 一 开 始 就 钻 到 各 种 细 枝 末 节 里 面 更 好 的 学 习 方 式。 这 是 精 简 的 意 义。 精 通 一 门 语 言， 需 要 在 实 际 项 目 开 发 中 踩 过 许 多 坑，需 要 熟 悉 计 算 机 运 作 的 底 层 原 理。 在 实 践 过 程 中， 你 自 然 会 逐 渐 完 善 知 识 体 系。]]></content>
      <categories>
        <category>Python</category>
        <category>Python 入门</category>
      </categories>
      <tags>
        <tag>Python 入门</tag>
        <tag>编程小白的第一本 Python 入门书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Head First Java]]></title>
    <url>%2F2017%2F11%2F02%2FHead-First-Java%2F</url>
    <content type="text"><![CDATA[Java 的垃圾回收p40 对象的创建内存示意图 对象的引用变量有多大？ 除非你和 JVM 开发团队有交情，不然不知道，在同一个 JVM 中，引用变量的大小是一样的。若你是要讨论内存分配的问题，你要关心的应该是需要建立多少个对象和引用，以及对象的实际大小。 Head First Java 基础知识附录取得命令行用户输入字符串的方法1234567891011121314151617181920212223242526import java.io.BufferedReader;import java.io.InputStreamReader;public class Helper &#123; public static void main(String args[]) &#123; Helper helper = new Helper(); System.out.println(helper.getUserInput("Please enter a number: ")); &#125; public String getUserInput(String prompt) &#123; String inputLine = null; System.out.println(prompt + " "); try &#123; BufferedReader is = new BufferedReader(new InputStreamReader(System.in)); inputLine = is.readLine(); if (inputLine.length() == 0) &#123; return null; &#125; &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125; return inputLine; &#125;&#125; 其中 123if (inputLine.length() == 0) &#123; return null;&#125; 这是做”用户什么都没输入的处理”，不加这句，什么也不会输出 另外 12String string = "dsfs";System.out.println(string.length()); String 类型的变量也有 length() 方法，不止数组有。 Returns: the length of the sequence of characters represented by this object. 如果 string 是 null ，则string.length() 会报空指向异常。 foreach 与 for1for(int cell : locationCells ) &#123;···&#125; 编译器会这么做： 创建名为 cell 的 int 变量 将 locationCells 的第一个元素值赋给 cell 执行循环内容 赋值给下一个元素 cell 重复执行至所有的元素被运行完毕为止 locationCells 的集合必须是数组或其他集合的引用。而且 int 这个位置的类型要与 locationCells 兼容。 注意：可以看出，在 foreach 的执行过程中，采用了数组数据赋值，所以，cell 值的改变并不会影响 原来数组里那个位置的元素值。如果需要改变原来的数组，如排序，就要用之前的 for 循环。涉及到「赋值」的操作，都不能用foreach. 原始的 for 循环： 12for(int i = 0 ; i&lt;0 ; i++ ) &#123;···&#125; 1 2 3 4 运行顺序： 1 -&gt; 2 ：1. true -&gt; 4 -&gt; 3 -&gt; 2 : 1. true -&gt; 4 -&gt; 3 -&gt; 2 :1. true -&gt; 4 -&gt; 3 -&gt; 2 : ​ 2.false -&gt; end 2.false -&gt; end 2.false -&gt; end for 与 while 比较： 不知道执行次数用 while，知道执行次数用 for更清晰。 String 转 int1int num = Integer.parseInt("3"); Integer 的 parseInt() 方法，能将 String 解析。 这个方法仅对代表数字的 String 起作用，除此之外，程序就会崩溃，抛出异常。 Java 传参数是值拷贝参数的值是由实参拷贝而来的，参数的改变不会影响到原先的值，但要是传递的是引用变量，那么引用变量的远程控制（字节组合代表取得远程控制对象的方法）也会拷贝过来，那么参数的改变就会影响原来的值。 变量的比较 == ：用来比较两个变量的字节组合是否相等，对于 primitive 主数据类型来说，字节组合就是实际的变量值，对于引用来说，字节组合是取得对象的方法（指针），== 就是判断两个引用是否指向同一个对象。 equals（）：用来判断两个对象是否在意义上相等。即对象的相等性。 实例变量 VS 局部变量实例变量声明在类内，未初始化时，有默认值。integer 和 char 类型默认为 0 ，boolean 默认为 false，对象引用默认为 null。null 表示没有操作对象的远程控制，他是个引用而不是对象。 局部变量声明在方法内，未初始化时，没有默认值。方法的参数也是局部变量。如果局部变量未初始化就使用，编译器会报错。 random() 方法产生随机数产生 [n,m] 之间的随机数： 1int x = (int)( Math.random() * (m-n+1) + n ); Math.random() 方法返回介于 0 与 1 之间的 double 值，然后将此值乘以数组元素个数，再取整数值。 random() Returns: a pseudorandom double greater than or equal to 0.0 and less than 1.0. 大于等于 0 ，小于 1. 产生 [0,n] 之间的随机数 1int x = (int)( Math,random() * (n + 1 )); 写伪代码参考Chapter 5 Page 100 类、方法、变量的命名规则 必须以字母，下划线，或 $ 开头 除第一个字符外，后面可以用数字 避开 Java 的关键字 变量的两种口味 香辣的对象引用：保存的是对象的引用，以字节来表示取得对象的方法（遥控器）。 清凉的 primitive 主数据类型：保存的是变量本身，以字节代表实际的变量值，有 boolean、char、byte、short、int、long、float、double 8种。 注意，数组不论被声明来承载的是 primitive 主数据类型，或对象引用，数组永远是对象。 Java 是个强类型语言类型不许乱用，可以被隐含的放大（小值放大容器），或明确的缩小（强制类型转换） Java APIJava 中内置了数百个类，被称为 API，其实他就是个函数库，你可以把他当做自己写的来用。ArrayList 类就是 Java 函数库里的一个。 使用函数库时，要在使用到该类时写出完整的类名，或是在源文件开头 import 进它的包名，除非是来源于 java.lang 这个包中，java.lang 是个预先被引用的包，是个经常会用到的基础包。 类用包来组织，但 import 绝不是 C 里的 include，import 只是会帮你省下每个类前面的包名称，程序并不会因为 import 而变大或变慢。 以 javax 开头的包以前曾经是扩展，后来才取得了标准的名份。 ArrayList 类ArrayList 类是 java.util 工具类的代表。 123ArrayList&lt;Egg&gt; myList = new ArrayList&lt;Egg&gt;();//虽然 ArrayList 里返回的是 Object，但编译器会帮你做类型转换，转成 Egg 类型 新的 ArrayList 对象虽然和数组一样会创建在堆上，但他们有本质的不同 ArrayList 数组 使用 ArrayList，只是运用 ArrayList 类型的对象，跟使用其他对象一样，用 “.” 运算符调用它的方法。 使用数组，要用特殊的数组语法 []，无法调用它的方法，最多只能存取它的 length 实例变量。 ArrayList 会自动管理大小 数组要定义它的大小，且大小不能改变 ArrayList 只能携带对象，不能装 primitive 主数据类型，但是非要装的话，编译器会自动将 primitive 包装成 Object ，再放入 ArrayList 中 在装载 primitive 主数据类型时，数组比 ArrayList 快 是类型参数，代表是 String 的集合 短运算的使用可以用这种方式避免调用内容为 null 的指针变量： 123if( refVar ! = null &amp;&amp; refVar.isValidType())&#123; //执行有效变量的工作&#125; Java 基础知识附录赋值数组Java 中有复制数组的方法，C++ 中没有 123Integer[] arr1 = SortTestHelper.generateRandomArray(n, 0, n);Integer[] arr2 = Arrays.copyOf(arr1, arr1.length); assert一、概述 在 C 和 C++ 语言中都有 assert 关键，表示断言。 在 Java 中，同样也有 assert 关键字，表示断言，用法和含义都差不多。 二、语法 在 Java 中，assert 关键字是从 JAVA SE 1.4 引入的，为了避免和老版本的 Java 代码中使用了 assert 关键字导致错误，Java 在执行的时候默认是不启动断言检查的（这个时候，所有的断言语句都将忽略！），如果要开启断言检查，则需要用开关 -enableassertions 或 -ea 来开启。 assert关键字语法很简单，有两种用法： 1assert &lt;boolean表达式&gt; 如果 为 true，则程序继续执行。 如果为 false，则程序抛出 AssertionError，并终止执行。 1assert &lt;boolean表达式&gt; : &lt;错误信息表达式&gt; 如果 为 true，则程序继续执行。 如果为 false，则程序抛出 java.lang.AssertionError，并输入 &lt;错误信息表达式&gt;。 三、应用实例 下面给出一个例子，通过例子说明其用法： 123456789101112131415161718192021public class AssertFoo &#123; public static void main(String args[]) &#123; //断言1结果为true，则继续往下执行 assert true; System.out.println("断言1没有问题，Go！"); System.out.println("\n-----------------\n"); //断言2结果为false，程序终止 assert false : "断言失败，此表达式的信息将会在抛出异常的时候输出！"; System.out.println("断言2没有问题，Go！"); &#125;&#125; 保存代码到 C:\AssertFoo.java，然后按照下面的方式执行，查看控制台输出结果： 1、编译程序： C:>javac AssertFoo.java 2、默认执行程序，没有开启-ea开关： C:>java AssertFoo 执行结果： 123断言1没有问题，Go！ -----------------断言2没有问题，Go！ 3、开启-ea开关，执行程序： C:>java -ea AssertFoo 执行结果： 12345断言1没有问题，Go！-----------------Exception in thread "main" java.lang.AssertionError: 断言失败，此表达式的信息将会在抛出异常的时候输出！ at AssertFoo.main(AssertFoo.java:10) 四、陷阱 assert 关键字用法简单，但是使用 assert 往往会让你陷入越来越深的陷阱中。应避免使用。笔者经过研究，总结了以下原因： 1、assert 关键字需要在运行时候显式开启才能生效，否则你的断言就没有任何意义。而现在主流的 Java IDE 工具默认都没有开启 -ea 断言检查功能。这就意味着你如果使用 IDE 工具编码，调试运行时候会有一定的麻烦。并且，对于 Java Web 应用，程序代码都是部署在容器里面，你没法直接去控制程序的运行，如果一定要开启 -ea 的开关，则需要更改 Web 容器的运行配置参数。这对程序的移植和部署都带来很大的不便。 2、用 assert 代替 if 是陷阱之二。assert 的判断和if语句差不多，但两者的作用有着本质的区别：assert 关键字本意上是为测试调试程序时使用的，但如果不小心用 assert 来控制了程序的业务流程，那在测试调试结束后去掉assert 关键字就意味着修改了程序的正常的逻辑。 3、assert 断言失败将面临程序的退出。这在一个生产环境下的应用是绝不能容忍的。一般都是通过异常处理来解决程序中潜在的错误。但是使用断言就很危险，一旦失败系统就挂了。 五、对assert的思考 assert 既然是为了调试测试程序用，不在正式生产环境下用，那应该考虑更好的测试 JUint 来代替其做用，JUint 相对 assert 关键的所提供的功能是有过之而无不及。当然完全可以通过 IDE debug 来进行调试测试。在此看来，assert 的前途一片昏暗。 因此，应当避免在 Java 中使用 assert 关键字，除非哪一天 Java 默认支持开启 -ea 的开关，这时候可以考虑。对比一下，assert 能给你带来多少好处，多少麻烦，这是我们选择是否使用的的原则。 评论： assert 有很大的用处首先可以用在单元测试代码中。junit 侵入性是很强的，如果整个工程大量的代码都使用了 junit，就难以去掉或者是选择另外一个框架。如果单元测试代码很多，并且想复用这些单元测试案例，应该选择 assert 而不是 junit，便于使用别的单元测试框架，比如 TestNG。同理正式的功能代码根本就不应该出现 Junit，应该使用 assert. assert 主要适合在基类，框架类，接口类，核心代码类，工具类中。换言之，当你的代码的调用者是另外一个程序员写得业务代码，或者是另外一个子系统时，就很有必要使用它。比如你做了一个快速排序的算法 123456789101112131415public static List&lt;Integer&gt; quickSort(List&lt;Integer&gt; list)&#123; assert list != null; // 申请临时空间 //开始排序 for(int i : list)&#123; // &#125;&#125; 这种情况下，如果不检查传入参数的正确性，会抛出一个莫名其妙的空指针错误。你的调用者可能并不清楚你代码的细节，在一个系统的深处调试一个空指针错误是很浪费时间的。就应该直接明确的告诉你的调用者是传入的参数有问题。否则他会怀疑你的代码有 BUG。使用 assert 可以避免两个程序员之间互相指责对方写的代码有问题。 assert 适用那些你知道具体是什么错误，你和你的调用者已经约定应该由你的调用者去排除或检查的错误。你通过一个断言告诉你的调用者。assert 不适用那些外部系统造成的错误，比如用户输入数据的错误，某个外部文件格式错误。这些错误不是你的调用者而是用户造成的，甚至于不属于异常，因为出现输入错误和文件格式错误是经常的，这些错误应该由业务代码去检查。 assert 比较适合于被频繁调用的 基类，框架代码，工具类，核心代码，接口代码中，这正是它在运行时被去掉的原因。测试代码应该在测试阶段开启 -ea 参数，便于对系统深处的核心代码做仔细的测试。 Java 较少使用 assert 的原因是 Java 有很完整的OO体系，强制类型转换出现得较少，所以不需要类似 c 那样需要频繁的检查指针的类型是否正确，指针是否为空。同时 Java 也很少直接管理内存或缓冲区，所以不需要频繁的检查传入的缓冲区是否为空或者是已经越界。 但使用好 assert 有助于提高框架代码的正确性和减少框架代码的使用者的调试时间。]]></content>
      <categories>
        <category>Java</category>
        <category>Head First Java</category>
      </categories>
      <tags>
        <tag>Head First Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 开发中遇到的 bug]]></title>
    <url>%2F2017%2F10%2F30%2FAndroid-developing-bug%2F</url>
    <content type="text"><![CDATA[NoSuchMethodError: No static method wrapSharedElementTransition上汽大通项目遇到火山级 bug，点击 123456789101112131415java.lang.NoSuchMethodError: No static method wrapSharedElementTransition(Ljava/lang/Object;)Ljava/lang/Object; in class Landroid/support/v4/app/FragmentTransitionCompat21; or its super classes (declaration of 'android.support.v4.app.FragmentTransitionCompat21' appears in /data/app/com.example.aidrive2-1/base.apk) at android.support.v4.app.BackStackRecord.getSharedElementTransition(BackStackRecord.java:1156) at android.support.v4.app.BackStackRecord.configureTransitions(BackStackRecord.java:1222) at android.support.v4.app.BackStackRecord.beginTransition(BackStackRecord.java:1112) at android.support.v4.app.BackStackRecord.run(BackStackRecord.java:721) at android.support.v4.app.FragmentManagerImpl.execPendingActions(FragmentManager.java:1677) at android.support.v4.app.FragmentManagerImpl$1.run(FragmentManager.java:536) at android.os.Handler.handleCallback(Handler.java:815) at android.os.Handler.dispatchMessage(Handler.java:104) at android.os.Looper.loop(Looper.java:194) at android.app.ActivityThread.main(ActivityThread.java:5556) at java.lang.reflect.Method.invoke(Native Method) at java.lang.reflect.Method.invoke(Method.java:372) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:967) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:762) app:dexDebug：/Library/Java/JavaVirtualMachines/jdk1.8.0_92.jdk/Contents/Home/bin/java’’ finished with non-zero exit value 21Error:Execution failed for task ':app:dexDebug'. &gt; com.android.ide.common.process.ProcessException: org.gradle.process.internal.ExecException: Process 'command '/Library/Java/JavaVirtualMachines/jdk1.8.0_92.jdk/Contents/Home/bin/java'' finished with non-zero exit value 2 是 app/build.gradle 依赖包的版本问题， 参考： https://stackoverflow.com/questions/30001051/appdexdebug-execexception-finished-with-non-zero-exit-value-2 http://www.cnblogs.com/creasylai19/p/5027757.html 状态：未解决]]></content>
      <categories>
        <category>Android</category>
        <category>Android Developing Bug</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文相关]]></title>
    <url>%2F2017%2F10%2F29%2FMyPaper%2F</url>
    <content type="text"><![CDATA[彩虹无线发布“立方体计划”：前装车联网大数据的两种玩法]]></content>
      <categories>
        <category>毕设论文</category>
        <category>材料收集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hencoder 朱凯的高级教程]]></title>
    <url>%2F2017%2F10%2F29%2Fhencoder%2F</url>
    <content type="text"><![CDATA[给高级 Android 工程师的进阶手册第一讲，讲 UI 一般使用 自带控件 + 开源库，可以实现大部分 UI 效果。但一些新颖的效果，要自定义 View 来实现。 自定义 View 的 3 个关键点： 布局 绘制 触摸反馈 听课： 录播的视频 + 文字 + 练习项目。视频负责打通概念，文字负责阐述细节，练习项目负责最后一公里，让你从「我懂了」变成「我会了」 自定义 View 1-1 绘制基础绘制就是控件内容的显示。 自定义绘制就是你来接管绘制的过程，操作绘制细节。使用系统 API 是绘制不出柱状图和饼形图的，即使绘制出来，性能也不佳，这时要使用自定义绘制 View。]]></content>
      <categories>
        <category>Android</category>
        <category>Hencoder 朱凯的高级教程</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>朱凯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[颠覆你的传统英语学习 - 杨萃先]]></title>
    <url>%2F2017%2F10%2F27%2FPronunciation-of-Miss-Yang%2F</url>
    <content type="text"><![CDATA[视频地址：撕掉单词语法书，颠覆你的传统英语学习 第 0 课 - 找对方法 本节课作业： 下载 app，找到和自己生活、工作密切相关的部分听，听不懂的，立马查，可以看字幕，怎么能听懂怎么听。听满 100 小时。 生活中，环境中，只要是不会的生词，立马查。至少找到五个不会的。 关注老师个人公众号 “途正英语”。看老师的文章和小故事。 找志同道合的小伙伴讨论，说英语。 第 1 课 - 背单词大法 记单词： 作业：]]></content>
      <categories>
        <category>英语</category>
        <category>英语口语</category>
      </categories>
      <tags>
        <tag>英语口语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纪老师英语音标课程]]></title>
    <url>%2F2017%2F10%2F26%2FPronunciation-of-Miss-Ji%2F</url>
    <content type="text"><![CDATA[视频地址纪老师英语 - 音标篇 纪老师 英语音标口诀记忆法 – 音标一 5 个元音 + 1 个辅音 纪老师 英语音标口诀记忆法 – 音标二 5 个辅音的发音方法 纪老师 英语音标口诀记忆法 – 音标三 8 个双元音的发音方法 纪老师 英语音标口诀记忆法 – 音标四 12 个辅音的发音方法 纪老师 英语音标口诀记忆法 – 音标五 p、k、t 清音浊化 纪老师 英语音标口诀记忆法 – 音标实战篇 英语习惯用语发音练习 1 - 6 句 纪老师 英语音标口诀记忆法 – 音标实战篇 英语习惯用语发音练习 32 句 纪老师 英语音标口诀记忆法 – 音标实战篇 英语习惯用语发音练习 71 - 79 句 纪老师 英语音标口诀记忆法 – 音标实战篇 英语习惯用语发音练习 108 - 135 句 纪老师 - 48个国际音标的记忆口诀讲义地址纪老师 - 48个国际音标的记忆口诀【讲义】 音标一元音：20 个，相当于韵母 辅音：28 个，相当于声母 第一节学习 5 个元音和 1 个辅音： 发言口诀： 音标二第二节学习 5 个辅音 f、l、m、n 的发音：一种是读汉语拼音里的flmn，另一种是读这四个英文字母发音的尾音。 后面有可以一起拼读的就发flmn的音，没有一起拼读的音就发英文字母的尾音。 r 后面有可以一起拼读的音就发 ru 音，没有一起拼读的音就发 “儿”化音。 音标三第三节学习 8 个双元音。 英语讲究「滑音」。双元音的读法是从第一个音向后面一个滑动。 新旧音标对比如下： 音标四12 个辅音的发音方法 噘嘴的 s，发汉语拼音的平舌 s 噘嘴的 z，发汉语拼音的平舌 z 噘嘴的 s，发汉语拼音中的咬舌 s 咬舌尖的 r，发汉语拼音中的 r 噘嘴的 ch，发汉语拼音的翘舌 ch 噘嘴的 zh，发汉语拼音的翘舌 zh 噘嘴的 chu，发汉语拼音的翘舌 chu 噘嘴的 zhu，发汉语拼音的翘舌 zhu chi，发音在 c 与 ch 之间，我觉得是 ci zhi，发音在 z 与 zh 之间，我觉得是 zi y，发汉语拼音 yi 不能噘嘴的 wu，上牙轻抚下唇。 音标五清音浊化问题，也叫音变。 p k t 胆子小，见到 s 须变音。 p 变 b，k 变 g，t 要变成 d。 英语音标中一共有 48 个音素，讲了 31 个特殊的音素，剩下 17 个音素与汉语拼音发音相似。 如 p，读短促的 p，k，读短促的 k。]]></content>
      <categories>
        <category>英语</category>
        <category>音标</category>
      </categories>
      <tags>
        <tag>音标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慕课网 - Android 通用框架设计与完整电商 APP 开发]]></title>
    <url>%2F2017%2F10%2F20%2Fimooc-Android-Complete-e-commerce-app%2F</url>
    <content type="text"><![CDATA[用到的 GitHub 上的库字体库JoanZapata 字体库 123//字体图标compile 'com.joanzapata.iconify:android-iconify-ionicons:2.2.2'compile 'com.joanzapata.iconify:android-iconify-fontawesome:2.2.2' Fragmentation 的库Fragmentation 的库 123//Fragment依赖compile 'me.yokeyword:fragmentation:1.1.6'compile 'me.yokeyword:fragmentation-swipeback:1.1.6' 视图注入的库 ButterKnifeButterKnife 的配置要参考ButterKnife官网，要配置 3 个地方 123//ButterKnife依赖compile 'com.jakewharton:butterknife:8.8.1'annotationProcessor 'com.jakewharton:butterknife-compiler:8.8.1' 123456789101112131415161718buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.3.3' // ButterKnife 插件 classpath 'com.jakewharton:butterknife-gradle-plugin:8.8.1' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;allprojects &#123; repositories &#123; jcenter() mavenCentral() &#125;&#125; 12apply plugin: 'com.android.library'apply plugin: 'com.jakewharton.butterknife' BufferKnife 插件的作用是生成 R2 的类，R2 类是生成视图绑定需要的唯一 ID，资源文件 R 只能在为 application 类型的 module 里使用，为 library 类型的 module 使用 BufferKnife 插件根据 R 生成 R2 的资源文件来访问视图绑定的 ID。 网络框架 retrofitretrofit 理解 RESTful 架构 RESTful API 设计最佳实践 12345//网络请求依赖 compile 'com.squareup.okio:okio:1.13.0' compile 'com.squareup.okhttp3:okhttp:3.8.1' compile 'com.squareup.retrofit2:retrofit:2.3.0' compile 'com.squareup.retrofit2:converter-scalars:2.3.0' Loading 加载库AVLoadingIndicatorView 12//loading 依赖 compile 'com.wang.avi:library:2.1.3' 启动页倒计时首次启动可以滑动Android-ConvenientBanner 全屏的广告轮播]]></content>
      <categories>
        <category>慕课网</category>
        <category>Android 通用框架设计与完整电商 APP 开发</category>
      </categories>
      <tags>
        <tag>Android 通用框架</tag>
        <tag>未解决的 bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慕课网 - 懒人必备之 Android 效率开发框架]]></title>
    <url>%2F2017%2F10%2F16%2Fimooc-Android-Framework-video-8302%2F</url>
    <content type="text"><![CDATA[什么是框架 框架是地基，地基打的好，不管业务层有多大的变化，都不会影响到正常的开发. 不用框架，理论上讲是可以的，但是开发成本就变高了，很多集成服务要自己搭建 Android 中哪些可以抽象成为框架的： 网络模块 图片缓存模块 数据库模块 UI 基础 把这些抽出来之后，只要写业务层就好了。 AndroidAnnotation AndroidAnnotation 官网 AndroidAnnotation 是基于注解的标签库，所有标签。 AS 配置androidannotationsapp/build.gradle: 123456789101112131415def AAVersion = '4.3.0'dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', &#123; exclude group: 'com.android.support', module: 'support-annotations' &#125;) compile 'com.android.support:appcompat-v7:25.3.1' compile 'com.android.support.constraint:constraint-layout:1.0.1' testCompile 'junit:junit:4.12' //androidannotations 注解标签库 annotationProcessor "org.androidannotations:androidannotations:$AAVersion" compile "org.androidannotations:androidannotations-api:$AAVersion"&#125; AndroidManifest.xml 中每个使用 androidAnnotations 的 Activity 名字后面都要添加_ 1234&lt;activity android:name=".MainActivity_" android:label="FirstTest"&gt;&lt;/activity&gt; .MainActivity 为什么要加 ？ 是 androidAnnotations ，在处理的过程中，生成的 .MainActivity_ 的 Activity。 参考了：http://www.cnblogs.com/l2rf/p/4971825.html http://blog.csdn.net/xx326664162/article/details/68490059 http://blog.csdn.net/doris_d/article/details/52634450 http://www.cnblogs.com/caobotao/p/5138935.html http://blog.csdn.net/caiwenfeng_for_23/article/details/45801151 https://github.com/androidannotations/androidannotations/blob/master/examples/gradle/build.gradle 没搞好，报错。 1234567891011121314151617181920212223242526272829Process: com.ning.helloworld, PID: 14359 java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;com.ning.helloworld/com.ning.helloworld.MainActivity_&#125;: java.lang.NullPointerException: Attempt to invoke virtual method 'void android.widget.Button.setOnClickListener(android.view.View$OnClickListener)' on a null object reference at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2470) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2532) at android.app.ActivityThread.access$800(ActivityThread.java:169) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1421) at android.os.Handler.dispatchMessage(Handler.java:111) at android.os.Looper.loop(Looper.java:194) at android.app.ActivityThread.main(ActivityThread.java:5556) at java.lang.reflect.Method.invoke(Native Method) at java.lang.reflect.Method.invoke(Method.java:372) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:967) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:762) Caused by: java.lang.NullPointerException: Attempt to invoke virtual method 'void android.widget.Button.setOnClickListener(android.view.View$OnClickListener)' on a null object reference at com.ning.helloworld.MainActivity.onCreate(MainActivity.java:67) at com.ning.helloworld.MainActivity_.onCreate(MainActivity_.java:33) at android.app.Activity.performCreate(Activity.java:5975) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1111) at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2423) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2532) at android.app.ActivityThread.access$800(ActivityThread.java:169) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1421) at android.os.Handler.dispatchMessage(Handler.java:111) at android.os.Looper.loop(Looper.java:194) at android.app.ActivityThread.main(ActivityThread.java:5556) at java.lang.reflect.Method.invoke(Native Method) at java.lang.reflect.Method.invoke(Method.java:372) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:967) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:762) annotation 的使用 看到这： 课程网址]]></content>
      <categories>
        <category>慕课网</category>
        <category>懒人必备之 Android 效率开发框架</category>
      </categories>
      <tags>
        <tag>未解决的 bug</tag>
        <tag>Android 框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 第一行代码]]></title>
    <url>%2F2017%2F10%2F10%2FAndroid-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Chapter 1 入门Android 各版本对应的 API 版本号 系统代号 API 4.0.3 - 4.0.4 Ice Cream Sandwich 15 4.1.x 4.2.x 4.3 Jelly Bean 16 17 18 4.4 KitKat 19 5.0 5.1 Lollipop 21 22 6.0 Marshmallow 23 7.0 7.1 Nougat 24 25 8.0 Oreo 26 Android 程序的项目结构 gradle 下包含了 gradle wrapper 的配置文件。 gradle.properties 是全局的 gradle 配置文件。这里配置的属性将会影响到项目中所有的 gradle 编译脚本。 app 是开发的主要工作目录。 其他都是些 AS 自动生成的文件，不需要修改。 .gitignore 文件，记录不需要提交到 Git 的东西，节省 Git 服务器资源和带宽、减少冲突。只在项目的根目录里创建这个文件就好，一般的 model 不需要这个文件。（慕课网 - Android 通用架构设计与完整电商App开发 学到的） app下的目录结构 build 里是编译时自动生成的文件，不需要改动。 libs 里放的是你项目中使用到的第三方 jar 包，放在这里的 jar 包会被自动添加进构建路径中去。 androidTest 是用来编写 Android Test 测试用例的，可以进行自动化测试 java 里是放 Java 代码的地方。 res 里 图片放在 drawable 中，布局放在 layout 中，字符放在 values 中，字符包括字符串、样式、颜色等配置，应用图标放在 mipmap 。 res 里的资源有以下两种引用方式： 在代码中：通过 R.资源所在最近文件夹.资源名称，如 R.string.hellp_world 在 xml 中：通过 @资源所在最近文件夹/资源名称，如 @string/hello_wrold AndroidManifest.xml 是整个 Android 项目的配置文件，四大组件都要在此注册，这个文件给应用程序添加权限声明。 test 里用来编写 Unit Test 测试用例，是自动化测试的另一种方式。 build.gradle 是 app 模块的 gradle 构建脚本。 proguard-rules.pro 用于指定项目代码的混淆规则。 app 里的 build.gradleAndroid 的日志工具 Log Log.v() Log.d() Log.i() :important，分析用户行为的数据。 Log.w() Log.e() 1 级别最低，5 级别最高。每次打印日志时，会把此级别以及此级别以上的日志显示出来，使用关键字过滤，支持正则表达式。 Log.d() 方法会传入 2 个参数，第一个是 tag ，一般传入当前类名，用于打印信息过滤，第二个是 msg ，即要打印的具体内容。 AS 快捷键： 在 onCreate() 方法的外面，输入 logt + tab ，生成一个以当前类名作为值的 TAG 常量； logd + tab logi + tab logw + tab loge + tab logt + tab Chapter 2 活动活动的注册在活动中使用 Toast在活动中添加 Menu P38销毁活动 finish（）使用 Intent Intent 是各组件之间进行交互的重要方式。它有两个作用： 指明当前组件想要执行的动作。即意图，如：启动活动、服务、发送广播。 在不同组件之间传递数据。 Intent 有显式和隐式两种。 更多隐式 Intent 的用法 使用 Intent 显示网页 123Intent intent = new Intent(Intent.ACTION_VIEW);intent.setData(Uri.parse("http://www.wangzhuningecnu.github.io"));startActivity(intent); 使用 Intent 指定其他协议，如 geo 地理位置，tel 拨打电话 123Intent intent = new Intent(Intent.ACTION_DIAL);intent.setData(Uri.parse("tel:10000"));startActivity(intent);]]></content>
      <categories>
        <category>Android</category>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>任务清单</tag>
        <tag>第一行代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective Java]]></title>
    <url>%2F2017%2F10%2F09%2FEffective-Java%2F</url>
    <content type="text"><![CDATA[Chapter 1本书基本原则 清晰性、简洁性：模块的用户永远不应被模块的行为迷惑 模块要尽可能小，但又不能太小（模块 Module 是指任何可重用的组件，包括单个方法，到多个包的复杂系统） 代码应该被重用，而不是被拷贝 模块之间的依赖性应该尽可能降到最小 错误应该尽早被检测出来，最好是在编译时 写出清晰、正确、可用、健壮、灵活和可维护的程序来。如果你能做到这一点，那么获得所需的性能就比较简单了。]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
      </categories>
      <tags>
        <tag>任务清单</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Primary Question]]></title>
    <url>%2F2017%2F10%2F08%2FJava-Primary-Question%2F</url>
    <content type="text"><![CDATA[引用数组的赋值问题元素对象为 Student 类，数组元素对象为什么不能这样声明： 123Student[] arrStudent = new Student[]&#123;&#123;"D",90&#125; , &#123;"C",100&#125; , &#123;"B",95&#125; , &#123;"A",95&#125;&#125;;Student[] arrStudent = new Student[]()&#123;&#123;"D",90&#125; , &#123;"C",100&#125; , &#123;"B",95&#125; , &#123;"A",95&#125;&#125;; Integer 的包装类就可以这样声明： 1234567891011121314151617181920212223//测试 IntegerInteger arrInteger[] = &#123;10,8,9,7,4,6,5,3,2,1&#125;;SelectionSort.selectionSort(arrInteger);for (Integer i : arrInteger )&#123; System.out.print(i + " ");&#125;System.out.println();//测试 DoubleDouble arrDouble[] = &#123;4.3,4.2,3.3,2.1,1.0&#125;;SelectionSort.selectionSort(arrDouble);for (Double double1 : arrDouble) &#123; System.out.print(double1 + " ");&#125;System.out.println();//测试 StringString[] arrString = &#123;"D","C","B","A"&#125;;SelectionSort.selectionSort(arrString);for (String string : arrString) &#123; System.out.print(string+" ");&#125;System.out.println(); 引用类型的数组不可以在声明时赋值吗？ 引用类型数组怎么定义的？ assert 是保证什么的东东，不是类，也不是静态方法，那应该是Object里的,但是没有1assert randomLeft &lt;= randomRight; 这句能保证的是，randomLeft 的值 如果大于 randomRight 的值，则会把他们两个调换。不会报 true 或 false ，也不会报错，程序还是能运行。 泛型泛型啊 Comparable[] Object[] 到底用哪个？Foreach 用法注意若是给数组赋值，则不能用 Foreach ，因为 foreach 只是把值拷贝给一个临时变量，并不会赋值给数组本身。 错误示例： 123for (Integer integer : arr) &#123; integer = new Integer((int)(Math.random()*(randomRight-randomLeft+1)+randomLeft)); &#125; 确实生成了随机数给 integer,但并没有给数组。 Java的反射机制1234567891011121314151617181920212223242526// 测试sortClassName所对应的排序算法，对arr数组排序，所得到结果的正确性和算法运行时间 public static void testSort(String sortClassName , Comparable[] arr)&#123; try &#123; Class sortClass = Class.forName(sortClassName); Method sortMethod = sortClass.getMethod("sort" ,new Class[]&#123;Comparable[].class&#125;); Object[] params = new Object[]&#123;arr&#125;; long startTime = System.currentTimeMillis(); sortMethod.invoke(null,params); //为啥是params，不是arr long endTime = System.currentTimeMillis(); assert isSorted(arr); System.out.println(sortClass.getSimpleName() + " : " + (endTime - startTime ) + "ms"); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; 方法返回值123456789101112131415161718192021222324252627public static boolean isSorted(Integer arr[])&#123; for (int i = 0 ; i &lt; arr.length - 1; i++)&#123; if (arr[i+1] &lt; arr[i])&#123; return false; &#125; return true; &#125;// return true; &#125; public static boolean isSorted(Comparable arr[])&#123; for (int i = 0 ; i &lt; arr.length - 1; i++)&#123; if (arr[i+1] .compareTo(arr[i]) &lt; 0)&#123; return false; &#125;else &#123; return true; &#125; &#125;// return true; &#125; return true; 注释掉后，报错，missing return statement。]]></content>
      <categories>
        <category>Java</category>
        <category>Java 问题贴</category>
      </categories>
      <tags>
        <tag>Java 问题贴</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sortAlgorithm]]></title>
    <url>%2F2017%2F10%2F07%2Fimooc-SortAlgorithm%2F</url>
    <content type="text"><![CDATA[最简单的 — 选择排序 选择排序：每次选择剩余元素中的最小的那个，与当前位置互换。 选择排序不能中断，插入排序根据条件可能中断 选择排序动态图 选择排序示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class SelectionSort &#123; private SelectionSort()&#123;&#125;//此算法类不允许产生实例 public static void selectionSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; //找到剩余元素（下标为 [i，arr.length)中的元素）中最小元素的下标 int min = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) &#123; min = j; &#125; &#125; swap(arr, min, i);//将选择出的最小元素与当前位置元素 arr[i] 交换 for (int n : arr) &#123; System.out.print(n +" "); &#125; System.out.println(); &#125; &#125; public static void swap(int arr[],int n,int m) &#123; int temp = arr[n]; arr[n] = arr[m]; arr[m] = temp; &#125; public static void main(String[] args) &#123; int arr[] = &#123;10,8,9,7,4,6,5,3,2,1&#125;; SelectionSort.selectionSort(arr); for (int i : arr) &#123; System.out.print(i + " "); &#125; System.out.println(); &#125;&#125;输出：1 8 9 7 4 6 5 3 2 10 1 2 9 7 4 6 5 3 8 10 1 2 3 7 4 6 5 9 8 10 1 2 3 4 7 6 5 9 8 10 1 2 3 4 5 6 7 9 8 10 1 2 3 4 5 6 7 9 8 10 1 2 3 4 5 6 7 9 8 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 加了泛型的选择排序123456789101112131415161718192021222324252627282930313233343536package com.ning;public class Student implements Comparable&lt;Student&gt;&#123; private String name; private int grade; public Student(String name,int grade) &#123; // TODO Auto-generated constructor stub this.name = name; this.grade = grade; &#125; public Student() &#123; // TODO Auto-generated constructor stub &#125; // 定义Student的compareTo函数 // 如果分数相等，则按照名字的字母序排序 // 如果分数不等，则分数高的靠前 @Override public int compareTo(Student o) &#123; // TODO Auto-generated method stub if (this.grade &gt; o.grade) &#123; return 1; &#125;else if (this.grade &lt; o.grade) &#123; return -1; &#125;else &#123; return this.name.compareTo(o.name); &#125; &#125; @Override public String toString() &#123; // TODO Auto-generated method stub return "Student: " + this.name + " " + this.grade; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.ning;import java.lang.management.MemoryManagerMXBean;public class SelectionSort &#123; private SelectionSort()&#123;&#125;//算法类不允许产生实例 public static void selectionSort(Comparable[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; //找到 [i，arr.length)中 最小元素的下标 int min = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; //使用compareTo方法比较两个Comparable对象的大小 if (arr[j].compareTo(arr[min]) &lt; 0) &#123; min = j; &#125; &#125; swap(arr, min, i);//将选择出的最小元素与 i 交换 for (Object n : arr) &#123; System.out.print(n +" "); &#125; System.out.println(); &#125; &#125; public static void swap(Object arr[],int n,int m) &#123; Object temp = arr[n]; arr[n] = arr[m]; arr[m] = temp; &#125; public static void main(String[] args) &#123; //测试 Integer Integer arrInteger[] = &#123;10,8,9,7,4,6,5,3,2,1&#125;; SelectionSort.selectionSort(arrInteger); for (Integer i : arrInteger )&#123; System.out.print(i + " "); &#125; System.out.println(); //测试 Double Double arrDouble[] = &#123;4.3,4.2,3.3,2.1,1.0&#125;; SelectionSort.selectionSort(arrDouble); for (Double double1 : arrDouble) &#123; System.out.print(double1 + " "); &#125; System.out.println(); //测试 String String[] arrString = &#123;"D","C","B","A"&#125;; SelectionSort.selectionSort(arrString); for (String string : arrString) &#123; System.out.print(string+" "); &#125; System.out.println(); //测试自定义的 Student 类 Student[] arrStudent = new Student[3]; arrStudent[0] = new Student("wang",100); arrStudent[1] = new Student("zhang",98); arrStudent[2] = new Student("xiang",79); SelectionSort.selectionSort(arrStudent); for (Student student : arrStudent) &#123; System.out.print(student + " "); &#125; System.out.println(); &#125;&#125;输出结果：1 8 9 7 4 6 5 3 2 10 1 2 9 7 4 6 5 3 8 10 1 2 3 7 4 6 5 9 8 10 1 2 3 4 7 6 5 9 8 10 1 2 3 4 5 6 7 9 8 10 1 2 3 4 5 6 7 9 8 10 1 2 3 4 5 6 7 9 8 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1.0 4.2 3.3 2.1 4.3 1.0 2.1 3.3 4.2 4.3 1.0 2.1 3.3 4.2 4.3 1.0 2.1 3.3 4.2 4.3 1.0 2.1 3.3 4.2 4.3 1.0 2.1 3.3 4.2 4.3 A C B D A B C D A B C D A B C D A B C D Student: xiang 79 Student: zhang 98 Student: wang 100 Student: xiang 79 Student: zhang 98 Student: wang 100 Student: xiang 79 Student: zhang 98 Student: wang 100 Student: xiang 79 Student: zhang 98 Student: wang 100 随机生成算法测试用例的 SortTestHelper 类1234567891011121314151617181920212223242526package com.ning;public class SortTestHelper &#123; //SortTestHelper 不允许产生任何实例 private SortTestHelper() &#123;&#125; //生成 n 个元素的随机数组，每个随机数的范围是【randomLeft，randomRight】 public static Integer[] generateRandomArray(int n,int randomLeft,int randomRight) &#123; assert randomLeft &lt;= randomRight; Integer[] arr = new Integer[n]; for (int i = 0 ; i &lt; arr.length ; i++) &#123; arr[i] = new Integer((int)(Math.random()*(randomRight-randomLeft+1)+randomLeft));// System.out.println(arr[i]); &#125; SortTestHelper.printArray(arr); return arr; &#125; public static void printArray(Object[] arr) &#123; for (Object o : arr) &#123; System.out.print(o + " "); &#125; System.out.println(); &#125;&#125; 注意：数组赋值的时候，不能使用 foreach 写法，否则只是赋值给了局部变量，并没有赋值给数组本身。 SortTestHelper 类的使用： 12345//测试 Integer int n = 10000; Integer arrInteger[] = SortTestHelper.generateRandomArray(n, 0, n); SelectionSort.selectionSort(arrInteger); SortTestHelper.printArray(arrInteger); 在 SortTestHelper 类中加入测试算法的性能的代码SortTestHelper 类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package bobo.algo;import java.lang.reflect.Method;import java.lang.Class;public class SortTestHelper &#123; //······ // 判断arr数组是否有序 public static boolean isSorted(Comparable[] arr)&#123; for( int i = 0 ; i &lt; arr.length - 1 ; i ++ ) //这里一定是arr.length - 1，否则越界 if( arr[i].compareTo(arr[i+1]) &gt; 0 ) return false; return true; &#125; // 测试sortClassName所对应的排序算法排序arr数组所得到结果的正确性和算法运行时间 public static void testSort(String sortClassName, Comparable[] arr)&#123; // 通过Java的反射机制，通过排序的类名，运行排序函数 // * 依然是，使用反射机制并不是这个课程的重点, 大家也完全可以使用自己的方式书写代码, 最终只要能够测试出自己书写的算法的效率即可 // * 推荐大家阅读我在问答区向大家分享的一个学习心得: 【学习心得分享】请大家抓大放小，不要纠结于C++语言的语法细节 // * 链接: http://coding.imooc.com/learn/questiondetail/4100.html try&#123; // 通过sortClassName获得排序函数的Class对象 Class sortClass = Class.forName(sortClassName); // 通过排序函数的Class对象获得排序方法 Method sortMethod = sortClass.getMethod("sort",new Class[]&#123;Comparable[].class&#125;); // 排序参数只有一个，是可比较数组arr Object[] params = new Object[]&#123;arr&#125;; long startTime = System.currentTimeMillis(); // 调用排序函数 sortMethod.invoke(null,params); long endTime = System.currentTimeMillis(); assert isSorted( arr ); System.out.println( sortClass.getSimpleName()+ " : " + (endTime-startTime) + "ms" ); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 客户端： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package bobo.algo;import java.util.*;public class SelectionSort&#123; // 我们的算法类不允许产生任何实例 private SelectionSort()&#123;&#125; public static void sort(Comparable[] arr)&#123; int n = arr.length; for( int i = 0 ; i &lt; n ; i ++ )&#123; // 寻找[i, n)区间里的最小值的索引 int minIndex = i; for( int j = i + 1 ; j &lt; n ; j ++ ) // 使用compareTo方法比较两个Comparable对象的大小 if( arr[j].compareTo( arr[minIndex] ) &lt; 0 ) minIndex = j; swap( arr , i , minIndex); &#125; &#125; private static void swap(Object[] arr, int i, int j) &#123; Object t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125; public static void main(String[] args) &#123; // 测试排序算法辅助函数 int N = 10000; Integer[] arr = SortTestHelper.generateRandomArray(N, 0, N); SortTestHelper.testSort("bobo.algo.SelectionSort", arr); return; &#125;&#125;输出结果：N = 100 时，排序数...SelectionSort: 1msN = 1000 时，排序数...SelectionSort: 12msN = 10000 时，排序数..SelectionSort: 140msN = 100000 时，排序数.SelectionSort: 11577ms 同样 n² 的 — 插入排序 插入排序：把后面的元素，一个位置一个位置的往前，插入到合适的位置 插入排序像是一边摸牌，一边码牌；选择排序像是发牌完毕后，再码牌 插入排序动态图 插入排序示例代码123456789101112131415161718192021222324package com.ning;public class InsertionSort &#123; // 我们的算法类不允许产生任何实例 private InsertionSort()&#123;&#125; public static void sort(Comparable arr[]) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; // 寻找元素arr[i]合适的插入位置 for (int j = i; j &gt;= 1 ; j--) &#123; if (arr[j].compareTo(arr[j-1])&lt;0) &#123; swap(arr,j,j-1); &#125;else &#123; break; &#125; &#125; &#125; &#125; private static void swap(Object[] a,int n,int m) &#123; Object temp = a[m]; a[m] = a[n]; a[n] = temp; &#125;&#125; 插入排序与选择排序的比较1234567891011int n = 100000;Integer[] arr1 = SortTestHelper.generateRandomArray(n, 0, n);Integer[] arr2 = Arrays.copyOf(arr1, arr1.length);//Java 中有赋值数组的方法，C++ 中没有SortTestHelper.testSort("com.ning.SelectionSort", arr1);SortTestHelper.testSort("com.ning.InsertionSort", arr2);结果：SelectionSort: 14086msInsertionSort: 15634ms 比较 SelectionSort 和 InsertionSort 两种排序算法的性能效率 此时，插入排序比选择排序性能略低 插入排序的优化 插入排序在元素本就在该位置时，会结束本次比较，按理说比不能中断的选择排序要快，但并非如此，为何？ 因为插入排序在遍历的同时，也在不停交换，交换操作比比较更耗时，每次交换都有三次赋值的操作。 插入排序优化示意图 插入排序优化示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.xiang;import java.util.Arrays;/** * 项目名： SelectionSort2 * 包名： com.xiang * 文件名： InsertSort * Created by ning on 2017/12/1. * 描述： 优化后的插入排序 */public class InsertSort &#123; public static void sort(Comparable[] arr)&#123; for (int i = 1 ; i &lt; arr.length ; i++)&#123;// 寻找元素 arr[i] 合适的位置 Comparable e = arr[i];// 保存元素 e 应该插入的位置 int j; for (j = i ; j &gt; 0 &amp;&amp; e.compareTo(arr[j-1]) &lt; 0; j--)&#123; arr[j] = arr[j-1]; &#125; arr[j] = e; &#125; &#125; public static void main(String[] args)&#123; int N = 10000; Integer arr[] = SortTestHelper.generateAlmostOrderedArray(N,10); Integer arr2[] = Arrays.copyOf(arr,arr.length); SortTestHelper.testSort("com.xiang.SelectionSort",arr2); SortTestHelper.testSort("com.xiang.InsertSort",arr); &#125;&#125; 可以看到，使用优化过后的插入排序，当对几乎有序的数组进行排序时，老师的结果是：插入排序的速度是选择排序的1000倍。我得到的大多数结果是插入排序的速度是选择排序的100倍。 事实上，对于近乎有序的数组，使用优化过后的插入排序甚至比 nlogn 的排序算法更快。 在最优的情况下，对于一个完全有序的数组，插入排序的时间复杂度达到了 O（n），这是插入排序的一个重要的性质，也是它作为其他复杂排序子过程的原因。 选择排序和插入排序的比较 选择排序：O（n^2）, 不能中断 插入排序：O（n^2) ，可以中断，最优情况：O (n) ，比 nlogn 还要快，最差情况 O（n^2），是希尔排序的子过程，希尔排序是 O（n^(3/2)），虽然比 O（nlogn）稍大一些，但是他的实现较为简单，和插入排序一脉相承。 冒泡排序： 冒泡排序12345678910111213141516171819202122232425262728293031323334353637package com.ning;//这是冒泡排序public class BubbleSort &#123; private BubbleSort() &#123; &#125; public static void sort(Comparable[] array) &#123; for (int i = 0; i &lt; array.length; i++) &#123; for (int j = 1+i; j &lt; array.length; j++) &#123; if (array[j].compareTo(array[i]) &lt; 0) &#123; Comparable temp = array[j]; array[j] = array[i]; array[i] = temp; &#125; &#125; &#125; &#125;&#125;输出结果：11 14 9 16 7 19 1 9 15 5 1 14 11 16 9 19 7 9 15 5 1 5 14 16 11 19 9 9 15 7 1 5 7 16 14 19 11 9 15 9 1 5 7 9 16 19 14 11 15 9 1 5 7 9 9 19 16 14 15 11 1 5 7 9 9 11 19 16 15 14 1 5 7 9 9 11 14 19 16 15 1 5 7 9 9 11 14 15 19 16 1 5 7 9 9 11 14 15 16 19 1 5 7 9 9 11 14 15 16 19 1 5 7 9 9 11 14 15 16 19 选择排序的优化我自己写的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.xiang;import java.util.Arrays;/** * 项目名： SelectionSort2 * 包名： com.xiang * 文件名： SelectionSort2 * Created by ning on 2017/12/7. * 描述： 我自己写的选择排序的优化 */public class SelectionSort2 &#123; public static void sort(Comparable[] array)&#123; int left = 0; int right = array.length-1; int minIndex,maxIndex ; Comparable min,max; while (left &lt; right)&#123; minIndex = left; maxIndex = left; max = array[maxIndex]; min = array[minIndex]; for (int i = left ; i &lt;= right ; i++)&#123; if (array[i].compareTo(array[minIndex]) &lt; 0)&#123; minIndex = i; &#125; if (array[i].compareTo(array[maxIndex]) &gt; 0)&#123; maxIndex = i ; &#125; max = array[maxIndex]; min = array[minIndex]; &#125; array[left] = min; array[right] = max; left++; right--; &#125; &#125; public static void main(String args[])&#123; int N = 10000; Integer arr[] = SortTestHelper.generateRandomArray(N,0,N); Integer arr2[] = Arrays.copyOf(arr,arr.length); SortTestHelper.testSort("com.xiang.SelectionSort2",arr); SortTestHelper.testSort("com.xiang.SelectionSort",arr); &#125;&#125; 结果： 截图 bobo 老师写的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.xiang;/** * 项目名： SelectionSort2 * 包名： com.xiang * 文件名： Selection3 * Created by ning on 2017/12/12. * 描述： bobo 的选择排序的优化 */public class SelectionSort3 &#123; // 我们的算法类不允许产生任何实例 private SelectionSort3()&#123;&#125; public static void sort(Comparable[] arr)&#123; int left = 0, right = arr.length - 1; while(left &lt; right)&#123; int minIndex = left; int maxIndex = right; // 在每一轮查找时, 要保证arr[minIndex] &lt;= arr[maxIndex] if(arr[minIndex].compareTo(arr[maxIndex]) &gt; 0) swap(arr, minIndex, maxIndex); for(int i = left + 1 ; i &lt; right; i ++) if(arr[i].compareTo(arr[minIndex]) &lt; 0) minIndex = i; else if(arr[i].compareTo(arr[maxIndex]) &gt; 0) maxIndex = i; swap(arr, left, minIndex); swap(arr, right, maxIndex); left ++; right --; &#125; &#125; private static void swap(Object[] arr, int i, int j) &#123; Object t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125; // 测试SelectionSort2 public static void main(String[] args) &#123; int N = 10000; Integer[] arr = SortTestHelper.generateRandomArray(N, 0, 100000); SortTestHelper.testSort("com.xiang.SelectionSort3", arr); SortTestHelper.testSort("com.xiang.SelectionSort2",arr); SortTestHelper.testSort("com.xiang.SelectionSort",arr); return; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>Java 算法与数据结构（慕课网）</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TaskList：SAIC MAXUS]]></title>
    <url>%2F2017%2F10%2F04%2FTaskList%EF%BC%9ASAIC-MAXUS%2F</url>
    <content type="text"><![CDATA[bug 记录 退出，在被迫下线之后重新登录后再退出，还是返回了主界面 DIY ABCD 行程、车况 1234java.lang.NullPointerException: Attempt to invoke interface method 'io.netty.channel.ChannelFuture io.netty.channel.Channel.writeAndFlush(java.lang.Object)' on a null object reference at com.example.aidrive3.SignIn.sendMessage(SignIn.java:981) at com.example.aidrive3.SignIn.access$1000(SignIn.java:51) at com.example.aidrive3.SignIn$4$1.run(SignIn.java:447) 断网时，系统退出？ 去掉状态栏下拉时的阴影,状态栏下拉如何去除阴影？ Android WebView页面加载优化 数据库实现手机验证码滚动广告搜索智能推荐购买支付语音]]></content>
      <categories>
        <category>上汽大通</category>
      </categories>
      <tags>
        <tag>任务清单</tag>
        <tag>上汽大通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Writing specifications]]></title>
    <url>%2F2017%2F10%2F02%2FWriting-specifications%2F</url>
    <content type="text"><![CDATA[摘自： stormzhang 的博客：每个人都需要的中文排版指南 空格 中英文之间需要加空格 eg. 大家可以搜索公众号 AndroidDeveloper 或者 googdev 关注我。 中文与数字之间需要加空格 eg. 不知不觉，我都快 30 岁了。 数字与单位之间需要加空格 eg. 我有一块 20 TB 的硬盘，鬼知道我是怎么用完的。 完整的英文整句时标点与单词之间需要加空格 eg. Stay hungry, stay foolish. 但是也有一些例外。 度的标志、百分号不加空格 eg. 今天气温有 30° 的高温。 eg. 据统计，关注公众号 AndroidDeveloper 的读者中有 80% 是长得好看的。 全角标点与其他字符之间不加空格 eg. 大家好，我是 stormzhang，请多多关照。 标点全角和半角是英文和中文的编码规范不同遗留下的问题，简单来说，全角占两个字节，半角占一个字节，你可以理解成中文汉字是全角，英文字母是半角，不过半角全角主要是针对标点符号来说的，中文标点占两个字节，英文标点占一个字节。体现在排版上的差异就是，全角字符屏幕打印宽度是两个，而半角字符屏幕打印宽度是一个，如中文逗号和英文逗号他们的显示分别是「，」和「,」。 使用全角中文标点 中文排版中所有的标点都应该使用中文全角中文标点 eg. 大家好，我是 stormzhang。 遇到英文整句、特殊名词时使用半角标点。 eg. 乔布斯说过：「Stay hungry, stay foolish.」 eg. Facebook, Inc. 使用直角引号 我国国家标准要求弯引号，但是个人建议在新媒体排版时使用直角引号。 eg. 你竟然不知道「帅比张」？ 如果引号再使用引号使用直角双引号。 eg. 我质问他，「你难道忘记『帅比张』了么？」 其他除以上之外，还有一些其他标准推荐大家使用的。 英文名词首字母尽量大写 eg. Google、Android、Facebook 专有名词使用正确的大小写 eg. GitHub、iOS、iPhone 6s、MacBook Pro 首行不要缩进 大家一般都采用「空出一行」进行自然段与自然段之间的区分，这种写作方式非常省事，而且很整齐。 ​]]></content>
      <categories>
        <category>stormzhang</category>
        <category>Blog 书写规范</category>
      </categories>
      <tags>
        <tag>stormzhang</tag>
        <tag>中文排版指南</tag>
        <tag>书写规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BookList]]></title>
    <url>%2F2017%2F09%2F30%2FBookList%2F</url>
    <content type="text"><![CDATA[过去完成时 Head First Java： 8 - 9 月 现在进行时 Android 第一行代码：10 月 Java 算法与数据结构（慕课网）：10 - 11 月 15 日，每天一小部分，你努力时，全世界都会给你让路。 Head First Java 总结：10月 。每晚补一点。 Head First 设计模式：10 - 11 月 15 日，和慕课网的视频结合着一起看。 CET - 6（10 月 - 11月 15日）：考研单词一天背一单元；一周看一次语法视频。 将来时]]></content>
      <categories>
        <category>书单</category>
      </categories>
      <tags>
        <tag>书单</tag>
        <tag>任务清单</tag>
        <tag>Head First Java</tag>
        <tag>Effective Java</tag>
        <tag>Thinking in Java</tag>
        <tag>Android 第一行代码</tag>
        <tag>Head First 设计模式</tag>
        <tag>CET - 6</tag>
        <tag>Java 算法与数据结构（慕课网）</tag>
        <tag>玩转算法面试 LeetCode 题库分门别类详细解析（慕课网）</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub + Hexo + NexT 主题 免费搭建博客-参考链接收集]]></title>
    <url>%2F2017%2F09%2F30%2FFreeBlog%EF%BC%9AGitHub-Hexo%2F</url>
    <content type="text"><![CDATA[博客搭建 GitHub 官网：https://github.com/ Hexo 官网：https://hexo.io/zh-cn/ 部署博客 NexT 主题官网：http://theme-next.iissnan.com/ 美化博客 NexT 源码地址：用于失误修改next文件夹里的文件，可以参考源码还原 最适合新手的 GitHub + Hexo 「大话」博客搭建教程 建立博客系列（三）：Hexo 安装配置 建立博客系列（四）：NexT 主题相关配置 建立博客系列（五）：发布第一篇文章 记录第一次搭建 Hexo 一些错误的解决方案 解决 Hexo 神烦的 DTraceProviderBindings MODULE_NOT_FOUND Mac 快速显示或隐藏“隐藏”文件 Mac 设置文件权限问题 博客主题 NexT 参考 Jark’s Blog 随风丶亮 主题 NexT 美化 NexT 主题里用到的所有图标 网站 icon 下载地址 NexT 主题配置及优化-动态背景等大全 Hexo 的 NexT 主题个性化教程:打造炫酷网站 NexT 主题添加腾讯空间404公益页面 Hexo 文章管理和写文章 Hexo 使用攻略：（四）Hexo 的分类和标签设置 分类和标签有什么区别和关联? Front - matter | Hexo 官网关于文章分类的解释 Markdown 官网 认识与入门 Markdown Markdown 语法手册 （完整整理版） Mac 下好用的 Markdown 编辑器– Mou Mac 下好用的 Markdown 编辑器—Typora Mac 下好用的图床工具 CloudApp（科学上网 + 软件收费 + 14天试用） 如何利用 GitHub 在 Markdown 中优雅地插入图片 Hexo-设置阅读全文 注意 修改文件之前先行备份，以防更改失败； 找不到的信息，结合官网查询。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F09%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
