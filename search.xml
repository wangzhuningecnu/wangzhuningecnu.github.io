<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android 开发中遇到的 bug]]></title>
    <url>%2F2017%2F10%2F30%2FAndroid-developing-bug%2F</url>
    <content type="text"><![CDATA[NoSuchMethodError: No static method wrapSharedElementTransition上汽大通项目遇到火山级 bug，点击 123456789101112131415java.lang.NoSuchMethodError: No static method wrapSharedElementTransition(Ljava/lang/Object;)Ljava/lang/Object; in class Landroid/support/v4/app/FragmentTransitionCompat21; or its super classes (declaration of 'android.support.v4.app.FragmentTransitionCompat21' appears in /data/app/com.example.aidrive2-1/base.apk) at android.support.v4.app.BackStackRecord.getSharedElementTransition(BackStackRecord.java:1156) at android.support.v4.app.BackStackRecord.configureTransitions(BackStackRecord.java:1222) at android.support.v4.app.BackStackRecord.beginTransition(BackStackRecord.java:1112) at android.support.v4.app.BackStackRecord.run(BackStackRecord.java:721) at android.support.v4.app.FragmentManagerImpl.execPendingActions(FragmentManager.java:1677) at android.support.v4.app.FragmentManagerImpl$1.run(FragmentManager.java:536) at android.os.Handler.handleCallback(Handler.java:815) at android.os.Handler.dispatchMessage(Handler.java:104) at android.os.Looper.loop(Looper.java:194) at android.app.ActivityThread.main(ActivityThread.java:5556) at java.lang.reflect.Method.invoke(Native Method) at java.lang.reflect.Method.invoke(Method.java:372) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:967) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:762)]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文相关]]></title>
    <url>%2F2017%2F10%2F29%2FMyPaper%2F</url>
    <content type="text"><![CDATA[彩虹无线发布“立方体计划”：前装车联网大数据的两种玩法]]></content>
      <categories>
        <category>毕设论文</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hencoder 朱凯的高级教程]]></title>
    <url>%2F2017%2F10%2F29%2Fhencoder%2F</url>
    <content type="text"><![CDATA[给高级 Android 工程师的进阶手册第一讲，讲 UI 一般使用 自带控件 + 开源库，可以实现大部分 UI 效果。但一些新颖的效果，要自定义 View 来实现。 自定义 View 的 3 个关键点： 布局 绘制 触摸反馈 听课： 录播的视频 + 文字 + 练习项目。视频负责打通概念，文字负责阐述细节，练习项目负责最后一公里，让你从「我懂了」变成「我会了」 自定义 View 1-1 绘制基础绘制就是控件内容的显示。 自定义绘制就是你来接管绘制的过程，操作绘制细节。使用系统 API 是绘制不出柱状图和饼形图的，即使绘制出来，性能也不佳，这时要使用自定义绘制 View。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>朱凯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[颠覆你的传统英语学习 - 杨萃先]]></title>
    <url>%2F2017%2F10%2F27%2FPronunciation-of-Miss-Yang%2F</url>
    <content type="text"><![CDATA[视频地址：撕掉单词语法书，颠覆你的传统英语学习 第 0 课 - 找对方法 本节课作业： 下载 app，找到和自己生活、工作密切相关的部分听，听不懂的，立马查，可以看字幕，怎么能听懂怎么听。听满 100 小时。 生活中，环境中，只要是不会的生词，立马查。至少找到五个不会的。 关注老师个人公众号 “途正英语”。看老师的文章和小故事。 找志同道合的小伙伴讨论，说英语。 第 1 课 - 背单词大法 记单词： 作业：]]></content>
      <categories>
        <category>英语</category>
        <category>英语口语</category>
      </categories>
      <tags>
        <tag>英语口语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纪老师英语音标课程]]></title>
    <url>%2F2017%2F10%2F26%2FPronunciation-of-Miss-Ji%2F</url>
    <content type="text"><![CDATA[视频地址纪老师英语 - 音标篇 纪老师 英语音标口诀记忆法 – 音标一 5 个元音 + 1 个辅音 纪老师 英语音标口诀记忆法 – 音标二 5 个辅音的发音方法 纪老师 英语音标口诀记忆法 – 音标三 8 个双元音的发音方法 纪老师 英语音标口诀记忆法 – 音标四 12 个辅音的发音方法 纪老师 英语音标口诀记忆法 – 音标实战篇 英语习惯用语发音练习 1 句 纪老师 英语音标口诀记忆法 – 音标实战篇 英语习惯用语发音练习 32 句 纪老师 英语音标口诀记忆法 – 音标实战篇 英语习惯用语发音练习 71 句 纪老师 英语音标口诀记忆法(光碟 7 ) 音标一元音：20 个，相当于韵母 辅音：28 个，相当于声母 第一节学习 5 个元音和 1 个辅音： 发言口诀： 音标二第二节学习 5 个辅音 f、l、m、n 的发音：一种是读汉语拼音里的flmn，另一种是读这四个英文字母发音的尾音。 后面有可以一起拼读的就发flmn的音，没有一起拼读的音就发英文字母的尾音。 r 后面有可以一起拼读的音就发 ru 音，没有一起拼读的音就发 “儿”化音。 音标三第三节学习 8 个双元音。 英语讲究「滑音」。双元音的读法是从第一个音向后面一个滑动。 新旧音标对比如下： 音标四12 个辅音的发音方法 噘嘴的 s，发汉语拼音的平舌 s 噘嘴的 z，发汉语拼音的平舌 z 噘嘴的 s，发汉语拼音中的咬舌 s 咬舌尖的 r，发汉语拼音中的 r 噘嘴的 ch，发汉语拼音的翘舌 ch 噘嘴的 zh，发汉语拼音的翘舌 zh 噘嘴的 chu，发汉语拼音的翘舌 chu 噘嘴的 zhu，发汉语拼音的翘舌 zhu chi，发音在 c 与 ch 之间，我觉得是 ci zhi，发音在 z 与 zh 之间，我觉得是 zi y，发汉语拼音 yi 不能噘嘴的 wu，上牙轻抚下唇。]]></content>
      <categories>
        <category>音标</category>
      </categories>
      <tags>
        <tag>音标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慕课网 - Android 通用框架设计与完整电商 APP 开发]]></title>
    <url>%2F2017%2F10%2F20%2Fimooc-Android-Complete-e-commerce-app%2F</url>
    <content type="text"><![CDATA[用到的 GitHub 上的库字体库JoanZapata 字体库 123//字体图标compile 'com.joanzapata.iconify:android-iconify-ionicons:2.2.2'compile 'com.joanzapata.iconify:android-iconify-fontawesome:2.2.2' Fragmentation 的库Fragmentation 的库 123//Fragment依赖compile 'me.yokeyword:fragmentation:1.1.6'compile 'me.yokeyword:fragmentation-swipeback:1.1.6' 视图注入的库 ButterKnifeButterKnife 的配置要参考ButterKnife官网，要配置 3 个地方 123//ButterKnife依赖compile 'com.jakewharton:butterknife:8.8.1'annotationProcessor 'com.jakewharton:butterknife-compiler:8.8.1' 123456789101112131415161718buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.3.3' // ButterKnife 插件 classpath 'com.jakewharton:butterknife-gradle-plugin:8.8.1' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;allprojects &#123; repositories &#123; jcenter() mavenCentral() &#125;&#125; 12apply plugin: 'com.android.library'apply plugin: 'com.jakewharton.butterknife' BufferKnife 插件的作用是生成 R2 的类，R2 类是生成视图绑定需要的唯一 ID，资源文件 R 只能在为 application 类型的 module 里使用，为 library 类型的 module 使用 BufferKnife 插件根据 R 生成 R2 的资源文件来访问视图绑定的 ID。 网络框架 retrofitretrofit 理解 RESTful 架构 RESTful API 设计最佳实践 12345//网络请求依赖 compile 'com.squareup.okio:okio:1.13.0' compile 'com.squareup.okhttp3:okhttp:3.8.1' compile 'com.squareup.retrofit2:retrofit:2.3.0' compile 'com.squareup.retrofit2:converter-scalars:2.3.0' Loading 加载库AVLoadingIndicatorView 12//loading 依赖 compile 'com.wang.avi:library:2.1.3' 启动页倒计时首次启动可以滑动Android-ConvenientBanner 全屏的广告轮播]]></content>
      <categories>
        <category>慕课网</category>
        <category>Android 通用框架设计与完整电商 APP 开发</category>
      </categories>
      <tags>
        <tag>未解决的 bug</tag>
        <tag>Android 通用框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慕课网 - 懒人必备之 Android 效率开发框架]]></title>
    <url>%2F2017%2F10%2F16%2Fimooc-Android-Framework-video-8302%2F</url>
    <content type="text"><![CDATA[什么是框架 框架是地基，地基打的好，不管业务层有多大的变化，都不会影响到正常的开发. 不用框架，理论上讲是可以的，但是开发成本就变高了，很多集成服务要自己搭建 Android 中哪些可以抽象成为框架的： 网络模块 图片缓存模块 数据库模块 UI 基础 把这些抽出来之后，只要写业务层就好了。 AndroidAnnotation AndroidAnnotation 官网 AndroidAnnotation 是基于注解的标签库，所有标签。 AS 配置androidannotationsapp/build.gradle: 123456789101112131415def AAVersion = '4.3.0'dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', &#123; exclude group: 'com.android.support', module: 'support-annotations' &#125;) compile 'com.android.support:appcompat-v7:25.3.1' compile 'com.android.support.constraint:constraint-layout:1.0.1' testCompile 'junit:junit:4.12' //androidannotations 注解标签库 annotationProcessor "org.androidannotations:androidannotations:$AAVersion" compile "org.androidannotations:androidannotations-api:$AAVersion"&#125; AndroidManifest.xml 中每个使用 androidAnnotations 的 Activity 名字后面都要添加_ 1234&lt;activity android:name=".MainActivity_" android:label="FirstTest"&gt;&lt;/activity&gt; .MainActivity 为什么要加 ？ 是 androidAnnotations ，在处理的过程中，生成的 .MainActivity_ 的 Activity。 参考了：http://www.cnblogs.com/l2rf/p/4971825.html http://blog.csdn.net/xx326664162/article/details/68490059 http://blog.csdn.net/doris_d/article/details/52634450 http://www.cnblogs.com/caobotao/p/5138935.html http://blog.csdn.net/caiwenfeng_for_23/article/details/45801151 https://github.com/androidannotations/androidannotations/blob/master/examples/gradle/build.gradle 没搞好，报错。 1234567891011121314151617181920212223242526272829Process: com.ning.helloworld, PID: 14359 java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;com.ning.helloworld/com.ning.helloworld.MainActivity_&#125;: java.lang.NullPointerException: Attempt to invoke virtual method 'void android.widget.Button.setOnClickListener(android.view.View$OnClickListener)' on a null object reference at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2470) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2532) at android.app.ActivityThread.access$800(ActivityThread.java:169) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1421) at android.os.Handler.dispatchMessage(Handler.java:111) at android.os.Looper.loop(Looper.java:194) at android.app.ActivityThread.main(ActivityThread.java:5556) at java.lang.reflect.Method.invoke(Native Method) at java.lang.reflect.Method.invoke(Method.java:372) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:967) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:762) Caused by: java.lang.NullPointerException: Attempt to invoke virtual method 'void android.widget.Button.setOnClickListener(android.view.View$OnClickListener)' on a null object reference at com.ning.helloworld.MainActivity.onCreate(MainActivity.java:67) at com.ning.helloworld.MainActivity_.onCreate(MainActivity_.java:33) at android.app.Activity.performCreate(Activity.java:5975) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1111) at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2423) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2532) at android.app.ActivityThread.access$800(ActivityThread.java:169) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1421) at android.os.Handler.dispatchMessage(Handler.java:111) at android.os.Looper.loop(Looper.java:194) at android.app.ActivityThread.main(ActivityThread.java:5556) at java.lang.reflect.Method.invoke(Native Method) at java.lang.reflect.Method.invoke(Method.java:372) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:967) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:762) annotation 的使用 看到这： 课程网址]]></content>
      <categories>
        <category>慕课网</category>
        <category>懒人必备之 Android 效率开发框架</category>
      </categories>
      <tags>
        <tag>Android 框架</tag>
        <tag>未解决的 bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 第一行代码]]></title>
    <url>%2F2017%2F10%2F10%2FAndroid-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Chapter 1 入门Android 各版本对应的 API 版本号 系统代号 API 4.0.3 - 4.0.4 Ice Cream Sandwich 15 4.1.x 4.2.x 4.3 Jelly Bean 16 17 18 4.4 KitKat 19 5.0 5.1 Lollipop 21 22 6.0 Marshmallow 23 7.0 7.1 Nougat 24 25 8.0 Oreo 26 Android 程序的项目结构 gradle 下包含了 gradle wrapper 的配置文件。 gradle.properties 是全局的 gradle 配置文件。这里配置的属性将会影响到项目中所有的 gradle 编译脚本。 app 是开发的主要工作目录。 其他都是些 AS 自动生成的文件，不需要修改。 .gitignore 文件，记录不需要提交到 Git 的东西，节省 Git 服务器资源和带宽、减少冲突。只在项目的根目录里创建这个文件就好，一般的 model 不需要这个文件。（慕课网 - Android 通用架构设计与完整电商App开发 学到的） app下的目录结构 build 里是编译时自动生成的文件，不需要改动。 libs 里放的是你项目中使用到的第三方 jar 包，放在这里的 jar 包会被自动添加进构建路径中去。 androidTest 是用来编写 Android Test 测试用例的，可以进行自动化测试 java 里是放 Java 代码的地方。 res 里 图片放在 drawable 中，布局放在 layout 中，字符放在 values 中，字符包括字符串、样式、颜色等配置，应用图标放在 mipmap 。 res 里的资源有以下两种引用方式： 在代码中：通过 R.资源所在最近文件夹.资源名称，如 R.string.hellp_world 在 xml 中：通过 @资源所在最近文件夹/资源名称，如 @string/hello_wrold AndroidManifest.xml 是整个 Android 项目的配置文件，四大组件都要在此注册，这个文件给应用程序添加权限声明。 test 里用来编写 Unit Test 测试用例，是自动化测试的另一种方式。 build.gradle 是 app 模块的 gradle 构建脚本。 proguard-rules.pro 用于指定项目代码的混淆规则。 app 里的 build.gradleAndroid 的日志工具 Log Log.v() Log.d() Log.i() :important，分析用户行为的数据。 Log.w() Log.e() 1 级别最低，5 级别最高。每次打印日志时，会把此级别以及此级别以上的日志显示出来，使用关键字过滤，支持正则表达式。 Log.d() 方法会传入 2 个参数，第一个是 tag ，一般传入当前类名，用于打印信息过滤，第二个是 msg ，即要打印的具体内容。 AS 快捷键： 在 onCreate() 方法的外面，输入 logt + tab ，生成一个以当前类名作为值的 TAG 常量； logd + tab logi + tab logw + tab loge + tab logt + tab Chapter 2 活动活动的注册在活动中使用 Toast在活动中添加 Menu P38销毁活动 finish（）使用 Intent Intent 是各组件之间进行交互的重要方式。它有两个作用： 指明当前组件想要执行的动作。即意图，如：启动活动、服务、发送广播。 在不同组件之间传递数据。 Intent 有显式和隐式两种。 更多隐式 Intent 的用法 使用 Intent 显示网页 123Intent intent = new Intent(Intent.ACTION_VIEW);intent.setData(Uri.parse("http://www.wangzhuningecnu.github.io"));startActivity(intent); 使用 Intent 指定其他协议，如 geo 地理位置，tel 拨打电话 123Intent intent = new Intent(Intent.ACTION_DIAL);intent.setData(Uri.parse("tel:10000"));startActivity(intent);]]></content>
      <categories>
        <category>Android</category>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>第一行代码</tag>
        <tag>任务清单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective Java]]></title>
    <url>%2F2017%2F10%2F09%2FEffective-Java%2F</url>
    <content type="text"><![CDATA[Chapter 1本书基本原则 清晰性、简洁性：模块的用户永远不应被模块的行为迷惑 模块要尽可能小，但又不能太小（模块 Module 是指任何可重用的组件，包括单个方法，到多个包的复杂系统） 代码应该被重用，而不是被拷贝 模块之间的依赖性应该尽可能降到最小 错误应该尽早被检测出来，最好是在编译时 写出清晰、正确、可用、健壮、灵活和可维护的程序来。如果你能做到这一点，那么获得所需的性能就比较简单了。]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
      </categories>
      <tags>
        <tag>任务清单</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Primary Question]]></title>
    <url>%2F2017%2F10%2F08%2FJava-Primary-Question%2F</url>
    <content type="text"><![CDATA[引用数组的赋值问题元素对象为 Student 类，数组元素对象为什么不能这样声明： 123Student[] arrStudent = new Student[]&#123;&#123;"D",90&#125; , &#123;"C",100&#125; , &#123;"B",95&#125; , &#123;"A",95&#125;&#125;;Student[] arrStudent = new Student[]()&#123;&#123;"D",90&#125; , &#123;"C",100&#125; , &#123;"B",95&#125; , &#123;"A",95&#125;&#125;; Integer 的包装类就可以这样声明： 1234567891011121314151617181920212223//测试 IntegerInteger arrInteger[] = &#123;10,8,9,7,4,6,5,3,2,1&#125;;SelectionSort.selectionSort(arrInteger);for (Integer i : arrInteger )&#123; System.out.print(i + " ");&#125;System.out.println();//测试 DoubleDouble arrDouble[] = &#123;4.3,4.2,3.3,2.1,1.0&#125;;SelectionSort.selectionSort(arrDouble);for (Double double1 : arrDouble) &#123; System.out.print(double1 + " ");&#125;System.out.println();//测试 StringString[] arrString = &#123;"D","C","B","A"&#125;;SelectionSort.selectionSort(arrString);for (String string : arrString) &#123; System.out.print(string+" ");&#125;System.out.println(); 引用类型的数组不可以在声明时赋值吗？ 引用类型数组怎么定义的？ assert 是保证什么的东东，不是类，也不是静态方法，那应该是Object里的,但是没有1assert randomLeft &lt;= randomRight; 这句能保证的是，randomLeft 的值 如果大于 randomRight 的值，则会把他们两个调换。不会报 true 或 false ，也不会报错，程序还是能运行。 泛型泛型啊Foreach 用法注意若是给数组赋值，则不能用 Foreach ，因为 foreach 只是把值拷贝给一个临时变量，并不会赋值给数组本身。 错误示例： 123for (Integer integer : arr) &#123; integer = new Integer((int)(Math.random()*(randomRight-randomLeft+1)+randomLeft)); &#125; 确实生成了随机数给 integer,但并没有给数组。 Java的反射机制]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java问题贴</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sortAlgorithm]]></title>
    <url>%2F2017%2F10%2F07%2FsortAlgorithm%2F</url>
    <content type="text"><![CDATA[最简单的 — 选择排序 选择排序：每次选择剩余元素中的最小的那个，与当前位置互换。 选择排序不能中断，插入排序根据条件可能中断 选择排序动态图 选择排序示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class SelectionSort &#123; private SelectionSort()&#123;&#125;//此算法类不允许产生实例 public static void selectionSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; //找到剩余元素（下标为 [i，arr.length)中的元素）中最小元素的下标 int min = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) &#123; min = j; &#125; &#125; swap(arr, min, i);//将选择出的最小元素与当前位置元素 arr[i] 交换 for (int n : arr) &#123; System.out.print(n +" "); &#125; System.out.println(); &#125; &#125; public static void swap(int arr[],int n,int m) &#123; int temp = arr[n]; arr[n] = arr[m]; arr[m] = temp; &#125; public static void main(String[] args) &#123; int arr[] = &#123;10,8,9,7,4,6,5,3,2,1&#125;; SelectionSort.selectionSort(arr); for (int i : arr) &#123; System.out.print(i + " "); &#125; System.out.println(); &#125;&#125;输出：1 8 9 7 4 6 5 3 2 10 1 2 9 7 4 6 5 3 8 10 1 2 3 7 4 6 5 9 8 10 1 2 3 4 7 6 5 9 8 10 1 2 3 4 5 6 7 9 8 10 1 2 3 4 5 6 7 9 8 10 1 2 3 4 5 6 7 9 8 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 加了泛型的选择排序123456789101112131415161718192021222324252627282930313233343536package com.ning;public class Student implements Comparable&lt;Student&gt;&#123; private String name; private int grade; public Student(String name,int grade) &#123; // TODO Auto-generated constructor stub this.name = name; this.grade = grade; &#125; public Student() &#123; // TODO Auto-generated constructor stub &#125; // 定义Student的compareTo函数 // 如果分数相等，则按照名字的字母序排序 // 如果分数不等，则分数高的靠前 @Override public int compareTo(Student o) &#123; // TODO Auto-generated method stub if (this.grade &gt; o.grade) &#123; return 1; &#125;else if (this.grade &lt; o.grade) &#123; return -1; &#125;else &#123; return this.name.compareTo(o.name); &#125; &#125; @Override public String toString() &#123; // TODO Auto-generated method stub return "Student: " + this.name + " " + this.grade; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.ning;import java.lang.management.MemoryManagerMXBean;public class SelectionSort &#123; private SelectionSort()&#123;&#125;//算法类不允许产生实例 public static void selectionSort(Comparable[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; //找到 [i，arr.length)中 最小元素的下标 int min = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; //使用compareTo方法比较两个Comparable对象的大小 if (arr[j].compareTo(arr[min]) &lt; 0) &#123; min = j; &#125; &#125; swap(arr, min, i);//将选择出的最小元素与 i 交换 for (Object n : arr) &#123; System.out.print(n +" "); &#125; System.out.println(); &#125; &#125; public static void swap(Object arr[],int n,int m) &#123; Object temp = arr[n]; arr[n] = arr[m]; arr[m] = temp; &#125; public static void main(String[] args) &#123; //测试 Integer Integer arrInteger[] = &#123;10,8,9,7,4,6,5,3,2,1&#125;; SelectionSort.selectionSort(arrInteger); for (Integer i : arrInteger )&#123; System.out.print(i + " "); &#125; System.out.println(); //测试 Double Double arrDouble[] = &#123;4.3,4.2,3.3,2.1,1.0&#125;; SelectionSort.selectionSort(arrDouble); for (Double double1 : arrDouble) &#123; System.out.print(double1 + " "); &#125; System.out.println(); //测试 String String[] arrString = &#123;"D","C","B","A"&#125;; SelectionSort.selectionSort(arrString); for (String string : arrString) &#123; System.out.print(string+" "); &#125; System.out.println(); //测试自定义的 Student 类 Student[] arrStudent = new Student[3]; arrStudent[0] = new Student("wang",100); arrStudent[1] = new Student("zhang",98); arrStudent[2] = new Student("xiang",79); SelectionSort.selectionSort(arrStudent); for (Student student : arrStudent) &#123; System.out.print(student + " "); &#125; System.out.println(); &#125;&#125;输出结果：1 8 9 7 4 6 5 3 2 10 1 2 9 7 4 6 5 3 8 10 1 2 3 7 4 6 5 9 8 10 1 2 3 4 7 6 5 9 8 10 1 2 3 4 5 6 7 9 8 10 1 2 3 4 5 6 7 9 8 10 1 2 3 4 5 6 7 9 8 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1.0 4.2 3.3 2.1 4.3 1.0 2.1 3.3 4.2 4.3 1.0 2.1 3.3 4.2 4.3 1.0 2.1 3.3 4.2 4.3 1.0 2.1 3.3 4.2 4.3 1.0 2.1 3.3 4.2 4.3 A C B D A B C D A B C D A B C D A B C D Student: xiang 79 Student: zhang 98 Student: wang 100 Student: xiang 79 Student: zhang 98 Student: wang 100 Student: xiang 79 Student: zhang 98 Student: wang 100 Student: xiang 79 Student: zhang 98 Student: wang 100 随机生成算法测试用例的 SortTestHelper 类1234567891011121314151617181920212223242526package com.ning;public class SortTestHelper &#123; //SortTestHelper 不允许产生任何实例 private SortTestHelper() &#123;&#125; //生成 n 个元素的随机数组，每个随机数的范围是【randomLeft，randomRight】 public static Integer[] generateRandomArray(int n,int randomLeft,int randomRight) &#123; assert randomLeft &lt;= randomRight; Integer[] arr = new Integer[n]; for (int i = 0 ; i &lt; arr.length ; i++) &#123; arr[i] = new Integer((int)(Math.random()*(randomRight-randomLeft+1)+randomLeft));// System.out.println(arr[i]); &#125; SortTestHelper.printArray(arr); return arr; &#125; public static void printArray(Object[] arr) &#123; for (Object o : arr) &#123; System.out.print(o + " "); &#125; System.out.println(); &#125;&#125; 注意：数组赋值的时候，不能使用 foreach 写法，否则只是赋值给了局部变量，并没有赋值给数组本身。 SortTestHelper 类的使用： 12345//测试 Integer int n = 10000; Integer arrInteger[] = SortTestHelper.generateRandomArray(n, 0, n); SelectionSort.selectionSort(arrInteger); SortTestHelper.printArray(arrInteger); 在 SortTestHelper 类中加入测试算法的性能的代码SortTestHelper 类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package bobo.algo;import java.lang.reflect.Method;import java.lang.Class;public class SortTestHelper &#123; //······ // 判断arr数组是否有序 public static boolean isSorted(Comparable[] arr)&#123; for( int i = 0 ; i &lt; arr.length - 1 ; i ++ ) if( arr[i].compareTo(arr[i+1]) &gt; 0 ) return false; return true; &#125; // 测试sortClassName所对应的排序算法排序arr数组所得到结果的正确性和算法运行时间 public static void testSort(String sortClassName, Comparable[] arr)&#123; // 通过Java的反射机制，通过排序的类名，运行排序函数 // * 依然是，使用反射机制并不是这个课程的重点, 大家也完全可以使用自己的方式书写代码, 最终只要能够测试出自己书写的算法的效率即可 // * 推荐大家阅读我在问答区向大家分享的一个学习心得: 【学习心得分享】请大家抓大放小，不要纠结于C++语言的语法细节 // * 链接: http://coding.imooc.com/learn/questiondetail/4100.html try&#123; // 通过sortClassName获得排序函数的Class对象 Class sortClass = Class.forName(sortClassName); // 通过排序函数的Class对象获得排序方法 Method sortMethod = sortClass.getMethod("sort",new Class[]&#123;Comparable[].class&#125;); // 排序参数只有一个，是可比较数组arr Object[] params = new Object[]&#123;arr&#125;; long startTime = System.currentTimeMillis(); // 调用排序函数 sortMethod.invoke(null,params); long endTime = System.currentTimeMillis(); assert isSorted( arr ); System.out.println( sortClass.getSimpleName()+ " : " + (endTime-startTime) + "ms" ); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 客户端： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package bobo.algo;import java.util.*;public class SelectionSort&#123; // 我们的算法类不允许产生任何实例 private SelectionSort()&#123;&#125; public static void sort(Comparable[] arr)&#123; int n = arr.length; for( int i = 0 ; i &lt; n ; i ++ )&#123; // 寻找[i, n)区间里的最小值的索引 int minIndex = i; for( int j = i + 1 ; j &lt; n ; j ++ ) // 使用compareTo方法比较两个Comparable对象的大小 if( arr[j].compareTo( arr[minIndex] ) &lt; 0 ) minIndex = j; swap( arr , i , minIndex); &#125; &#125; private static void swap(Object[] arr, int i, int j) &#123; Object t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125; public static void main(String[] args) &#123; // 测试排序算法辅助函数 int N = 10000; Integer[] arr = SortTestHelper.generateRandomArray(N, 0, N); SortTestHelper.testSort("bobo.algo.SelectionSort", arr); return; &#125;&#125;输出结果：N = 100 时，排序数...SelectionSort: 1msN = 1000 时，排序数...SelectionSort: 12msN = 10000 时，排序数..SelectionSort: 140msN = 100000 时，排序数.SelectionSort: 11577ms 同样 n² 的 — 插入排序 插入排序：把后面的元素，一个位置一个位置的往前，插入到合适的位置 插入排序像是一边摸牌，一边码牌；选择排序像是发牌完毕后，再码牌 插入排序动态图 插入排序示例代码123456789101112131415161718192021222324package com.ning;public class InsertionSort &#123; // 我们的算法类不允许产生任何实例 private InsertionSort()&#123;&#125; public static void sort(Comparable arr[]) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; // 寻找元素arr[i]合适的插入位置 for (int j = i; j &gt;= 1 ; j--) &#123; if (arr[j].compareTo(arr[j-1])&lt;0) &#123; swap(arr,j,j-1); &#125;else &#123; break; &#125; &#125; &#125; &#125; private static void swap(Object[] a,int n,int m) &#123; Object temp = a[m]; a[m] = a[n]; a[n] = temp; &#125;&#125; 插入排序与选择排序的比较123456789101112 int n = 100000; Integer[] arr1 = SortTestHelper.generateRandomArray(n, 0, n); Integer[] arr2 = Arrays.copyOf(arr1, arr1.length); //Java 中有赋值数组的方法，C++ 中没有 /*SelectionSort.selectionSort(arrInteger); SortTestHelper.printArray(arrInteger);*/ SortTestHelper.testSort("com.ning.SelectionSort", arr1); SortTestHelper.testSort("com.ning.InsertionSort", arr2);结果：SelectionSort: 14086msInsertionSort: 15634ms 比较 SelectionSort 和 InsertionSort 两种排序算法的性能效率 此时，插入排序比选择排序性能略低 插入排序的优化 插入排序在元素本就在该位置时，会结束本次比较，按理说比不能中断的选择排序要快，但并非如此，为何？ 因为插入排序在遍历的同时，也在不停交换，交换操作比比较更耗时，每次交换都有三次赋值的操作。 插入排序优化示意图 插入排序优化示例代码]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>Java 算法与数据结构（慕课网）</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TaskList：SAIC MAXUS]]></title>
    <url>%2F2017%2F10%2F04%2FTaskList%EF%BC%9ASAIC-MAXUS%2F</url>
    <content type="text"><![CDATA[数据库实现手机验证码滚动广告搜索智能推荐购买支付语音]]></content>
      <categories>
        <category>上汽大通</category>
      </categories>
      <tags>
        <tag>任务清单</tag>
        <tag>上汽大通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Writing specifications]]></title>
    <url>%2F2017%2F10%2F02%2FWriting-specifications%2F</url>
    <content type="text"><![CDATA[摘自： stormzhang 的博客：每个人都需要的中文排版指南 空格 中英文之间需要加空格 eg. 大家可以搜索公众号 AndroidDeveloper 或者 googdev 关注我。 中文与数字之间需要加空格 eg. 不知不觉，我都快 30 岁了。 数字与单位之间需要加空格 eg. 我有一块 20 TB 的硬盘，鬼知道我是怎么用完的。 完整的英文整句时标点与单词之间需要加空格 eg. Stay hungry, stay foolish. 但是也有一些例外。 度的标志、百分号不加空格 eg. 今天气温有 30° 的高温。 eg. 据统计，关注公众号 AndroidDeveloper 的读者中有 80% 是长得好看的。 全角标点与其他字符之间不加空格 eg. 大家好，我是 stormzhang，请多多关照。 标点全角和半角是英文和中文的编码规范不同遗留下的问题，简单来说，全角占两个字节，半角占一个字节，你可以理解成中文汉字是全角，英文字母是半角，不过半角全角主要是针对标点符号来说的，中文标点占两个字节，英文标点占一个字节。体现在排版上的差异就是，全角字符屏幕打印宽度是两个，而半角字符屏幕打印宽度是一个，如中文逗号和英文逗号他们的显示分别是「，」和「,」。 使用全角中文标点 中文排版中所有的标点都应该使用中文全角中文标点 eg. 大家好，我是 stormzhang。 遇到英文整句、特殊名词时使用半角标点。 eg. 乔布斯说过：「Stay hungry, stay foolish.」 eg. Facebook, Inc. 使用直角引号 我国国家标准要求弯引号，但是个人建议在新媒体排版时使用直角引号。 eg. 你竟然不知道「帅比张」？ 如果引号再使用引号使用直角双引号。 eg. 我质问他，「你难道忘记『帅比张』了么？」 其他除以上之外，还有一些其他标准推荐大家使用的。 英文名词首字母尽量大写 eg. Google、Android、Facebook 专有名词使用正确的大小写 eg. GitHub、iOS、iPhone 6s、MacBook Pro 首行不要缩进 大家一般都采用「空出一行」进行自然段与自然段之间的区分，这种写作方式非常省事，而且很整齐。 ​]]></content>
      <categories>
        <category>stormzhang</category>
      </categories>
      <tags>
        <tag>stormzhang</tag>
        <tag>中文排版指南</tag>
        <tag>书写规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BookList]]></title>
    <url>%2F2017%2F09%2F30%2FBookList%2F</url>
    <content type="text"><![CDATA[过去完成时 Head First Java： 8 - 9 月 现在进行时 Android 第一行代码：10 月 Java 算法与数据结构（慕课网）：10 - 11 月 15 日，每天一小部分，你努力时，全世界都会给你让路。 Head First Java 总结：10月 。每晚补一点。 Head First 设计模式：10 - 11 月 15 日，和慕课网的视频结合着一起看。 CET - 6（10 月 - 11月 15日）：考研单词一天背一单元；一周看一次语法视频。 将来时]]></content>
      <categories>
        <category>书单</category>
      </categories>
      <tags>
        <tag>任务清单</tag>
        <tag>书单</tag>
        <tag>Head First Java</tag>
        <tag>Effective Java</tag>
        <tag>Thinking in Java</tag>
        <tag>Android 第一行代码</tag>
        <tag>Head First 设计模式</tag>
        <tag>CET - 6</tag>
        <tag>Java 算法与数据结构（慕课网）</tag>
        <tag>玩转算法面试 LeetCode 题库分门别类详细解析（慕课网）</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub + Hexo + NexT 主题 免费搭建博客-参考链接收集]]></title>
    <url>%2F2017%2F09%2F30%2FFreeBlog%EF%BC%9AGitHub-Hexo%2F</url>
    <content type="text"><![CDATA[博客搭建 GitHub 官网：https://github.com/ Hexo 官网：https://hexo.io/zh-cn/ 部署博客 NexT 主题官网：http://theme-next.iissnan.com/ 美化博客 NexT 源码地址：用于失误修改next文件夹里的文件，可以参考源码还原 最适合新手的 GitHub + Hexo 「大话」博客搭建教程 建立博客系列（三）：Hexo 安装配置 建立博客系列（四）：NexT 主题相关配置 建立博客系列（五）：发布第一篇文章 记录第一次搭建 Hexo 一些错误的解决方案 解决 Hexo 神烦的 DTraceProviderBindings MODULE_NOT_FOUND Mac 快速显示或隐藏“隐藏”文件 Mac 设置文件权限问题 博客主题 NexT 参考 Jark’s Blog 随风丶亮 主题 NexT 美化 NexT 主题里用到的所有图标 网站 icon 下载地址 NexT 主题配置及优化-动态背景等大全 Hexo 的 NexT 主题个性化教程:打造炫酷网站 NexT 主题添加腾讯空间404公益页面 Hexo 文章管理和写文章 Hexo 使用攻略：（四）Hexo 的分类和标签设置 分类和标签有什么区别和关联? Front - matter | Hexo 官网关于文章分类的解释 Markdown 官网 认识与入门 Markdown Markdown 语法手册 （完整整理版） Mac 下好用的 Markdown 编辑器– Mou Mac 下好用的 Markdown 编辑器—Typora Mac 下好用的图床工具 CloudApp（科学上网 + 软件收费 + 14天试用） 如何利用 GitHub 在 Markdown 中优雅地插入图片 Hexo-设置阅读全文 注意 修改文件之前先行备份，以防更改失败； 找不到的信息，结合官网查询。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F09%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
