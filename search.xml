<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[廖雪峰Python基础]]></title>
    <url>%2F2017%2F12%2F21%2FLiaoXueFeng-Python%2F</url>
    <content type="text"><![CDATA[原文地址：中文，免费，零起点，完整示例，基于最新的Python 3版本。 from：马超 廖雪峰的 Python 教程，不懂得地方再查资料去补充。 找一个实际的项目去练手。写一个爬虫项目。 找到一个已经会 Python 的司机。让他给你指出一条路子，同时在遇到卡壳的地方就找他指点。 要学会看别人代码，查看官方文档。 其实只要你想学习，什么时候开始都不晚，不要担心这担心那，你只需要努力，剩下的交给时间，而你之所以没有变强，只因你还不够努力，要记得付出不亚于任何人的努力。 Python 简介用Python可以做什么？可以做日常任务，比如自动备份你的MP3；可以做网站，很多著名的网站包括YouTube就是Python写的；可以做网络游戏的后台，很多在线游戏的后台都是Python开发的。总之就是能干很多很多事啦。 Python不能写操作系统，这个只能用C语言写；不能写手机应用，只能用Swift/Objective-C（针对iPhone）和Java（针对Android）；不能写3D游戏，最好用C或C++。 Python是著名的“龟叔”Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言。 最近10年最常用的10种编程语言的变化图（TIOBE排行榜）： 总的来说，这几种编程语言各有千秋。C语言是可以用来编写操作系统的贴近硬件的语言，所以，C语言适合开发那些追求运行速度、充分发挥硬件性能的程序。而Python是用来编写应用程序的高级编程语言。 高级编程语言通常都会提供一个比较完善的基础代码库，让你能直接调用，比如，针对电子邮件协议的SMTP库，针对桌面环境的GUI库，在这些已有的代码库的基础上开发，一个电子邮件客户端几天就能开发出来。 Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池（batteries included）”。用Python开发，许多功能不必从零编写，直接使用现成的即可。 除了内置的库外，Python还有大量的第三方库，也就是别人开发的，供你直接使用的东西。当然，如果你开发的代码通过很好的封装，也可以作为第三方库给别人使用。 许多大型网站就是用Python开发的，例如YouTube、Instagram，还有国内的豆瓣。很多大公司，包括Google、Yahoo等，甚至NASA（美国航空航天局）都大量地使用Python。 那Python适合开发哪些类型的应用呢？ 首选是网络应用，包括网站、后台服务等等； 其次是许多日常需要的小工具，包括系统管理员需要的脚本任务等等； 另外就是把其他语言开发的程序再包装起来，方便使用。 任何编程语言都有缺点，Python也不例外。优点说过了，那Python有哪些缺点呢？ 第一个缺点就是运行速度慢，和C程序相比非常慢，因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。 第二个缺点就是代码不能加密。如果要发布你的Python程序，实际上就是发布源代码，这一点跟C语言不同，C语言不用发布源代码，只需要把编译后的机器码（也就是你在Windows上常见的xxx.exe文件）发布出去。要从机器码反推出C代码是不可能的，所以，凡是编译型的语言，都没有这个问题，而解释型的语言，则必须把源码发布出去。 这个缺点仅限于你要编写的软件需要卖给别人挣钱的时候。好消息是目前的互联网时代，靠卖软件授权的商业模式越来越少了，靠网站和移动应用卖服务的模式越来越多了，后一种模式不需要把源码给别人。 当然，Python还有其他若干小缺点，请自行忽略，就不一一列举了。 安装 Python要开始学习Python编程，首先就得把Python安装到你的电脑里。安装后，你会得到Python解释器（就是负责运行Python程序的），一个命令行交互环境，还有一个简单的集成开发环境。 目前，Python有两个版本，一个是2.x版，一个是3.x版，这两个版本是不兼容的。由于3.x版越来越普及，我们的教程将以最新的Python 3.6版本为基础。请确保你的电脑上安装的Python版本是最新的3.6.x，这样，你才能无痛学习这个教程。 Python解释器当我们编写Python代码时，我们得到的是一个包含Python代码的以.py为扩展名的文本文件。要运行代码，就需要Python解释器去执行.py文件。 Python的解释器很多，但使用最广泛的还是CPython。如果要和Java或.Net平台交互，最好的办法是通过网络调用来交互，确保各程序之间的独立性，而不是用Jython或IronPython。 当你在终端或者cmd里输入python3的时候, 就是启动了CPython解释器, 安装了Python会默认带一个IDLE, 该软件就是基于CPython做的一个IDE. pycharm是一个IDE，类似Python自带的IDLE、Spyder、Sublime等等，它们都只是编辑器，是用来编写代码的，而CPython、IPython、PyPy等，这些是解释器，是用来执行Python代码的，这两者是不一样的。 命令行模式和Python交互模式命令行模式： 在Windows开始菜单选择“命令提示符”，就进入到命令行模式，它的提示符类似C:\&gt;， 在命令行模式下，可以执行python进入Python交互式环境，也可以执行python hello.py运行一个.py文件。 执行一个.py文件只能在命令行模式执行。 Python交互模式： 在命令行模式下敲命令python，就看到类似如下的一堆文本输出，然后就进入到Python交互模式，它的提示符是&gt;&gt;&gt;。 在Python交互模式下输入exit()并回车，就退出了Python交互模式，并回到命令行模式。 Python交互模式的代码是输入一行，执行一行，而命令行模式下直接运行.py文件是一次性执行该文件内的所有代码。可见，Python交互模式主要是为了调试Python代码用的，也便于初学者学习，它不是正式运行Python代码的环境！ 使用文本编辑器py文件名只能是英文字母、数字和下划线的组合。 用Python开发程序，完全可以一边在文本编辑器里写代码，一边开一个交互式命令窗口，在写代码的过程中，把部分代码粘到命令行去验证，事半功倍！前提是得有个27’的超大显示器！ Python代码运行助手Python代码运行助手可以让你在线输入Python代码，然后通过本机运行的一个Python脚本来执行代码。原理如下： 在网页输入代码; 点击Run按钮，代码被发送到本机正在运行的Python代码运行助手； Python代码运行助手将代码保存为临时文件，然后调用Python解释器执行代码； 网页显示代码执行结果。 下载地址：learning.py 运行： 在存放learning.py的目录下运行命令： 1C:\Users\michael\Downloads&gt; python3 learning.py 如果看到Ready for Python code on port 39093...表示运行成功，不要关闭命令行窗口，最小化放到后台运行即可。 输入和输出输出用print()在括号中加上字符串，就可以向屏幕上输出指定的文字。用print()在括号中加上字符串，就可以向屏幕上输出指定的文字。print()遇到逗号“,”会输出一个空格： 12&gt;&gt;&gt; print('The quick brown fox', 'jumps over', 'the lazy dog')The quick brown fox jumps over the lazy dog print()也可以打印整数，或者计算结果： 12&gt;&gt;&gt; print('100 + 200 =', 100 + 200)100 + 200 = 300 输入Python提供了一个input()，可以让用户输入字符串，并存放到一个变量里。比如输入用户的名字：输入和输出 阅读: 920559 输出用print()在括号中加上字符串，就可以向屏幕上输出指定的文字。比如输出&#39;hello, world&#39;，用代码实现如下： 1&gt;&gt;&gt; print(&apos;hello, world&apos;) print()函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出： 12&gt;&gt;&gt; print(&apos;The quick brown fox&apos;, &apos;jumps over&apos;, &apos;the lazy dog&apos;)The quick brown fox jumps over the lazy dog print()会依次打印每个字符串，遇到逗号“,”会输出一个空格，因此，输出的字符串是这样拼起来的： print()也可以打印整数，或者计算结果： 1234&gt;&gt;&gt; print(300)300&gt;&gt;&gt; print(100 + 200)300 因此，我们可以把计算100 + 200的结果打印得更漂亮一点： 12&gt;&gt;&gt; print(&apos;100 + 200 =&apos;, 100 + 200)100 + 200 = 300 注意，对于100 + 200，Python解释器自动计算出结果300，但是，&#39;100 + 200 =&#39;是字符串而非数学公式，Python把它视为字符串，请自行解释上述打印结果。 输入现在，你已经可以用print()输出你想要的结果了。但是，如果要让用户从电脑输入一些字符怎么办？Python提供了一个input()，可以让用户输入字符串，并存放到一个变量里。比如输入用户的名字： 12&gt;&gt;&gt; name = input()Michael 输入完成后，不会有任何提示，Python交互式命令行又回到&gt;&gt;&gt;状态了。那我们刚才输入的内容到哪去了？答案是存放到name变量里了。可以直接输入name查看变量内容： 12&gt;&gt;&gt; name'Michael' 要打印出name变量的内容，除了直接写name然后按回车外，还可以用print()函数： 12&gt;&gt;&gt; print(name)Michael input()可以让你显示一个字符串来提示用户，于是我们把代码改成： 12name = input('please enter your name: ')print('hello,', name) 运行结果： 123C:\Workspace&gt; python hello.pyplease enter your name: Michaelhello, Michael 小结 Python 是解释型语言 pycharm是一个IDE，类似Python自带的IDLE、Spyder、Sublime等等，它们都只是编辑器，是用来编写代码的，而CPython、IPython、PyPy等，这些是解释器，是用来执行Python代码的 输入是Input，输出是Output，因此，我们把输入输出统称为Input/Output，或者简写为IO。 input()和print()是在命令行下面最基本的输入和输出，但是，用户也可以通过其他更高级的图形界面完成输入和输出，比如，在网页上的一个文本框输入自己的名字，点击“确定”后在网页上看到输出信息。 input()可以让你显示一个字符串来提示用户，name = input(‘please enter your name: ‘) print()`会依次打印每个字符串，遇到逗号“,”会输出一个空格，print(‘hello,’, name) Python基础]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git 原理详解及实用指南]]></title>
    <url>%2F2017%2F12%2F18%2FJuejin-Git-renwuxian%2F</url>
    <content type="text"><![CDATA[1. 什么是版本控制系统？版本控制：最基本功能版本控制系统（Version Control System - VCS）最基本的功能是版本控制。所谓版本控制，就是在文件的修改历程中保留修改历史，让你可以方便地撤销之前对文件的修改操作。如 「撤销（Undo）」功能。当你按下「撤销」的时候，它就帮你把内容回退到上一个状态；同理，按一次是会退到上一个版本，按两次就是回退到上上一个版本。 写程序的时候同样也难免会遇到「写错」的情况，所以程序的 VCS，当然也会需要版本控制功能，这样当你发现「昨天有一行代码写错了」，你就不用凭着记忆把那段代码背出来，而只需要在 VCS 中选择撤回到昨天的那个版本。 主动提交：程序代码和普通文本的区别程序代码的修改的生命周期非常长。一次代码的修改，在几天后、几个月后、几年后都有可能需要被翻出来。如果依然采用「每次改动自动保存」的形式来保留修改历史，将会导致改动历史非常频繁和无章可循，这样，历史代码的查找、阅读和回退就会很困难了。所以，和文本编辑器的撤销功能不同，VCS 保存修改历史，使用的是主动提交改动的机制。 在你写了一段完整的代码（例如修复了一个 bug）之后，使用 commit 命令把改动和对改动的描述信息提交，这次改动就被记录到版本历史中了。之后如果你希望回退到这个版本，就可以从 VCS 的历史日志中方便地找到它。 多人合作的同步需求：中央仓库代码可以一个人写，但更多的时候会是多个人共同开发。那么自然地，就需要有一个中央仓库作为代码的存储中心：所有人的改动都会上传到这里，所有人都能也都能看到和下载到别人上传的改动。 这样，解决了同步的需求，多个人在不同的机器上开发同一个程序就成了可能。 版本控制、主动提交、中央仓库这三个要素，共同构成了版本控制系统（VCS）的核心：开发团队中的每个人向中央仓库主动提交自己的改动和同步别人的改动，并在需要的时候查看和操作历史版本，这就是版本控制系统. 中央式版本控制系统最初的版本控制系统，是中央式版本控制系统（Centralized VCS），也就是前面我讲的这种。Git 是分布式的版本控制系统（Distributed VCS），现在先说一下中央式版本控制系统的工作模型。 工作模型： 假设你在一个三人团队，你们计划开发一个软件或者系统，并决定使用中央式 VCS 来管理代码。于是： 作为项目的主工程师，你独自一人花两天时间搭建了项目的框架； 然后，你在公司的服务器（这个服务器可以是公司内的设备，也可以是你们买的云服务）上创建了一个中央仓库，并把你的代码提交到了中央仓库上； 你的两个队友从中央仓库取到了你的初始代码，从此刻开始，你们三人开始并行开发； 在之后的开发过程中，你们三人为了工作方便，总是每人独立负责开发一个功能，在这个功能开发完成后，这个人就把他的这些新代码提交到中央仓库； 每次当有人把代码提交到中央仓库的时候，另外两个人就可以选择把这些代码同步到自己的机器上，保持自己的本地代码总是最新的。 而对于团队中的每个人来说，就会更简单一点： 第一次加入团队时，把中央仓库的代码取下来； 写完的新功能提交到中央仓库； 同事提交到中央仓库的新代码，及时同步下来。 这样，一个三人的团队就成功做到了各自在自己的电脑上开发同一个项目，并且互不影响，就好像你们三个人是在同一台电脑上操作一样。 这就是中央式 VCS 最基本的工作模型。当然，实际的开发工作并没有简单到这种程度，因为你时常会需要处理代码冲突、查看版本历史、回退代码版本等；另外，Git 属于分布式 VCS，它的概念也比中央式 VCS 要复杂一些。 中央式 VCS 的中央仓库有两个主要功能：保存版本历史、同步团队代码。 2. 什么是分布式版本控制系统（DVCS）？分布式 VCS （Distributed VCS / DVCS）和中央式的区别在于，分布式 VCS 除了中央仓库之外，还有本地仓库：团队中每一个成员的机器上都有一份本地仓库，这个仓库里包含了所有的版本历史，或者换句话说，每个人在自己的机器上就可以提交代码、查看历史，而无需联网和中央仓库交互——当然，取而代之的，你需要和本地仓库交互。 中央式 VCS 的中央仓库有两个主要功能：保存版本历史、同步团队代码。而在分布式 VCS 中，保存版本历史的工作转交到了每个团队成员的本地仓库中，中央仓库就只剩下了同步团队代码这一个主要任务。它的中央仓库依然也保存了历史版本，但这份历史版本更多的是作为团队间的同步中转站。 工作模型： 依然以三人团队为例，分布式 VCS 的工作模型大致是这样： 首先，你作为主工程师，独立搭建了项目架构，并把这些代码提交到了本地仓库； 然后，你在服务器上创建了一个中央仓库，并把 1 中的提交从本地仓库推送到了服务器的中央仓库； 其他同事把中央仓库的所有内容克隆到本地，拥有了各自的本地仓库，从此刻开始，你们三人开始并行开发； 在之后的开发过程中，你们三人总是每人独立负责开发一个功能，在这个功能开发过程中，一个人会把它的每一步改动提交到本地仓库。注意：由于本地提交无需立即上传到中央仓库，所以每一步提交不必是一个完整功能，而可以是功能中的一个步骤或块。 在一个人把某个功能开发完成之后，他就可以把这个功能相关的所有提交从本地仓库推送到中央仓库； 每次当有人把新的提交推送到中央仓库的时候，另外两个人就可以选择把这些提交同步到自己的机器上，并把它们和自己的本地代码合并。 可以看出，这个工作模型和上一节讲的「中央式 VCS 的工作模型」很相似，只是把代码的提交和上传过程拆开了。 另外，和上节讲的中央式 VCS 工作模型一样，这个也只是分布式 VCS 的一个最基本的工作模型，实际的开发工作会比这个麻烦和复杂。 3. 快速上手 Git点击右上角的「New Repository」来新建远程仓库； 进入仓库设置页面填写信息：仓库名会被 GitHub 设置为你的仓库的根目录的名称，.gitignore 是 Git 仓库中的一个特殊的文本文件，它里面记录了你不希望提交到仓库的目录和文件的名称或类型，例如你的 /build 目录，然后完成远程仓库的创建。 点击右边的「Clone or download」，然后把仓库的 clone 地址复制到剪贴板。接下来就可以把远程仓库取下来了。取的方式很简单：在 Terminal 或 cmd 中切换到你希望放置项目的目录中，然后输入： 1git clone 你刚复制的地址 Git 就会把你的远程仓库 clone 到本地。你会看到你的当前目录下多了一个新的子目录，它的名字和刚才新建的 GitHub 仓库名一致：进入这个目录，你会发现这里除了你刚才添加的 LICENSE 和 .gitignore 文件外，还有一个叫做 .git 的隐藏目录。这个 .git 目录，就是你的本地仓库（Local Repository），你的所有版本信息都会存在这里。而 .git 所在的这个根目录，称为 Git 的工作目录（Working Directory），它保存了你当前从仓库中签出（checkout）的内容。现在你在项目的目录下输入：]]></content>
  </entry>
  <entry>
    <title><![CDATA[李旭口语]]></title>
    <url>%2F2017%2F11%2F26%2FPronunciation-of-Miss-Li%2F</url>
    <content type="text"><![CDATA[音标元音 = 韵母，口型固定，气流喷出 辅音 = 声母，受嘴唇、舌头、牙齿结合 发音就是 单独的元音 或 辅音 + 元音 元音分为：前元音、中元音、后元音。（单元音，双元音只是分类方法不同，意义一样） 前元音【 i 】：很短促的叫人：衣（诶） ship shit me i、y结尾 发这个【 i 】音，pig,many。y在词首部读【j】 【 i :】：等于【i】到【j】（夜）滑动的音（一夜） sheep sheet ee、ea 发这个【 i :】音 【 e 】：小口型的林黛玉式的 哎 bed best said。e 、ea、ai 发这个音 【 æ 】：大口型的 ╮(╯▽╰)╭哎 bad apple ，a 发这个音 美式发音和英式发言连读规则重音语调场景考试口语音乐]]></content>
  </entry>
  <entry>
    <title><![CDATA[Teacher Li's 大学英语六级听力之“连读”]]></title>
    <url>%2F2017%2F11%2F17%2FTeacher-Li-s-%E5%A4%A7%E5%AD%A6%E8%8B%B1%E8%AF%AD%E5%85%AD%E7%BA%A7%E5%90%AC%E5%8A%9B%E4%B9%8B%E2%80%9C%E8%BF%9E%E8%AF%BB%E2%80%9D%2F</url>
    <content type="text"><![CDATA[链接：视频：大学英语六级听力之“连读” 辅音 + 辅音失去爆破：前面一个音节以辅音结尾，通常是 p 、 k 、 t、b 、g 、d，且后面一个音节以不同的辅音开头，在一起时，要失爆。第一个辅音只做口型，不读出声音。听力中有停顿，说明可能是失去爆破。 blackboard breakfast sit down hot day good teacher bad boy could be put it down t 和 d 是两个辅音， put it down（注意，t 后面跟一个元音时，u 不发 ʌ 音，发 ə 音） 击穿针对于 h，它放词首，且不是重读音节，则不做口型，不出气，即不发音。飘出来的 「和」，除非你想强调，要读出来。 i like her in his car ask him 叠合前面结尾的辅音和后面开头的辅音一样，且不是重读音节，就是叠合现象，这时，只读其中的一个发音。除非你想强调，要读出来。 a bad dog good day take care ( 注意这个发音和 take air 一样) i like candy a tame monkey book case a big game 辅音 + 元音 （最常见）前一个音节的结尾辅音，跟后一个音节的开头元音，连在一起拼读。 knock at look into look out take up 但是还有四个，前面结尾的要发音，后面的还要连读在一起： [ r ] + 元音[ r ] 发言结尾，且后面是元音时，r （儿化音）要读出来，还要再跟后面的元音连读 Your answer are excellent. 当主语和系动词都要连时，连主语。 I have read your article. far away for instance a number of 【 l 】+ 元音[ l ] 发二分之一的了音，以下单词发这个音：l、ll、le [ l ] 发言结尾，且后面是元音时，要跟后面的元音连读。 couple of double of LED Li 读成 Llai 的音 LEE L double e i will ask him later 007: double O seven 【 n 】+ 元音[ n ] 发言结尾，且后面是元音时，要跟后面的元音连读。 an apple 必然连读，否则是错的，除非特殊强调。 an answer an article in a hotel an old lady pen and paper in an instant （发生两次连读，第一次是n + a,第二次是 n+i） open an account (发生两次连读，第一次是n + a,第二次是 n+a） 1980： nineteen eigthy 【 t 】+ 元音[ t ] + 元音，则变成介于 t 与 d 之间的弹射音 city 美国人发生音变有3个规则： [ t ] 音在音节的中间 [ t ] 音前面是一个元音 [ t ] 音不是重读音 get in get out so it is get in get it out of here put it off take it easy not at all keep it up not alone 元音 + 元音加半元音【w】当前面单词以 [əu]、[ɑu]、[u]、[u:]结尾，后面单词以元音开头，在一起连读时，要加半元音【w】,感觉像【温】音 just do it go on no end doing going who else too often you are 加半元音【j】当前面单词以 [ei]、[ɑi]、[ɔi]、[i]结尾，后面单词以元音开头，在一起连读时，要加半元音【j】,感觉像【耶】音 be on time say it see it she is try it may i i am weigh i*t u*p (两次连读，第一次是加 【j】，第二次是t变d，连读u) 连读音变 【t】 +【j】=【ʧ】 why don’t you come here? i want you nice to meet you 【d】+【j】=【ʤ】 would you please… could you please… how did you get there.. 【s】+【j】=【ʃ】 i miss you unless you know how to get there]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 使用]]></title>
    <url>%2F2017%2F11%2F09%2FAndroid-Studio-%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[快捷键上下移动代码： OXS/Win/Linux : Alt + Shift + Up/Down 删除行： OSX : Cmd + Delete Win/Linux : Ctrl + Y 快捷向下复制行： OSX : Cmd + D Win/Linux : Ctrl + D 快捷覆写方法： OSX : Ctrl + O Win/Linux : 注释代码 ( // )： OSX : Cmd + / Win/Linux : 注释代码 ( /**/ )： OSX : Cmd + Alt + / Win/Linux : 格式化代码： OSX : Cmd + Alt + L Win/Linux : 快捷最近打开： OSX : Cmd + E Win/Linux : Ctrl + E 清除无效 import ： OSX : Alt + Control + O Win/Linux:Alt + Control + O 代码补全 : OSX : Cmd + Shift + Enter Win/Linux : Ctrl + Shift + Enter 提示错误解决方案 : OSX : Alt + Enter Win/Linux : Alt + Enter 提示参数类型 : OSX : Cmd + P Win/Linux : Ctrl + P 查找+替换 : OSX : Cmd + R Win/Linux : Ctrl + R 查找 : OSX : Cmd + F Win/Linux : Ctrl + F 类注释自动生成说明类注释： 添加以下内容： 1234567/** * 项目名： $&#123;PROJECT_NAME&#125; * 包名： $&#123;PACKAGE_NAME&#125; * 文件名： $&#123;NAME&#125; * Created by $&#123;USER&#125; on $&#123;DATE&#125;. * 描述： TODO */]]></content>
      <categories>
        <category>Android</category>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[英文词串 - 英语流利说]]></title>
    <url>%2F2017%2F11%2F06%2FEnglish-word-phrase%2F</url>
    <content type="text"><![CDATA[英语六级口语考试自我介绍 语音一定要准（第一印象很重要） 语速不要过快或过慢（20秒，40-50词为最佳） 适当使用连续以增加语言的流畅度，有快有慢 不要面面俱到，找一两个方向，展开一两句即可 六级考生还要根据自己的自我介绍准备可能考官追问的问题 名字问题可以不说 自我介绍部分思考方向： 年龄，专业 大学介绍 i am from … university,she is a famous beatiful school name love in here. 性格特点 家庭背景 业余爱好 家乡景点 百度搜 地名+英文介绍可以参考 自我介绍注意停顿和连读就更好一些，每一个发言一定要准确。 先写100词的自我介绍，再按照连读规则，把施爆的地方划掉，连读音变加上，语速增加、减缓画出来，读音注意的地方画上，背下来，录下来，听哪里不好再改 老师问问题，基于你自己所说的东西问，回答的时候，挑自己会说的回答，不一定是实话。 图片 so, what do you say? 巴拉巴拉说了一堆后，询问对方的意见。]]></content>
      <categories>
        <category>英语</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[带领新手快速开发 Android App]]></title>
    <url>%2F2017%2F11%2F02%2Fimooc-Quick-develop-Android-App%2F</url>
    <content type="text"><![CDATA[借助流行的第三方 SDK 及框架，开发“生活小助手 App ”。 用户管理登录注册忘记密码语音机器人聊天微信精选文章物流及电话号码归属地查询美女相册个性化二维码扫描与生成定位与查看地图]]></content>
      <categories>
        <category>慕课网</category>
        <category>带领新手快速开发 Android App</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程小白的第一本 Python 入门书]]></title>
    <url>%2F2017%2F11%2F02%2FFirst-Python%2F</url>
    <content type="text"></content>
      <categories>
        <category>Python</category>
        <category>Python 入门</category>
      </categories>
      <tags>
        <tag>Python 入门</tag>
        <tag>编程小白的第一本 Python 入门书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Head First Java]]></title>
    <url>%2F2017%2F11%2F02%2FHead-First-Java%2F</url>
    <content type="text"><![CDATA[Java 的垃圾回收p40 对象的创建内存示意图 对象的引用变量有多大？ 除非你和 JVM 开发团队有交情，不然不知道，在同一个 JVM 中，引用变量的大小是一样的。若你是要讨论内存分配的问题，你要关心的应该是需要建立多少个对象和引用，以及对象的实际大小。 Head First Java 基础知识附录取得命令行用户输入字符串的方法1234567891011121314151617181920212223242526import java.io.BufferedReader;import java.io.InputStreamReader;public class Helper &#123; public static void main(String args[]) &#123; Helper helper = new Helper(); System.out.println(helper.getUserInput("Please enter a number: ")); &#125; public String getUserInput(String prompt) &#123; String inputLine = null; System.out.println(prompt + " "); try &#123; BufferedReader is = new BufferedReader(new InputStreamReader(System.in)); inputLine = is.readLine(); if (inputLine.length() == 0) &#123; return null; &#125; &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125; return inputLine; &#125;&#125; 其中 123if (inputLine.length() == 0) &#123; return null;&#125; 这是做”用户什么都没输入的处理”，不加这句，什么也不会输出 另外 12String string = "dsfs";System.out.println(string.length()); String 类型的变量也有 length() 方法，不止数组有。 Returns: the length of the sequence of characters represented by this object. 如果 string 是 null ，则string.length() 会报空指向异常。 foreach 与 for1for(int cell : locationCells ) &#123;···&#125; 编译器会这么做： 创建名为 cell 的 int 变量 将 locationCells 的第一个元素值赋给 cell 执行循环内容 赋值给下一个元素 cell 重复执行至所有的元素被运行完毕为止 locationCells 的集合必须是数组或其他集合的引用。而且 int 这个位置的类型要与 locationCells 兼容。 注意：可以看出，在 foreach 的执行过程中，采用了数组数据赋值，所以，cell 值的改变并不会影响 原来数组里那个位置的元素值。如果需要改变原来的数组，如排序，就要用之前的 for 循环。涉及到「赋值」的操作，都不能用foreach. 原始的 for 循环： 12for(int i = 0 ; i&lt;0 ; i++ ) &#123;···&#125; 1 2 3 4 运行顺序： 1 -&gt; 2 ：1. true -&gt; 4 -&gt; 3 -&gt; 2 : 1. true -&gt; 4 -&gt; 3 -&gt; 2 :1. true -&gt; 4 -&gt; 3 -&gt; 2 : ​ 2.false -&gt; end 2.false -&gt; end 2.false -&gt; end for 与 while 比较： 不知道执行次数用 while，知道执行次数用 for更清晰。 String 转 int1int num = Integer.parseInt("3"); Integer 的 parseInt() 方法，能将 String 解析。 这个方法仅对代表数字的 String 起作用，除此之外，程序就会崩溃，抛出异常。 Java 传参数是值拷贝参数的值是由实参拷贝而来的，参数的改变不会影响到原先的值，但要是传递的是引用变量，那么引用变量的远程控制（字节组合代表取得远程控制对象的方法）也会拷贝过来，那么参数的改变就会影响原来的值。 变量的比较 == ：用来比较两个变量的字节组合是否相等，对于 primitive 主数据类型来说，字节组合就是实际的变量值，对于引用来说，字节组合是取得对象的方法（指针），== 就是判断两个引用是否指向同一个对象。 equals（）：用来判断两个对象是否在意义上相等。即对象的相等性。 实例变量 VS 局部变量实例变量声明在类内，未初始化时，有默认值。integer 和 char 类型默认为 0 ，boolean 默认为 false，对象引用默认为 null。null 表示没有操作对象的远程控制，他是个引用而不是对象。 局部变量声明在方法内，未初始化时，没有默认值。方法的参数也是局部变量。如果局部变量未初始化就使用，编译器会报错。 random() 方法产生随机数产生 [n,m] 之间的随机数： 1int x = (int)( Math.random() * (m-n+1) + n ); Math.random() 方法返回介于 0 与 1 之间的 double 值，然后将此值乘以数组元素个数，再取整数值。 random() Returns: a pseudorandom double greater than or equal to 0.0 and less than 1.0. 大于等于 0 ，小于 1. 产生 [0,n] 之间的随机数 1int x = (int)( Math,random() * (n + 1 )); 写伪代码参考Chapter 5 Page 100 类、方法、变量的命名规则 必须以字母，下划线，或 $ 开头 除第一个字符外，后面可以用数字 避开 Java 的关键字 变量的两种口味 香辣的对象引用：保存的是对象的引用，以字节来表示取得对象的方法（遥控器）。 清凉的 primitive 主数据类型：保存的是变量本身，以字节代表实际的变量值，有 boolean、char、byte、short、int、long、float、double 8种。 注意，数组不论被声明来承载的是 primitive 主数据类型，或对象引用，数组永远是对象。 Java 是个强类型语言类型不许乱用，可以被隐含的放大（小值放大容器），或明确的缩小（强制类型转换） Java APIJava 中内置了数百个类，被称为 API，其实他就是个函数库，你可以把他当做自己写的来用。ArrayList 类就是 Java 函数库里的一个。 使用函数库时，要在使用到该类时写出完整的类名，或是在源文件开头 import 进它的包名，除非是来源于 java.lang 这个包中，java.lang 是个预先被引用的包，是个经常会用到的基础包。 类用包来组织，但 import 绝不是 C 里的 include，import 只是会帮你省下每个类前面的包名称，程序并不会因为 import 而变大或变慢。 以 javax 开头的包以前曾经是扩展，后来才取得了标准的名份。 ArrayList 类ArrayList 类是 java.util 工具类的代表。 123ArrayList&lt;Egg&gt; myList = new ArrayList&lt;Egg&gt;();//虽然 ArrayList 里返回的是 Object，但编译器会帮你做类型转换，转成 Egg 类型 新的 ArrayList 对象虽然和数组一样会创建在堆上，但他们有本质的不同 ArrayList 数组 使用 ArrayList，只是运用 ArrayList 类型的对象，跟使用其他对象一样，用 “.” 运算符调用它的方法。 使用数组，要用特殊的数组语法 []，无法调用它的方法，最多只能存取它的 length 实例变量。 ArrayList 会自动管理大小 数组要定义它的大小，且大小不能改变 ArrayList 只能携带对象，不能装 primitive 主数据类型，但是非要装的话，编译器会自动将 primitive 包装成 Object ，再放入 ArrayList 中 在装载 primitive 主数据类型时，数组比 ArrayList 快 是类型参数，代表是 String 的集合 短运算的使用可以用这种方式避免调用内容为 null 的指针变量： 123if( refVar ! = null &amp;&amp; refVar.isValidType())&#123; //执行有效变量的工作&#125; Java 基础知识附录赋值数组Java 中有复制数组的方法，C++ 中没有 123Integer[] arr1 = SortTestHelper.generateRandomArray(n, 0, n);Integer[] arr2 = Arrays.copyOf(arr1, arr1.length); assert一、概述 在 C 和 C++ 语言中都有 assert 关键，表示断言。 在 Java 中，同样也有 assert 关键字，表示断言，用法和含义都差不多。 二、语法 在 Java 中，assert 关键字是从 JAVA SE 1.4 引入的，为了避免和老版本的 Java 代码中使用了 assert 关键字导致错误，Java 在执行的时候默认是不启动断言检查的（这个时候，所有的断言语句都将忽略！），如果要开启断言检查，则需要用开关 -enableassertions 或 -ea 来开启。 assert关键字语法很简单，有两种用法： 1assert &lt;boolean表达式&gt; 如果 为 true，则程序继续执行。 如果为 false，则程序抛出 AssertionError，并终止执行。 1assert &lt;boolean表达式&gt; : &lt;错误信息表达式&gt; 如果 为 true，则程序继续执行。 如果为 false，则程序抛出 java.lang.AssertionError，并输入 &lt;错误信息表达式&gt;。 三、应用实例 下面给出一个例子，通过例子说明其用法： 123456789101112131415161718192021public class AssertFoo &#123; public static void main(String args[]) &#123; //断言1结果为true，则继续往下执行 assert true; System.out.println("断言1没有问题，Go！"); System.out.println("\n-----------------\n"); //断言2结果为false，程序终止 assert false : "断言失败，此表达式的信息将会在抛出异常的时候输出！"; System.out.println("断言2没有问题，Go！"); &#125;&#125; 保存代码到 C:\AssertFoo.java，然后按照下面的方式执行，查看控制台输出结果： 1、编译程序： C:>javac AssertFoo.java 2、默认执行程序，没有开启-ea开关： C:>java AssertFoo 执行结果： 123断言1没有问题，Go！ -----------------断言2没有问题，Go！ 3、开启-ea开关，执行程序： C:>java -ea AssertFoo 执行结果： 12345断言1没有问题，Go！-----------------Exception in thread "main" java.lang.AssertionError: 断言失败，此表达式的信息将会在抛出异常的时候输出！ at AssertFoo.main(AssertFoo.java:10) 四、陷阱 assert 关键字用法简单，但是使用 assert 往往会让你陷入越来越深的陷阱中。应避免使用。笔者经过研究，总结了以下原因： 1、assert 关键字需要在运行时候显式开启才能生效，否则你的断言就没有任何意义。而现在主流的 Java IDE 工具默认都没有开启 -ea 断言检查功能。这就意味着你如果使用 IDE 工具编码，调试运行时候会有一定的麻烦。并且，对于 Java Web 应用，程序代码都是部署在容器里面，你没法直接去控制程序的运行，如果一定要开启 -ea 的开关，则需要更改 Web 容器的运行配置参数。这对程序的移植和部署都带来很大的不便。 2、用 assert 代替 if 是陷阱之二。assert 的判断和if语句差不多，但两者的作用有着本质的区别：assert 关键字本意上是为测试调试程序时使用的，但如果不小心用 assert 来控制了程序的业务流程，那在测试调试结束后去掉assert 关键字就意味着修改了程序的正常的逻辑。 3、assert 断言失败将面临程序的退出。这在一个生产环境下的应用是绝不能容忍的。一般都是通过异常处理来解决程序中潜在的错误。但是使用断言就很危险，一旦失败系统就挂了。 五、对assert的思考 assert 既然是为了调试测试程序用，不在正式生产环境下用，那应该考虑更好的测试 JUint 来代替其做用，JUint 相对 assert 关键的所提供的功能是有过之而无不及。当然完全可以通过 IDE debug 来进行调试测试。在此看来，assert 的前途一片昏暗。 因此，应当避免在 Java 中使用 assert 关键字，除非哪一天 Java 默认支持开启 -ea 的开关，这时候可以考虑。对比一下，assert 能给你带来多少好处，多少麻烦，这是我们选择是否使用的的原则。 评论： assert 有很大的用处首先可以用在单元测试代码中。junit 侵入性是很强的，如果整个工程大量的代码都使用了 junit，就难以去掉或者是选择另外一个框架。如果单元测试代码很多，并且想复用这些单元测试案例，应该选择 assert 而不是 junit，便于使用别的单元测试框架，比如 TestNG。同理正式的功能代码根本就不应该出现 Junit，应该使用 assert. assert 主要适合在基类，框架类，接口类，核心代码类，工具类中。换言之，当你的代码的调用者是另外一个程序员写得业务代码，或者是另外一个子系统时，就很有必要使用它。比如你做了一个快速排序的算法 123456789101112131415public static List&lt;Integer&gt; quickSort(List&lt;Integer&gt; list)&#123; assert list != null; // 申请临时空间 //开始排序 for(int i : list)&#123; // &#125;&#125; 这种情况下，如果不检查传入参数的正确性，会抛出一个莫名其妙的空指针错误。你的调用者可能并不清楚你代码的细节，在一个系统的深处调试一个空指针错误是很浪费时间的。就应该直接明确的告诉你的调用者是传入的参数有问题。否则他会怀疑你的代码有 BUG。使用 assert 可以避免两个程序员之间互相指责对方写的代码有问题。 assert 适用那些你知道具体是什么错误，你和你的调用者已经约定应该由你的调用者去排除或检查的错误。你通过一个断言告诉你的调用者。assert 不适用那些外部系统造成的错误，比如用户输入数据的错误，某个外部文件格式错误。这些错误不是你的调用者而是用户造成的，甚至于不属于异常，因为出现输入错误和文件格式错误是经常的，这些错误应该由业务代码去检查。 assert 比较适合于被频繁调用的 基类，框架代码，工具类，核心代码，接口代码中，这正是它在运行时被去掉的原因。测试代码应该在测试阶段开启 -ea 参数，便于对系统深处的核心代码做仔细的测试。 Java 较少使用 assert 的原因是 Java 有很完整的OO体系，强制类型转换出现得较少，所以不需要类似 c 那样需要频繁的检查指针的类型是否正确，指针是否为空。同时 Java 也很少直接管理内存或缓冲区，所以不需要频繁的检查传入的缓冲区是否为空或者是已经越界。 但使用好 assert 有助于提高框架代码的正确性和减少框架代码的使用者的调试时间。]]></content>
      <categories>
        <category>Java</category>
        <category>Head First Java</category>
      </categories>
      <tags>
        <tag>Head First Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 开发中遇到的 bug]]></title>
    <url>%2F2017%2F10%2F30%2FAndroid-developing-bug%2F</url>
    <content type="text"><![CDATA[NoSuchMethodError: No static method wrapSharedElementTransition上汽大通项目遇到火山级 bug，点击 123456789101112131415java.lang.NoSuchMethodError: No static method wrapSharedElementTransition(Ljava/lang/Object;)Ljava/lang/Object; in class Landroid/support/v4/app/FragmentTransitionCompat21; or its super classes (declaration of 'android.support.v4.app.FragmentTransitionCompat21' appears in /data/app/com.example.aidrive2-1/base.apk) at android.support.v4.app.BackStackRecord.getSharedElementTransition(BackStackRecord.java:1156) at android.support.v4.app.BackStackRecord.configureTransitions(BackStackRecord.java:1222) at android.support.v4.app.BackStackRecord.beginTransition(BackStackRecord.java:1112) at android.support.v4.app.BackStackRecord.run(BackStackRecord.java:721) at android.support.v4.app.FragmentManagerImpl.execPendingActions(FragmentManager.java:1677) at android.support.v4.app.FragmentManagerImpl$1.run(FragmentManager.java:536) at android.os.Handler.handleCallback(Handler.java:815) at android.os.Handler.dispatchMessage(Handler.java:104) at android.os.Looper.loop(Looper.java:194) at android.app.ActivityThread.main(ActivityThread.java:5556) at java.lang.reflect.Method.invoke(Native Method) at java.lang.reflect.Method.invoke(Method.java:372) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:967) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:762) app:dexDebug：/Library/Java/JavaVirtualMachines/jdk1.8.0_92.jdk/Contents/Home/bin/java’’ finished with non-zero exit value 21Error:Execution failed for task ':app:dexDebug'. &gt; com.android.ide.common.process.ProcessException: org.gradle.process.internal.ExecException: Process 'command '/Library/Java/JavaVirtualMachines/jdk1.8.0_92.jdk/Contents/Home/bin/java'' finished with non-zero exit value 2 是 app/build.gradle 依赖包的版本问题， 参考： https://stackoverflow.com/questions/30001051/appdexdebug-execexception-finished-with-non-zero-exit-value-2 http://www.cnblogs.com/creasylai19/p/5027757.html 状态：未解决]]></content>
      <categories>
        <category>Android</category>
        <category>Android Developing Bug</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文相关]]></title>
    <url>%2F2017%2F10%2F29%2FMyPaper%2F</url>
    <content type="text"><![CDATA[彩虹无线发布“立方体计划”：前装车联网大数据的两种玩法]]></content>
      <categories>
        <category>毕设论文</category>
        <category>材料收集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hencoder 朱凯的高级教程]]></title>
    <url>%2F2017%2F10%2F29%2Fhencoder%2F</url>
    <content type="text"><![CDATA[给高级 Android 工程师的进阶手册第一讲，讲 UI 一般使用 自带控件 + 开源库，可以实现大部分 UI 效果。但一些新颖的效果，要自定义 View 来实现。 自定义 View 的 3 个关键点： 布局 绘制 触摸反馈 听课： 录播的视频 + 文字 + 练习项目。视频负责打通概念，文字负责阐述细节，练习项目负责最后一公里，让你从「我懂了」变成「我会了」 自定义 View 1-1 绘制基础绘制就是控件内容的显示。 自定义绘制就是你来接管绘制的过程，操作绘制细节。使用系统 API 是绘制不出柱状图和饼形图的，即使绘制出来，性能也不佳，这时要使用自定义绘制 View。]]></content>
      <categories>
        <category>Android</category>
        <category>Hencoder 朱凯的高级教程</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>朱凯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[颠覆你的传统英语学习 - 杨萃先]]></title>
    <url>%2F2017%2F10%2F27%2FPronunciation-of-Miss-Yang%2F</url>
    <content type="text"><![CDATA[视频地址：撕掉单词语法书，颠覆你的传统英语学习 第 0 课 - 找对方法 本节课作业： 下载 app，找到和自己生活、工作密切相关的部分听，听不懂的，立马查，可以看字幕，怎么能听懂怎么听。听满 100 小时。 生活中，环境中，只要是不会的生词，立马查。至少找到五个不会的。 关注老师个人公众号 “途正英语”。看老师的文章和小故事。 找志同道合的小伙伴讨论，说英语。 第 1 课 - 背单词大法 记单词： 作业：]]></content>
      <categories>
        <category>英语</category>
        <category>英语口语</category>
      </categories>
      <tags>
        <tag>英语口语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纪老师英语音标课程]]></title>
    <url>%2F2017%2F10%2F26%2FPronunciation-of-Miss-Ji%2F</url>
    <content type="text"><![CDATA[视频地址纪老师英语 - 音标篇 纪老师 英语音标口诀记忆法 – 音标一 5 个元音 + 1 个辅音 纪老师 英语音标口诀记忆法 – 音标二 5 个辅音的发音方法 纪老师 英语音标口诀记忆法 – 音标三 8 个双元音的发音方法 纪老师 英语音标口诀记忆法 – 音标四 12 个辅音的发音方法 纪老师 英语音标口诀记忆法 – 音标五 p、k、t 清音浊化 纪老师 英语音标口诀记忆法 – 音标实战篇 英语习惯用语发音练习 1 - 6 句 纪老师 英语音标口诀记忆法 – 音标实战篇 英语习惯用语发音练习 32 句 纪老师 英语音标口诀记忆法 – 音标实战篇 英语习惯用语发音练习 71 - 79 句 纪老师 英语音标口诀记忆法 – 音标实战篇 英语习惯用语发音练习 108 - 135 句 纪老师 - 48个国际音标的记忆口诀讲义地址纪老师 - 48个国际音标的记忆口诀【讲义】 音标一元音：20 个，相当于韵母 辅音：28 个，相当于声母 第一节学习 5 个元音和 1 个辅音： 发言口诀： 音标二第二节学习 5 个辅音 f、l、m、n 的发音：一种是读汉语拼音里的flmn，另一种是读这四个英文字母发音的尾音。 后面有可以一起拼读的就发flmn的音，没有一起拼读的音就发英文字母的尾音。 r 后面有可以一起拼读的音就发 ru 音，没有一起拼读的音就发 “儿”化音。 音标三第三节学习 8 个双元音。 英语讲究「滑音」。双元音的读法是从第一个音向后面一个滑动。 新旧音标对比如下： 音标四12 个辅音的发音方法 噘嘴的 s，发汉语拼音的平舌 s 噘嘴的 z，发汉语拼音的平舌 z 噘嘴的 s，发汉语拼音中的咬舌 s 咬舌尖的 r，发汉语拼音中的 r 噘嘴的 ch，发汉语拼音的翘舌 ch 噘嘴的 zh，发汉语拼音的翘舌 zh 噘嘴的 chu，发汉语拼音的翘舌 chu 噘嘴的 zhu，发汉语拼音的翘舌 zhu chi，发音在 c 与 ch 之间，我觉得是 ci zhi，发音在 z 与 zh 之间，我觉得是 zi y，发汉语拼音 yi 不能噘嘴的 wu，上牙轻抚下唇。 音标五清音浊化问题，也叫音变。 p k t 胆子小，见到 s 须变音。 p 变 b，k 变 g，t 要变成 d。 英语音标中一共有 48 个音素，讲了 31 个特殊的音素，剩下 17 个音素与汉语拼音发音相似。 如 p，读短促的 p，k，读短促的 k。]]></content>
      <categories>
        <category>英语</category>
        <category>音标</category>
      </categories>
      <tags>
        <tag>音标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慕课网 - Android 通用框架设计与完整电商 APP 开发]]></title>
    <url>%2F2017%2F10%2F20%2Fimooc-Android-Complete-e-commerce-app%2F</url>
    <content type="text"><![CDATA[用到的 GitHub 上的库字体库JoanZapata 字体库 123//字体图标compile 'com.joanzapata.iconify:android-iconify-ionicons:2.2.2'compile 'com.joanzapata.iconify:android-iconify-fontawesome:2.2.2' Fragmentation 的库Fragmentation 的库 123//Fragment依赖compile 'me.yokeyword:fragmentation:1.1.6'compile 'me.yokeyword:fragmentation-swipeback:1.1.6' 视图注入的库 ButterKnifeButterKnife 的配置要参考ButterKnife官网，要配置 3 个地方 123//ButterKnife依赖compile 'com.jakewharton:butterknife:8.8.1'annotationProcessor 'com.jakewharton:butterknife-compiler:8.8.1' 123456789101112131415161718buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.3.3' // ButterKnife 插件 classpath 'com.jakewharton:butterknife-gradle-plugin:8.8.1' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;allprojects &#123; repositories &#123; jcenter() mavenCentral() &#125;&#125; 12apply plugin: 'com.android.library'apply plugin: 'com.jakewharton.butterknife' BufferKnife 插件的作用是生成 R2 的类，R2 类是生成视图绑定需要的唯一 ID，资源文件 R 只能在为 application 类型的 module 里使用，为 library 类型的 module 使用 BufferKnife 插件根据 R 生成 R2 的资源文件来访问视图绑定的 ID。 网络框架 retrofitretrofit 理解 RESTful 架构 RESTful API 设计最佳实践 12345//网络请求依赖 compile 'com.squareup.okio:okio:1.13.0' compile 'com.squareup.okhttp3:okhttp:3.8.1' compile 'com.squareup.retrofit2:retrofit:2.3.0' compile 'com.squareup.retrofit2:converter-scalars:2.3.0' Loading 加载库AVLoadingIndicatorView 12//loading 依赖 compile 'com.wang.avi:library:2.1.3' 启动页倒计时首次启动可以滑动Android-ConvenientBanner 全屏的广告轮播]]></content>
      <categories>
        <category>慕课网</category>
        <category>Android 通用框架设计与完整电商 APP 开发</category>
      </categories>
      <tags>
        <tag>Android 通用框架</tag>
        <tag>未解决的 bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慕课网 - 懒人必备之 Android 效率开发框架]]></title>
    <url>%2F2017%2F10%2F16%2Fimooc-Android-Framework-video-8302%2F</url>
    <content type="text"><![CDATA[什么是框架 框架是地基，地基打的好，不管业务层有多大的变化，都不会影响到正常的开发. 不用框架，理论上讲是可以的，但是开发成本就变高了，很多集成服务要自己搭建 Android 中哪些可以抽象成为框架的： 网络模块 图片缓存模块 数据库模块 UI 基础 把这些抽出来之后，只要写业务层就好了。 AndroidAnnotation AndroidAnnotation 官网 AndroidAnnotation 是基于注解的标签库，所有标签。 AS 配置androidannotationsapp/build.gradle: 123456789101112131415def AAVersion = '4.3.0'dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', &#123; exclude group: 'com.android.support', module: 'support-annotations' &#125;) compile 'com.android.support:appcompat-v7:25.3.1' compile 'com.android.support.constraint:constraint-layout:1.0.1' testCompile 'junit:junit:4.12' //androidannotations 注解标签库 annotationProcessor "org.androidannotations:androidannotations:$AAVersion" compile "org.androidannotations:androidannotations-api:$AAVersion"&#125; AndroidManifest.xml 中每个使用 androidAnnotations 的 Activity 名字后面都要添加_ 1234&lt;activity android:name=".MainActivity_" android:label="FirstTest"&gt;&lt;/activity&gt; .MainActivity 为什么要加 ？ 是 androidAnnotations ，在处理的过程中，生成的 .MainActivity_ 的 Activity。 参考了：http://www.cnblogs.com/l2rf/p/4971825.html http://blog.csdn.net/xx326664162/article/details/68490059 http://blog.csdn.net/doris_d/article/details/52634450 http://www.cnblogs.com/caobotao/p/5138935.html http://blog.csdn.net/caiwenfeng_for_23/article/details/45801151 https://github.com/androidannotations/androidannotations/blob/master/examples/gradle/build.gradle 没搞好，报错。 1234567891011121314151617181920212223242526272829Process: com.ning.helloworld, PID: 14359 java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;com.ning.helloworld/com.ning.helloworld.MainActivity_&#125;: java.lang.NullPointerException: Attempt to invoke virtual method 'void android.widget.Button.setOnClickListener(android.view.View$OnClickListener)' on a null object reference at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2470) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2532) at android.app.ActivityThread.access$800(ActivityThread.java:169) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1421) at android.os.Handler.dispatchMessage(Handler.java:111) at android.os.Looper.loop(Looper.java:194) at android.app.ActivityThread.main(ActivityThread.java:5556) at java.lang.reflect.Method.invoke(Native Method) at java.lang.reflect.Method.invoke(Method.java:372) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:967) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:762) Caused by: java.lang.NullPointerException: Attempt to invoke virtual method 'void android.widget.Button.setOnClickListener(android.view.View$OnClickListener)' on a null object reference at com.ning.helloworld.MainActivity.onCreate(MainActivity.java:67) at com.ning.helloworld.MainActivity_.onCreate(MainActivity_.java:33) at android.app.Activity.performCreate(Activity.java:5975) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1111) at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2423) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2532) at android.app.ActivityThread.access$800(ActivityThread.java:169) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1421) at android.os.Handler.dispatchMessage(Handler.java:111) at android.os.Looper.loop(Looper.java:194) at android.app.ActivityThread.main(ActivityThread.java:5556) at java.lang.reflect.Method.invoke(Native Method) at java.lang.reflect.Method.invoke(Method.java:372) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:967) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:762) annotation 的使用 看到这： 课程网址]]></content>
      <categories>
        <category>慕课网</category>
        <category>懒人必备之 Android 效率开发框架</category>
      </categories>
      <tags>
        <tag>未解决的 bug</tag>
        <tag>Android 框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 第一行代码]]></title>
    <url>%2F2017%2F10%2F10%2FAndroid-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Chapter 1 入门Android 各版本对应的 API 版本号 系统代号 API 4.0.3 - 4.0.4 Ice Cream Sandwich 15 4.1.x 4.2.x 4.3 Jelly Bean 16 17 18 4.4 KitKat 19 5.0 5.1 Lollipop 21 22 6.0 Marshmallow 23 7.0 7.1 Nougat 24 25 8.0 Oreo 26 Android 程序的项目结构 gradle 下包含了 gradle wrapper 的配置文件。 gradle.properties 是全局的 gradle 配置文件。这里配置的属性将会影响到项目中所有的 gradle 编译脚本。 app 是开发的主要工作目录。 其他都是些 AS 自动生成的文件，不需要修改。 .gitignore 文件，记录不需要提交到 Git 的东西，节省 Git 服务器资源和带宽、减少冲突。只在项目的根目录里创建这个文件就好，一般的 model 不需要这个文件。（慕课网 - Android 通用架构设计与完整电商App开发 学到的） app下的目录结构 build 里是编译时自动生成的文件，不需要改动。 libs 里放的是你项目中使用到的第三方 jar 包，放在这里的 jar 包会被自动添加进构建路径中去。 androidTest 是用来编写 Android Test 测试用例的，可以进行自动化测试 java 里是放 Java 代码的地方。 res 里 图片放在 drawable 中，布局放在 layout 中，字符放在 values 中，字符包括字符串、样式、颜色等配置，应用图标放在 mipmap 。 res 里的资源有以下两种引用方式： 在代码中：通过 R.资源所在最近文件夹.资源名称，如 R.string.hellp_world 在 xml 中：通过 @资源所在最近文件夹/资源名称，如 @string/hello_wrold AndroidManifest.xml 是整个 Android 项目的配置文件，四大组件都要在此注册，这个文件给应用程序添加权限声明。 test 里用来编写 Unit Test 测试用例，是自动化测试的另一种方式。 build.gradle 是 app 模块的 gradle 构建脚本。 proguard-rules.pro 用于指定项目代码的混淆规则。 app 里的 build.gradleAndroid 的日志工具 Log Log.v() Log.d() Log.i() :important，分析用户行为的数据。 Log.w() Log.e() 1 级别最低，5 级别最高。每次打印日志时，会把此级别以及此级别以上的日志显示出来，使用关键字过滤，支持正则表达式。 Log.d() 方法会传入 2 个参数，第一个是 tag ，一般传入当前类名，用于打印信息过滤，第二个是 msg ，即要打印的具体内容。 AS 快捷键： 在 onCreate() 方法的外面，输入 logt + tab ，生成一个以当前类名作为值的 TAG 常量； logd + tab logi + tab logw + tab loge + tab logt + tab Chapter 2 活动活动的注册在活动中使用 Toast在活动中添加 Menu P38销毁活动 finish（）使用 Intent Intent 是各组件之间进行交互的重要方式。它有两个作用： 指明当前组件想要执行的动作。即意图，如：启动活动、服务、发送广播。 在不同组件之间传递数据。 Intent 有显式和隐式两种。 更多隐式 Intent 的用法 使用 Intent 显示网页 123Intent intent = new Intent(Intent.ACTION_VIEW);intent.setData(Uri.parse("http://www.wangzhuningecnu.github.io"));startActivity(intent); 使用 Intent 指定其他协议，如 geo 地理位置，tel 拨打电话 123Intent intent = new Intent(Intent.ACTION_DIAL);intent.setData(Uri.parse("tel:10000"));startActivity(intent);]]></content>
      <categories>
        <category>Android</category>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>第一行代码</tag>
        <tag>任务清单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective Java]]></title>
    <url>%2F2017%2F10%2F09%2FEffective-Java%2F</url>
    <content type="text"><![CDATA[Chapter 1本书基本原则 清晰性、简洁性：模块的用户永远不应被模块的行为迷惑 模块要尽可能小，但又不能太小（模块 Module 是指任何可重用的组件，包括单个方法，到多个包的复杂系统） 代码应该被重用，而不是被拷贝 模块之间的依赖性应该尽可能降到最小 错误应该尽早被检测出来，最好是在编译时 写出清晰、正确、可用、健壮、灵活和可维护的程序来。如果你能做到这一点，那么获得所需的性能就比较简单了。]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
      </categories>
      <tags>
        <tag>任务清单</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Primary Question]]></title>
    <url>%2F2017%2F10%2F08%2FJava-Primary-Question%2F</url>
    <content type="text"><![CDATA[引用数组的赋值问题元素对象为 Student 类，数组元素对象为什么不能这样声明： 123Student[] arrStudent = new Student[]&#123;&#123;"D",90&#125; , &#123;"C",100&#125; , &#123;"B",95&#125; , &#123;"A",95&#125;&#125;;Student[] arrStudent = new Student[]()&#123;&#123;"D",90&#125; , &#123;"C",100&#125; , &#123;"B",95&#125; , &#123;"A",95&#125;&#125;; Integer 的包装类就可以这样声明： 1234567891011121314151617181920212223//测试 IntegerInteger arrInteger[] = &#123;10,8,9,7,4,6,5,3,2,1&#125;;SelectionSort.selectionSort(arrInteger);for (Integer i : arrInteger )&#123; System.out.print(i + " ");&#125;System.out.println();//测试 DoubleDouble arrDouble[] = &#123;4.3,4.2,3.3,2.1,1.0&#125;;SelectionSort.selectionSort(arrDouble);for (Double double1 : arrDouble) &#123; System.out.print(double1 + " ");&#125;System.out.println();//测试 StringString[] arrString = &#123;"D","C","B","A"&#125;;SelectionSort.selectionSort(arrString);for (String string : arrString) &#123; System.out.print(string+" ");&#125;System.out.println(); 引用类型的数组不可以在声明时赋值吗？ 引用类型数组怎么定义的？ assert 是保证什么的东东，不是类，也不是静态方法，那应该是Object里的,但是没有1assert randomLeft &lt;= randomRight; 这句能保证的是，randomLeft 的值 如果大于 randomRight 的值，则会把他们两个调换。不会报 true 或 false ，也不会报错，程序还是能运行。 泛型泛型啊 Comparable[] Object[] 到底用哪个？Foreach 用法注意若是给数组赋值，则不能用 Foreach ，因为 foreach 只是把值拷贝给一个临时变量，并不会赋值给数组本身。 错误示例： 123for (Integer integer : arr) &#123; integer = new Integer((int)(Math.random()*(randomRight-randomLeft+1)+randomLeft)); &#125; 确实生成了随机数给 integer,但并没有给数组。 Java的反射机制1234567891011121314151617181920212223242526// 测试sortClassName所对应的排序算法，对arr数组排序，所得到结果的正确性和算法运行时间 public static void testSort(String sortClassName , Comparable[] arr)&#123; try &#123; Class sortClass = Class.forName(sortClassName); Method sortMethod = sortClass.getMethod("sort" ,new Class[]&#123;Comparable[].class&#125;); Object[] params = new Object[]&#123;arr&#125;; long startTime = System.currentTimeMillis(); sortMethod.invoke(null,params); //为啥是params，不是arr long endTime = System.currentTimeMillis(); assert isSorted(arr); System.out.println(sortClass.getSimpleName() + " : " + (endTime - startTime ) + "ms"); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; 方法返回值123456789101112131415161718192021222324252627public static boolean isSorted(Integer arr[])&#123; for (int i = 0 ; i &lt; arr.length - 1; i++)&#123; if (arr[i+1] &lt; arr[i])&#123; return false; &#125; return true; &#125;// return true; &#125; public static boolean isSorted(Comparable arr[])&#123; for (int i = 0 ; i &lt; arr.length - 1; i++)&#123; if (arr[i+1] .compareTo(arr[i]) &lt; 0)&#123; return false; &#125;else &#123; return true; &#125; &#125;// return true; &#125; return true; 注释掉后，报错，missing return statement。]]></content>
      <categories>
        <category>Java</category>
        <category>Java 问题贴</category>
      </categories>
      <tags>
        <tag>Java 问题贴</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sortAlgorithm]]></title>
    <url>%2F2017%2F10%2F07%2Fimooc-SortAlgorithm%2F</url>
    <content type="text"><![CDATA[最简单的 — 选择排序 选择排序：每次选择剩余元素中的最小的那个，与当前位置互换。 选择排序不能中断，插入排序根据条件可能中断 选择排序动态图 选择排序示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class SelectionSort &#123; private SelectionSort()&#123;&#125;//此算法类不允许产生实例 public static void selectionSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; //找到剩余元素（下标为 [i，arr.length)中的元素）中最小元素的下标 int min = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) &#123; min = j; &#125; &#125; swap(arr, min, i);//将选择出的最小元素与当前位置元素 arr[i] 交换 for (int n : arr) &#123; System.out.print(n +" "); &#125; System.out.println(); &#125; &#125; public static void swap(int arr[],int n,int m) &#123; int temp = arr[n]; arr[n] = arr[m]; arr[m] = temp; &#125; public static void main(String[] args) &#123; int arr[] = &#123;10,8,9,7,4,6,5,3,2,1&#125;; SelectionSort.selectionSort(arr); for (int i : arr) &#123; System.out.print(i + " "); &#125; System.out.println(); &#125;&#125;输出：1 8 9 7 4 6 5 3 2 10 1 2 9 7 4 6 5 3 8 10 1 2 3 7 4 6 5 9 8 10 1 2 3 4 7 6 5 9 8 10 1 2 3 4 5 6 7 9 8 10 1 2 3 4 5 6 7 9 8 10 1 2 3 4 5 6 7 9 8 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 加了泛型的选择排序123456789101112131415161718192021222324252627282930313233343536package com.ning;public class Student implements Comparable&lt;Student&gt;&#123; private String name; private int grade; public Student(String name,int grade) &#123; // TODO Auto-generated constructor stub this.name = name; this.grade = grade; &#125; public Student() &#123; // TODO Auto-generated constructor stub &#125; // 定义Student的compareTo函数 // 如果分数相等，则按照名字的字母序排序 // 如果分数不等，则分数高的靠前 @Override public int compareTo(Student o) &#123; // TODO Auto-generated method stub if (this.grade &gt; o.grade) &#123; return 1; &#125;else if (this.grade &lt; o.grade) &#123; return -1; &#125;else &#123; return this.name.compareTo(o.name); &#125; &#125; @Override public String toString() &#123; // TODO Auto-generated method stub return "Student: " + this.name + " " + this.grade; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.ning;import java.lang.management.MemoryManagerMXBean;public class SelectionSort &#123; private SelectionSort()&#123;&#125;//算法类不允许产生实例 public static void selectionSort(Comparable[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; //找到 [i，arr.length)中 最小元素的下标 int min = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; //使用compareTo方法比较两个Comparable对象的大小 if (arr[j].compareTo(arr[min]) &lt; 0) &#123; min = j; &#125; &#125; swap(arr, min, i);//将选择出的最小元素与 i 交换 for (Object n : arr) &#123; System.out.print(n +" "); &#125; System.out.println(); &#125; &#125; public static void swap(Object arr[],int n,int m) &#123; Object temp = arr[n]; arr[n] = arr[m]; arr[m] = temp; &#125; public static void main(String[] args) &#123; //测试 Integer Integer arrInteger[] = &#123;10,8,9,7,4,6,5,3,2,1&#125;; SelectionSort.selectionSort(arrInteger); for (Integer i : arrInteger )&#123; System.out.print(i + " "); &#125; System.out.println(); //测试 Double Double arrDouble[] = &#123;4.3,4.2,3.3,2.1,1.0&#125;; SelectionSort.selectionSort(arrDouble); for (Double double1 : arrDouble) &#123; System.out.print(double1 + " "); &#125; System.out.println(); //测试 String String[] arrString = &#123;"D","C","B","A"&#125;; SelectionSort.selectionSort(arrString); for (String string : arrString) &#123; System.out.print(string+" "); &#125; System.out.println(); //测试自定义的 Student 类 Student[] arrStudent = new Student[3]; arrStudent[0] = new Student("wang",100); arrStudent[1] = new Student("zhang",98); arrStudent[2] = new Student("xiang",79); SelectionSort.selectionSort(arrStudent); for (Student student : arrStudent) &#123; System.out.print(student + " "); &#125; System.out.println(); &#125;&#125;输出结果：1 8 9 7 4 6 5 3 2 10 1 2 9 7 4 6 5 3 8 10 1 2 3 7 4 6 5 9 8 10 1 2 3 4 7 6 5 9 8 10 1 2 3 4 5 6 7 9 8 10 1 2 3 4 5 6 7 9 8 10 1 2 3 4 5 6 7 9 8 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1.0 4.2 3.3 2.1 4.3 1.0 2.1 3.3 4.2 4.3 1.0 2.1 3.3 4.2 4.3 1.0 2.1 3.3 4.2 4.3 1.0 2.1 3.3 4.2 4.3 1.0 2.1 3.3 4.2 4.3 A C B D A B C D A B C D A B C D A B C D Student: xiang 79 Student: zhang 98 Student: wang 100 Student: xiang 79 Student: zhang 98 Student: wang 100 Student: xiang 79 Student: zhang 98 Student: wang 100 Student: xiang 79 Student: zhang 98 Student: wang 100 随机生成算法测试用例的 SortTestHelper 类1234567891011121314151617181920212223242526package com.ning;public class SortTestHelper &#123; //SortTestHelper 不允许产生任何实例 private SortTestHelper() &#123;&#125; //生成 n 个元素的随机数组，每个随机数的范围是【randomLeft，randomRight】 public static Integer[] generateRandomArray(int n,int randomLeft,int randomRight) &#123; assert randomLeft &lt;= randomRight; Integer[] arr = new Integer[n]; for (int i = 0 ; i &lt; arr.length ; i++) &#123; arr[i] = new Integer((int)(Math.random()*(randomRight-randomLeft+1)+randomLeft));// System.out.println(arr[i]); &#125; SortTestHelper.printArray(arr); return arr; &#125; public static void printArray(Object[] arr) &#123; for (Object o : arr) &#123; System.out.print(o + " "); &#125; System.out.println(); &#125;&#125; 注意：数组赋值的时候，不能使用 foreach 写法，否则只是赋值给了局部变量，并没有赋值给数组本身。 SortTestHelper 类的使用： 12345//测试 Integer int n = 10000; Integer arrInteger[] = SortTestHelper.generateRandomArray(n, 0, n); SelectionSort.selectionSort(arrInteger); SortTestHelper.printArray(arrInteger); 在 SortTestHelper 类中加入测试算法的性能的代码SortTestHelper 类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package bobo.algo;import java.lang.reflect.Method;import java.lang.Class;public class SortTestHelper &#123; //······ // 判断arr数组是否有序 public static boolean isSorted(Comparable[] arr)&#123; for( int i = 0 ; i &lt; arr.length - 1 ; i ++ ) //这里一定是arr.length - 1，否则越界 if( arr[i].compareTo(arr[i+1]) &gt; 0 ) return false; return true; &#125; // 测试sortClassName所对应的排序算法排序arr数组所得到结果的正确性和算法运行时间 public static void testSort(String sortClassName, Comparable[] arr)&#123; // 通过Java的反射机制，通过排序的类名，运行排序函数 // * 依然是，使用反射机制并不是这个课程的重点, 大家也完全可以使用自己的方式书写代码, 最终只要能够测试出自己书写的算法的效率即可 // * 推荐大家阅读我在问答区向大家分享的一个学习心得: 【学习心得分享】请大家抓大放小，不要纠结于C++语言的语法细节 // * 链接: http://coding.imooc.com/learn/questiondetail/4100.html try&#123; // 通过sortClassName获得排序函数的Class对象 Class sortClass = Class.forName(sortClassName); // 通过排序函数的Class对象获得排序方法 Method sortMethod = sortClass.getMethod("sort",new Class[]&#123;Comparable[].class&#125;); // 排序参数只有一个，是可比较数组arr Object[] params = new Object[]&#123;arr&#125;; long startTime = System.currentTimeMillis(); // 调用排序函数 sortMethod.invoke(null,params); long endTime = System.currentTimeMillis(); assert isSorted( arr ); System.out.println( sortClass.getSimpleName()+ " : " + (endTime-startTime) + "ms" ); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 客户端： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package bobo.algo;import java.util.*;public class SelectionSort&#123; // 我们的算法类不允许产生任何实例 private SelectionSort()&#123;&#125; public static void sort(Comparable[] arr)&#123; int n = arr.length; for( int i = 0 ; i &lt; n ; i ++ )&#123; // 寻找[i, n)区间里的最小值的索引 int minIndex = i; for( int j = i + 1 ; j &lt; n ; j ++ ) // 使用compareTo方法比较两个Comparable对象的大小 if( arr[j].compareTo( arr[minIndex] ) &lt; 0 ) minIndex = j; swap( arr , i , minIndex); &#125; &#125; private static void swap(Object[] arr, int i, int j) &#123; Object t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125; public static void main(String[] args) &#123; // 测试排序算法辅助函数 int N = 10000; Integer[] arr = SortTestHelper.generateRandomArray(N, 0, N); SortTestHelper.testSort("bobo.algo.SelectionSort", arr); return; &#125;&#125;输出结果：N = 100 时，排序数...SelectionSort: 1msN = 1000 时，排序数...SelectionSort: 12msN = 10000 时，排序数..SelectionSort: 140msN = 100000 时，排序数.SelectionSort: 11577ms 同样 n² 的 — 插入排序 插入排序：把后面的元素，一个位置一个位置的往前，插入到合适的位置 插入排序像是一边摸牌，一边码牌；选择排序像是发牌完毕后，再码牌 插入排序动态图 插入排序示例代码123456789101112131415161718192021222324package com.ning;public class InsertionSort &#123; // 我们的算法类不允许产生任何实例 private InsertionSort()&#123;&#125; public static void sort(Comparable arr[]) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; // 寻找元素arr[i]合适的插入位置 for (int j = i; j &gt;= 1 ; j--) &#123; if (arr[j].compareTo(arr[j-1])&lt;0) &#123; swap(arr,j,j-1); &#125;else &#123; break; &#125; &#125; &#125; &#125; private static void swap(Object[] a,int n,int m) &#123; Object temp = a[m]; a[m] = a[n]; a[n] = temp; &#125;&#125; 插入排序与选择排序的比较1234567891011int n = 100000;Integer[] arr1 = SortTestHelper.generateRandomArray(n, 0, n);Integer[] arr2 = Arrays.copyOf(arr1, arr1.length);//Java 中有赋值数组的方法，C++ 中没有SortTestHelper.testSort("com.ning.SelectionSort", arr1);SortTestHelper.testSort("com.ning.InsertionSort", arr2);结果：SelectionSort: 14086msInsertionSort: 15634ms 比较 SelectionSort 和 InsertionSort 两种排序算法的性能效率 此时，插入排序比选择排序性能略低 插入排序的优化 插入排序在元素本就在该位置时，会结束本次比较，按理说比不能中断的选择排序要快，但并非如此，为何？ 因为插入排序在遍历的同时，也在不停交换，交换操作比比较更耗时，每次交换都有三次赋值的操作。 插入排序优化示意图 插入排序优化示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.xiang;import java.util.Arrays;/** * 项目名： SelectionSort2 * 包名： com.xiang * 文件名： InsertSort * Created by ning on 2017/12/1. * 描述： 优化后的插入排序 */public class InsertSort &#123; public static void sort(Comparable[] arr)&#123; for (int i = 1 ; i &lt; arr.length ; i++)&#123;// 寻找元素 arr[i] 合适的位置 Comparable e = arr[i];// 保存元素 e 应该插入的位置 int j; for (j = i ; j &gt; 0 &amp;&amp; e.compareTo(arr[j-1]) &lt; 0; j--)&#123; arr[j] = arr[j-1]; &#125; arr[j] = e; &#125; &#125; public static void main(String[] args)&#123; int N = 10000; Integer arr[] = SortTestHelper.generateAlmostOrderedArray(N,10); Integer arr2[] = Arrays.copyOf(arr,arr.length); SortTestHelper.testSort("com.xiang.SelectionSort",arr2); SortTestHelper.testSort("com.xiang.InsertSort",arr); &#125;&#125; 可以看到，使用优化过后的插入排序，当对几乎有序的数组进行排序时，老师的结果是：插入排序的速度是选择排序的1000倍。我得到的大多数结果是插入排序的速度是选择排序的100倍。 事实上，对于近乎有序的数组，使用优化过后的插入排序甚至比 nlogn 的排序算法更快。 在最优的情况下，对于一个完全有序的数组，插入排序的时间复杂度达到了 O（n），这是插入排序的一个重要的性质，也是它作为其他复杂排序子过程的原因。 选择排序和插入排序的比较 选择排序：O（n^2）, 不能中断 插入排序：O（n^2) ，可以中断，最优情况：O (n) ，比 nlogn 还要快，最差情况 O（n^2），是希尔排序的子过程，希尔排序是 O（n^(3/2)），虽然比 O（nlogn）稍大一些，但是他的实现较为简单，和插入排序一脉相承。 冒泡排序： 冒泡排序12345678910111213141516171819202122232425262728293031323334353637package com.ning;//这是冒泡排序public class BubbleSort &#123; private BubbleSort() &#123; &#125; public static void sort(Comparable[] array) &#123; for (int i = 0; i &lt; array.length; i++) &#123; for (int j = 1+i; j &lt; array.length; j++) &#123; if (array[j].compareTo(array[i]) &lt; 0) &#123; Comparable temp = array[j]; array[j] = array[i]; array[i] = temp; &#125; &#125; &#125; &#125;&#125;输出结果：11 14 9 16 7 19 1 9 15 5 1 14 11 16 9 19 7 9 15 5 1 5 14 16 11 19 9 9 15 7 1 5 7 16 14 19 11 9 15 9 1 5 7 9 16 19 14 11 15 9 1 5 7 9 9 19 16 14 15 11 1 5 7 9 9 11 19 16 15 14 1 5 7 9 9 11 14 19 16 15 1 5 7 9 9 11 14 15 19 16 1 5 7 9 9 11 14 15 16 19 1 5 7 9 9 11 14 15 16 19 1 5 7 9 9 11 14 15 16 19 选择排序的优化我自己写的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.xiang;import java.util.Arrays;/** * 项目名： SelectionSort2 * 包名： com.xiang * 文件名： SelectionSort2 * Created by ning on 2017/12/7. * 描述： 我自己写的选择排序的优化 */public class SelectionSort2 &#123; public static void sort(Comparable[] array)&#123; int left = 0; int right = array.length-1; int minIndex,maxIndex ; Comparable min,max; while (left &lt; right)&#123; minIndex = left; maxIndex = left; max = array[maxIndex]; min = array[minIndex]; for (int i = left ; i &lt;= right ; i++)&#123; if (array[i].compareTo(array[minIndex]) &lt; 0)&#123; minIndex = i; &#125; if (array[i].compareTo(array[maxIndex]) &gt; 0)&#123; maxIndex = i ; &#125; max = array[maxIndex]; min = array[minIndex]; &#125; array[left] = min; array[right] = max; left++; right--; &#125; &#125; public static void main(String args[])&#123; int N = 10000; Integer arr[] = SortTestHelper.generateRandomArray(N,0,N); Integer arr2[] = Arrays.copyOf(arr,arr.length); SortTestHelper.testSort("com.xiang.SelectionSort2",arr); SortTestHelper.testSort("com.xiang.SelectionSort",arr); &#125;&#125; 结果： 截图 bobo 老师写的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.xiang;/** * 项目名： SelectionSort2 * 包名： com.xiang * 文件名： Selection3 * Created by ning on 2017/12/12. * 描述： bobo 的选择排序的优化 */public class SelectionSort3 &#123; // 我们的算法类不允许产生任何实例 private SelectionSort3()&#123;&#125; public static void sort(Comparable[] arr)&#123; int left = 0, right = arr.length - 1; while(left &lt; right)&#123; int minIndex = left; int maxIndex = right; // 在每一轮查找时, 要保证arr[minIndex] &lt;= arr[maxIndex] if(arr[minIndex].compareTo(arr[maxIndex]) &gt; 0) swap(arr, minIndex, maxIndex); for(int i = left + 1 ; i &lt; right; i ++) if(arr[i].compareTo(arr[minIndex]) &lt; 0) minIndex = i; else if(arr[i].compareTo(arr[maxIndex]) &gt; 0) maxIndex = i; swap(arr, left, minIndex); swap(arr, right, maxIndex); left ++; right --; &#125; &#125; private static void swap(Object[] arr, int i, int j) &#123; Object t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125; // 测试SelectionSort2 public static void main(String[] args) &#123; int N = 10000; Integer[] arr = SortTestHelper.generateRandomArray(N, 0, 100000); SortTestHelper.testSort("com.xiang.SelectionSort3", arr); SortTestHelper.testSort("com.xiang.SelectionSort2",arr); SortTestHelper.testSort("com.xiang.SelectionSort",arr); return; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>Java 算法与数据结构（慕课网）</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TaskList：SAIC MAXUS]]></title>
    <url>%2F2017%2F10%2F04%2FTaskList%EF%BC%9ASAIC-MAXUS%2F</url>
    <content type="text"><![CDATA[bug 记录 退出，在被迫下线之后重新登录后再退出，还是返回了主界面 DIY ABCD 行程、车况 1234java.lang.NullPointerException: Attempt to invoke interface method 'io.netty.channel.ChannelFuture io.netty.channel.Channel.writeAndFlush(java.lang.Object)' on a null object reference at com.example.aidrive3.SignIn.sendMessage(SignIn.java:981) at com.example.aidrive3.SignIn.access$1000(SignIn.java:51) at com.example.aidrive3.SignIn$4$1.run(SignIn.java:447) 断网时，系统退出？ 去掉状态栏下拉时的阴影,状态栏下拉如何去除阴影？ Android WebView页面加载优化 数据库实现手机验证码滚动广告搜索智能推荐购买支付语音]]></content>
      <categories>
        <category>上汽大通</category>
      </categories>
      <tags>
        <tag>任务清单</tag>
        <tag>上汽大通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Writing specifications]]></title>
    <url>%2F2017%2F10%2F02%2FWriting-specifications%2F</url>
    <content type="text"><![CDATA[摘自： stormzhang 的博客：每个人都需要的中文排版指南 空格 中英文之间需要加空格 eg. 大家可以搜索公众号 AndroidDeveloper 或者 googdev 关注我。 中文与数字之间需要加空格 eg. 不知不觉，我都快 30 岁了。 数字与单位之间需要加空格 eg. 我有一块 20 TB 的硬盘，鬼知道我是怎么用完的。 完整的英文整句时标点与单词之间需要加空格 eg. Stay hungry, stay foolish. 但是也有一些例外。 度的标志、百分号不加空格 eg. 今天气温有 30° 的高温。 eg. 据统计，关注公众号 AndroidDeveloper 的读者中有 80% 是长得好看的。 全角标点与其他字符之间不加空格 eg. 大家好，我是 stormzhang，请多多关照。 标点全角和半角是英文和中文的编码规范不同遗留下的问题，简单来说，全角占两个字节，半角占一个字节，你可以理解成中文汉字是全角，英文字母是半角，不过半角全角主要是针对标点符号来说的，中文标点占两个字节，英文标点占一个字节。体现在排版上的差异就是，全角字符屏幕打印宽度是两个，而半角字符屏幕打印宽度是一个，如中文逗号和英文逗号他们的显示分别是「，」和「,」。 使用全角中文标点 中文排版中所有的标点都应该使用中文全角中文标点 eg. 大家好，我是 stormzhang。 遇到英文整句、特殊名词时使用半角标点。 eg. 乔布斯说过：「Stay hungry, stay foolish.」 eg. Facebook, Inc. 使用直角引号 我国国家标准要求弯引号，但是个人建议在新媒体排版时使用直角引号。 eg. 你竟然不知道「帅比张」？ 如果引号再使用引号使用直角双引号。 eg. 我质问他，「你难道忘记『帅比张』了么？」 其他除以上之外，还有一些其他标准推荐大家使用的。 英文名词首字母尽量大写 eg. Google、Android、Facebook 专有名词使用正确的大小写 eg. GitHub、iOS、iPhone 6s、MacBook Pro 首行不要缩进 大家一般都采用「空出一行」进行自然段与自然段之间的区分，这种写作方式非常省事，而且很整齐。 ​]]></content>
      <categories>
        <category>stormzhang</category>
        <category>Blog 书写规范</category>
      </categories>
      <tags>
        <tag>stormzhang</tag>
        <tag>中文排版指南</tag>
        <tag>书写规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BookList]]></title>
    <url>%2F2017%2F09%2F30%2FBookList%2F</url>
    <content type="text"><![CDATA[过去完成时 Head First Java： 8 - 9 月 现在进行时 Android 第一行代码：10 月 Java 算法与数据结构（慕课网）：10 - 11 月 15 日，每天一小部分，你努力时，全世界都会给你让路。 Head First Java 总结：10月 。每晚补一点。 Head First 设计模式：10 - 11 月 15 日，和慕课网的视频结合着一起看。 CET - 6（10 月 - 11月 15日）：考研单词一天背一单元；一周看一次语法视频。 将来时]]></content>
      <categories>
        <category>书单</category>
      </categories>
      <tags>
        <tag>任务清单</tag>
        <tag>书单</tag>
        <tag>Head First Java</tag>
        <tag>Effective Java</tag>
        <tag>Thinking in Java</tag>
        <tag>Android 第一行代码</tag>
        <tag>Head First 设计模式</tag>
        <tag>CET - 6</tag>
        <tag>Java 算法与数据结构（慕课网）</tag>
        <tag>玩转算法面试 LeetCode 题库分门别类详细解析（慕课网）</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub + Hexo + NexT 主题 免费搭建博客-参考链接收集]]></title>
    <url>%2F2017%2F09%2F30%2FFreeBlog%EF%BC%9AGitHub-Hexo%2F</url>
    <content type="text"><![CDATA[博客搭建 GitHub 官网：https://github.com/ Hexo 官网：https://hexo.io/zh-cn/ 部署博客 NexT 主题官网：http://theme-next.iissnan.com/ 美化博客 NexT 源码地址：用于失误修改next文件夹里的文件，可以参考源码还原 最适合新手的 GitHub + Hexo 「大话」博客搭建教程 建立博客系列（三）：Hexo 安装配置 建立博客系列（四）：NexT 主题相关配置 建立博客系列（五）：发布第一篇文章 记录第一次搭建 Hexo 一些错误的解决方案 解决 Hexo 神烦的 DTraceProviderBindings MODULE_NOT_FOUND Mac 快速显示或隐藏“隐藏”文件 Mac 设置文件权限问题 博客主题 NexT 参考 Jark’s Blog 随风丶亮 主题 NexT 美化 NexT 主题里用到的所有图标 网站 icon 下载地址 NexT 主题配置及优化-动态背景等大全 Hexo 的 NexT 主题个性化教程:打造炫酷网站 NexT 主题添加腾讯空间404公益页面 Hexo 文章管理和写文章 Hexo 使用攻略：（四）Hexo 的分类和标签设置 分类和标签有什么区别和关联? Front - matter | Hexo 官网关于文章分类的解释 Markdown 官网 认识与入门 Markdown Markdown 语法手册 （完整整理版） Mac 下好用的 Markdown 编辑器– Mou Mac 下好用的 Markdown 编辑器—Typora Mac 下好用的图床工具 CloudApp（科学上网 + 软件收费 + 14天试用） 如何利用 GitHub 在 Markdown 中优雅地插入图片 Hexo-设置阅读全文 注意 修改文件之前先行备份，以防更改失败； 找不到的信息，结合官网查询。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F09%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
