<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[英文词串 - 英语流利说]]></title>
    <url>%2F2017%2F11%2F06%2FEnglish-word-phrase%2F</url>
    <content type="text"><![CDATA[英语六级口语考试自我介绍 语音一定要准（第一印象很重要） 语速不要过快或过慢（20秒，40-50词为最佳） 适当使用连续以增加语言的流畅度，有快有慢 不要面面俱到，找一两个方向，展开一两句即可 六级考生还要根据自己的自我介绍准备可能考官追问的问题 名字问题可以不说 自我介绍部分思考方向： 年龄，专业 大学介绍 i am from … university,she is a famous beatiful school name love in here. 性格特点 家庭背景 业余爱好 家乡景点 百度搜 地名+英文介绍可以参考 自我介绍注意停顿和连读就更好一些，每一个发言一定要准确。 先写100词的自我介绍，再按照连读规则，把施爆的地方划掉，连读音变加上，语速增加、减缓画出来，读音注意的地方画上，背下来，录下来，听哪里不好再改 老师问问题，基于你自己所说的东西问，回答的时候，挑自己会说的回答，不一定是实话。 图片 so, what do you say? 巴拉巴拉说了一堆后，询问对方的意见。]]></content>
      <categories>
        <category>英语</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[带领新手快速开发 Android App]]></title>
    <url>%2F2017%2F11%2F02%2Fimooc-Quick-develop-Android-App%2F</url>
    <content type="text"><![CDATA[借助流行的第三方 SDK 及框架，开发“生活小助手 App ”。 用户管理登录注册忘记密码语音机器人聊天微信精选文章物流及电话号码归属地查询美女相册个性化二维码扫描与生成定位与查看地图]]></content>
      <categories>
        <category>慕课网</category>
        <category>带领新手快速开发 Android App</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程小白的第一本 Python 入门书]]></title>
    <url>%2F2017%2F11%2F02%2FFirst-Python%2F</url>
    <content type="text"></content>
      <categories>
        <category>Python</category>
        <category>Python 入门</category>
      </categories>
      <tags>
        <tag>Python 入门</tag>
        <tag>编程小白的第一本 Python 入门书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Head First Java]]></title>
    <url>%2F2017%2F11%2F02%2FHead-First-Java%2F</url>
    <content type="text"><![CDATA[Java 的垃圾回收p40 对象的创建内存示意图 对象的引用变量有多大？ 除非你和 JVM 开发团队有交情，不然不知道，在同一个 JVM 中，引用变量的大小是一样的。若你是要讨论内存分配的问题，你要关心的应该是需要建立多少个对象和引用，以及对象的实际大小。 Head First Java 基础知识附录取得命令行用户输入字符串的方法1234567891011121314151617181920212223242526import java.io.BufferedReader;import java.io.InputStreamReader;public class Helper &#123; public static void main(String args[]) &#123; Helper helper = new Helper(); System.out.println(helper.getUserInput("Please enter a number: ")); &#125; public String getUserInput(String prompt) &#123; String inputLine = null; System.out.println(prompt + " "); try &#123; BufferedReader is = new BufferedReader(new InputStreamReader(System.in)); inputLine = is.readLine(); if (inputLine.length() == 0) &#123; return null; &#125; &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125; return inputLine; &#125;&#125; 其中 123if (inputLine.length() == 0) &#123; return null;&#125; 这是做”用户什么都没输入的处理”，不加这句，什么也不会输出 另外 12String string = "dsfs";System.out.println(string.length()); String 类型的变量也有 length() 方法，不止数组有。 Returns: the length of the sequence of characters represented by this object. 如果 string 是 null ，则string.length() 会报空指向异常。 foreach 与 for1for(int cell : locationCells ) &#123;···&#125; 编译器会这么做： 创建名为 cell 的 int 变量 将 locationCells 的第一个元素值赋给 cell 执行循环内容 赋值给下一个元素 cell 重复执行至所有的元素被运行完毕为止 locationCells 的集合必须是数组或其他集合的引用。而且 int 这个位置的类型要与 locationCells 兼容。 注意：可以看出，在 foreach 的执行过程中，采用了数组数据赋值，所以，cell 值的改变并不会影响 原来数组里那个位置的元素值。如果需要改变原来的数组，如排序，就要用之前的 for 循环。 原始的 for 循环： 12for(int i = 0 ; i&lt;0 ; i++ ) &#123;···&#125; 1 2 3 4 运行顺序： 1 -&gt; 2 ：1. true -&gt; 4 -&gt; 3 -&gt; 2 : 1. true -&gt; 4 -&gt; 3 -&gt; 2 :1. true -&gt; 4 -&gt; 3 -&gt; 2 : ​ 2.false -&gt; end 2.false -&gt; end 2.false -&gt; end for 与 while 比较： 不知道执行次数用 while，知道执行次数用 for更清晰。 String 转 int1int num = Integer.parseInt("3"); Integer 的 parseInt() 方法，能将 String 解析。 这个方法仅对代表数字的 String 起作用，除此之外，程序就会崩溃，抛出异常。 Java 传参数是值拷贝参数的值是由实参拷贝而来的，参数的改变不会影响到原先的值，但要是传递的是引用变量，那么引用变量的远程控制（字节组合代表取得远程控制对象的方法）也会拷贝过来，那么参数的改变就会影响原来的值。 变量的比较 == ：用来比较两个变量的字节组合是否相等，对于 primitive 主数据类型来说，字节组合就是实际的变量值，对于引用来说，字节组合是取得对象的方法（指针），== 就是判断两个引用是否指向同一个对象。 equals（）：用来判断两个对象是否在意义上相等。即对象的相等性。 实例变量 VS 局部变量实例变量声明在类内，未初始化时，有默认值。integer 和 char 类型默认为 0 ，boolean 默认为 false，对象引用默认为 null。null 表示没有操作对象的远程控制，他是个引用而不是对象。 局部变量声明在方法内，未初始化时，没有默认值。方法的参数也是局部变量。如果局部变量未初始化就使用，编译器会报错。 random() 方法产生随机数产生 [n,m] 之间的随机数： 1int x = (int)( Math.random() * (m-n+1) + n ); Math.random() 方法返回介于 0 与 1 之间的 double 值，然后将此值乘以数组元素个数，再取整数值。 random() Returns: a pseudorandom double greater than or equal to 0.0 and less than 1.0. 大于等于 0 ，小于 1. 写伪代码参考Chapter 5 Page 100 类、方法、变量的命名规则 必须以字母，下划线，或 $ 开头 除第一个字符外，后面可以用数字 避开 Java 的关键字 变量的两种口味 香辣的对象引用：保存的是对象的引用，以字节来表示取得对象的方法（遥控器）。 清凉的 primitive 主数据类型：保存的是变量本身，以字节代表实际的变量值，有 boolean、char、byte、short、int、long、float、double 8种。 注意，数组不论被声明来承载的是 primitive 主数据类型，或对象引用，数组永远是对象。 Java 是个强类型语言类型不许乱用，可以被隐含的放大（小值放大容器），或明确的缩小（强制类型转换） Java APIJava 中内置了数百个类，被称为 API，其实他就是个函数库，你可以把他当做自己写的来用。ArrayList 类就是 Java 函数库里的一个。 使用函数库时，要在使用到该类时写出完整的类名，或是在源文件开头 import 进它的包名，除非是来源于 java.lang 这个包中，java.lang 是个预先被引用的包，是个经常会用到的基础包。 类用包来组织，但 import 绝不是 C 里的 include，import 只是会帮你省下每个类前面的包名称，程序并不会因为 import 而变大或变慢。 以 javax 开头的包以前曾经是扩展，后来才取得了标准的名份。 ArrayList 类ArrayList 类是 java.util 工具类的代表。 123ArrayList&lt;Egg&gt; myList = new ArrayList&lt;Egg&gt;();//虽然 ArrayList 里返回的是 Object，但编译器会帮你做类型转换，转成 Egg 类型 新的 ArrayList 对象虽然和数组一样会创建在堆上，但他们有本质的不同 ArrayList 数组 使用 ArrayList，只是运用 ArrayList 类型的对象，跟使用其他对象一样，用 “.” 运算符调用它的方法。 使用数组，要用特殊的数组语法 []，无法调用它的方法，最多只能存取它的 length 实例变量。 ArrayList 会自动管理大小 数组要定义它的大小，且大小不能改变 ArrayList 只能携带对象，不能装 primitive 主数据类型，但是非要装的话，编译器会自动将 primitive 包装成 Object ，再放入 ArrayList 中 在装载 primitive 主数据类型时，数组比 ArrayList 快 是类型参数，代表是 String 的集合 短运算的使用可以用这种方式避免调用内容为 null 的指针变量： 123if( refVar ! = null &amp;&amp; refVar.isValidType())&#123; //执行有效变量的工作&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>Head First Java</category>
      </categories>
      <tags>
        <tag>Head First Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 开发中遇到的 bug]]></title>
    <url>%2F2017%2F10%2F30%2FAndroid-developing-bug%2F</url>
    <content type="text"><![CDATA[NoSuchMethodError: No static method wrapSharedElementTransition上汽大通项目遇到火山级 bug，点击 123456789101112131415java.lang.NoSuchMethodError: No static method wrapSharedElementTransition(Ljava/lang/Object;)Ljava/lang/Object; in class Landroid/support/v4/app/FragmentTransitionCompat21; or its super classes (declaration of 'android.support.v4.app.FragmentTransitionCompat21' appears in /data/app/com.example.aidrive2-1/base.apk) at android.support.v4.app.BackStackRecord.getSharedElementTransition(BackStackRecord.java:1156) at android.support.v4.app.BackStackRecord.configureTransitions(BackStackRecord.java:1222) at android.support.v4.app.BackStackRecord.beginTransition(BackStackRecord.java:1112) at android.support.v4.app.BackStackRecord.run(BackStackRecord.java:721) at android.support.v4.app.FragmentManagerImpl.execPendingActions(FragmentManager.java:1677) at android.support.v4.app.FragmentManagerImpl$1.run(FragmentManager.java:536) at android.os.Handler.handleCallback(Handler.java:815) at android.os.Handler.dispatchMessage(Handler.java:104) at android.os.Looper.loop(Looper.java:194) at android.app.ActivityThread.main(ActivityThread.java:5556) at java.lang.reflect.Method.invoke(Native Method) at java.lang.reflect.Method.invoke(Method.java:372) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:967) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:762) app:dexDebug：/Library/Java/JavaVirtualMachines/jdk1.8.0_92.jdk/Contents/Home/bin/java’’ finished with non-zero exit value 21Error:Execution failed for task ':app:dexDebug'. &gt; com.android.ide.common.process.ProcessException: org.gradle.process.internal.ExecException: Process 'command '/Library/Java/JavaVirtualMachines/jdk1.8.0_92.jdk/Contents/Home/bin/java'' finished with non-zero exit value 2 是 app/build.gradle 依赖包的版本问题， 参考： https://stackoverflow.com/questions/30001051/appdexdebug-execexception-finished-with-non-zero-exit-value-2 http://www.cnblogs.com/creasylai19/p/5027757.html 状态：未解决]]></content>
      <categories>
        <category>Android</category>
        <category>Android Developing Bug</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文相关]]></title>
    <url>%2F2017%2F10%2F29%2FMyPaper%2F</url>
    <content type="text"><![CDATA[彩虹无线发布“立方体计划”：前装车联网大数据的两种玩法]]></content>
      <categories>
        <category>毕设论文</category>
        <category>材料收集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hencoder 朱凯的高级教程]]></title>
    <url>%2F2017%2F10%2F29%2Fhencoder%2F</url>
    <content type="text"><![CDATA[给高级 Android 工程师的进阶手册第一讲，讲 UI 一般使用 自带控件 + 开源库，可以实现大部分 UI 效果。但一些新颖的效果，要自定义 View 来实现。 自定义 View 的 3 个关键点： 布局 绘制 触摸反馈 听课： 录播的视频 + 文字 + 练习项目。视频负责打通概念，文字负责阐述细节，练习项目负责最后一公里，让你从「我懂了」变成「我会了」 自定义 View 1-1 绘制基础绘制就是控件内容的显示。 自定义绘制就是你来接管绘制的过程，操作绘制细节。使用系统 API 是绘制不出柱状图和饼形图的，即使绘制出来，性能也不佳，这时要使用自定义绘制 View。]]></content>
      <categories>
        <category>Android</category>
        <category>Hencoder 朱凯的高级教程</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>朱凯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[颠覆你的传统英语学习 - 杨萃先]]></title>
    <url>%2F2017%2F10%2F27%2FPronunciation-of-Miss-Yang%2F</url>
    <content type="text"><![CDATA[视频地址：撕掉单词语法书，颠覆你的传统英语学习 第 0 课 - 找对方法 本节课作业： 下载 app，找到和自己生活、工作密切相关的部分听，听不懂的，立马查，可以看字幕，怎么能听懂怎么听。听满 100 小时。 生活中，环境中，只要是不会的生词，立马查。至少找到五个不会的。 关注老师个人公众号 “途正英语”。看老师的文章和小故事。 找志同道合的小伙伴讨论，说英语。 第 1 课 - 背单词大法 记单词： 作业：]]></content>
      <categories>
        <category>英语</category>
        <category>英语口语</category>
      </categories>
      <tags>
        <tag>英语口语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纪老师英语音标课程]]></title>
    <url>%2F2017%2F10%2F26%2FPronunciation-of-Miss-Ji%2F</url>
    <content type="text"><![CDATA[视频地址纪老师英语 - 音标篇 纪老师 英语音标口诀记忆法 – 音标一 5 个元音 + 1 个辅音 纪老师 英语音标口诀记忆法 – 音标二 5 个辅音的发音方法 纪老师 英语音标口诀记忆法 – 音标三 8 个双元音的发音方法 纪老师 英语音标口诀记忆法 – 音标四 12 个辅音的发音方法 纪老师 英语音标口诀记忆法 – 音标五 p、k、t 清音浊化 纪老师 英语音标口诀记忆法 – 音标实战篇 英语习惯用语发音练习 1 - 6 句 纪老师 英语音标口诀记忆法 – 音标实战篇 英语习惯用语发音练习 32 句 纪老师 英语音标口诀记忆法 – 音标实战篇 英语习惯用语发音练习 71 - 79 句 纪老师 英语音标口诀记忆法 – 音标实战篇 英语习惯用语发音练习 108 - 135 句 纪老师 - 48个国际音标的记忆口诀讲义地址纪老师 - 48个国际音标的记忆口诀【讲义】 音标一元音：20 个，相当于韵母 辅音：28 个，相当于声母 第一节学习 5 个元音和 1 个辅音： 发言口诀： 音标二第二节学习 5 个辅音 f、l、m、n 的发音：一种是读汉语拼音里的flmn，另一种是读这四个英文字母发音的尾音。 后面有可以一起拼读的就发flmn的音，没有一起拼读的音就发英文字母的尾音。 r 后面有可以一起拼读的音就发 ru 音，没有一起拼读的音就发 “儿”化音。 音标三第三节学习 8 个双元音。 英语讲究「滑音」。双元音的读法是从第一个音向后面一个滑动。 新旧音标对比如下： 音标四12 个辅音的发音方法 噘嘴的 s，发汉语拼音的平舌 s 噘嘴的 z，发汉语拼音的平舌 z 噘嘴的 s，发汉语拼音中的咬舌 s 咬舌尖的 r，发汉语拼音中的 r 噘嘴的 ch，发汉语拼音的翘舌 ch 噘嘴的 zh，发汉语拼音的翘舌 zh 噘嘴的 chu，发汉语拼音的翘舌 chu 噘嘴的 zhu，发汉语拼音的翘舌 zhu chi，发音在 c 与 ch 之间，我觉得是 ci zhi，发音在 z 与 zh 之间，我觉得是 zi y，发汉语拼音 yi 不能噘嘴的 wu，上牙轻抚下唇。 音标五清音浊化问题，也叫音变。 p k t 胆子小，见到 s 须变音。 p 变 b，k 变 g，t 要变成 d。 英语音标中一共有 48 个音素，讲了 31 个特殊的音素，剩下 17 个音素与汉语拼音发音相似。 如 p，读短促的 p，k，读短促的 k。]]></content>
      <categories>
        <category>英语</category>
        <category>音标</category>
      </categories>
      <tags>
        <tag>音标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慕课网 - Android 通用框架设计与完整电商 APP 开发]]></title>
    <url>%2F2017%2F10%2F20%2Fimooc-Android-Complete-e-commerce-app%2F</url>
    <content type="text"><![CDATA[用到的 GitHub 上的库字体库JoanZapata 字体库 123//字体图标compile 'com.joanzapata.iconify:android-iconify-ionicons:2.2.2'compile 'com.joanzapata.iconify:android-iconify-fontawesome:2.2.2' Fragmentation 的库Fragmentation 的库 123//Fragment依赖compile 'me.yokeyword:fragmentation:1.1.6'compile 'me.yokeyword:fragmentation-swipeback:1.1.6' 视图注入的库 ButterKnifeButterKnife 的配置要参考ButterKnife官网，要配置 3 个地方 123//ButterKnife依赖compile 'com.jakewharton:butterknife:8.8.1'annotationProcessor 'com.jakewharton:butterknife-compiler:8.8.1' 123456789101112131415161718buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.3.3' // ButterKnife 插件 classpath 'com.jakewharton:butterknife-gradle-plugin:8.8.1' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;allprojects &#123; repositories &#123; jcenter() mavenCentral() &#125;&#125; 12apply plugin: 'com.android.library'apply plugin: 'com.jakewharton.butterknife' BufferKnife 插件的作用是生成 R2 的类，R2 类是生成视图绑定需要的唯一 ID，资源文件 R 只能在为 application 类型的 module 里使用，为 library 类型的 module 使用 BufferKnife 插件根据 R 生成 R2 的资源文件来访问视图绑定的 ID。 网络框架 retrofitretrofit 理解 RESTful 架构 RESTful API 设计最佳实践 12345//网络请求依赖 compile 'com.squareup.okio:okio:1.13.0' compile 'com.squareup.okhttp3:okhttp:3.8.1' compile 'com.squareup.retrofit2:retrofit:2.3.0' compile 'com.squareup.retrofit2:converter-scalars:2.3.0' Loading 加载库AVLoadingIndicatorView 12//loading 依赖 compile 'com.wang.avi:library:2.1.3' 启动页倒计时首次启动可以滑动Android-ConvenientBanner 全屏的广告轮播]]></content>
      <categories>
        <category>慕课网</category>
        <category>Android 通用框架设计与完整电商 APP 开发</category>
      </categories>
      <tags>
        <tag>Android 通用框架</tag>
        <tag>未解决的 bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慕课网 - 懒人必备之 Android 效率开发框架]]></title>
    <url>%2F2017%2F10%2F16%2Fimooc-Android-Framework-video-8302%2F</url>
    <content type="text"><![CDATA[什么是框架 框架是地基，地基打的好，不管业务层有多大的变化，都不会影响到正常的开发. 不用框架，理论上讲是可以的，但是开发成本就变高了，很多集成服务要自己搭建 Android 中哪些可以抽象成为框架的： 网络模块 图片缓存模块 数据库模块 UI 基础 把这些抽出来之后，只要写业务层就好了。 AndroidAnnotation AndroidAnnotation 官网 AndroidAnnotation 是基于注解的标签库，所有标签。 AS 配置androidannotationsapp/build.gradle: 123456789101112131415def AAVersion = '4.3.0'dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', &#123; exclude group: 'com.android.support', module: 'support-annotations' &#125;) compile 'com.android.support:appcompat-v7:25.3.1' compile 'com.android.support.constraint:constraint-layout:1.0.1' testCompile 'junit:junit:4.12' //androidannotations 注解标签库 annotationProcessor "org.androidannotations:androidannotations:$AAVersion" compile "org.androidannotations:androidannotations-api:$AAVersion"&#125; AndroidManifest.xml 中每个使用 androidAnnotations 的 Activity 名字后面都要添加_ 1234&lt;activity android:name=".MainActivity_" android:label="FirstTest"&gt;&lt;/activity&gt; .MainActivity 为什么要加 ？ 是 androidAnnotations ，在处理的过程中，生成的 .MainActivity_ 的 Activity。 参考了：http://www.cnblogs.com/l2rf/p/4971825.html http://blog.csdn.net/xx326664162/article/details/68490059 http://blog.csdn.net/doris_d/article/details/52634450 http://www.cnblogs.com/caobotao/p/5138935.html http://blog.csdn.net/caiwenfeng_for_23/article/details/45801151 https://github.com/androidannotations/androidannotations/blob/master/examples/gradle/build.gradle 没搞好，报错。 1234567891011121314151617181920212223242526272829Process: com.ning.helloworld, PID: 14359 java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;com.ning.helloworld/com.ning.helloworld.MainActivity_&#125;: java.lang.NullPointerException: Attempt to invoke virtual method 'void android.widget.Button.setOnClickListener(android.view.View$OnClickListener)' on a null object reference at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2470) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2532) at android.app.ActivityThread.access$800(ActivityThread.java:169) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1421) at android.os.Handler.dispatchMessage(Handler.java:111) at android.os.Looper.loop(Looper.java:194) at android.app.ActivityThread.main(ActivityThread.java:5556) at java.lang.reflect.Method.invoke(Native Method) at java.lang.reflect.Method.invoke(Method.java:372) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:967) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:762) Caused by: java.lang.NullPointerException: Attempt to invoke virtual method 'void android.widget.Button.setOnClickListener(android.view.View$OnClickListener)' on a null object reference at com.ning.helloworld.MainActivity.onCreate(MainActivity.java:67) at com.ning.helloworld.MainActivity_.onCreate(MainActivity_.java:33) at android.app.Activity.performCreate(Activity.java:5975) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1111) at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2423) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2532) at android.app.ActivityThread.access$800(ActivityThread.java:169) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1421) at android.os.Handler.dispatchMessage(Handler.java:111) at android.os.Looper.loop(Looper.java:194) at android.app.ActivityThread.main(ActivityThread.java:5556) at java.lang.reflect.Method.invoke(Native Method) at java.lang.reflect.Method.invoke(Method.java:372) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:967) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:762) annotation 的使用 看到这： 课程网址]]></content>
      <categories>
        <category>慕课网</category>
        <category>懒人必备之 Android 效率开发框架</category>
      </categories>
      <tags>
        <tag>未解决的 bug</tag>
        <tag>Android 框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 第一行代码]]></title>
    <url>%2F2017%2F10%2F10%2FAndroid-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Chapter 1 入门Android 各版本对应的 API 版本号 系统代号 API 4.0.3 - 4.0.4 Ice Cream Sandwich 15 4.1.x 4.2.x 4.3 Jelly Bean 16 17 18 4.4 KitKat 19 5.0 5.1 Lollipop 21 22 6.0 Marshmallow 23 7.0 7.1 Nougat 24 25 8.0 Oreo 26 Android 程序的项目结构 gradle 下包含了 gradle wrapper 的配置文件。 gradle.properties 是全局的 gradle 配置文件。这里配置的属性将会影响到项目中所有的 gradle 编译脚本。 app 是开发的主要工作目录。 其他都是些 AS 自动生成的文件，不需要修改。 .gitignore 文件，记录不需要提交到 Git 的东西，节省 Git 服务器资源和带宽、减少冲突。只在项目的根目录里创建这个文件就好，一般的 model 不需要这个文件。（慕课网 - Android 通用架构设计与完整电商App开发 学到的） app下的目录结构 build 里是编译时自动生成的文件，不需要改动。 libs 里放的是你项目中使用到的第三方 jar 包，放在这里的 jar 包会被自动添加进构建路径中去。 androidTest 是用来编写 Android Test 测试用例的，可以进行自动化测试 java 里是放 Java 代码的地方。 res 里 图片放在 drawable 中，布局放在 layout 中，字符放在 values 中，字符包括字符串、样式、颜色等配置，应用图标放在 mipmap 。 res 里的资源有以下两种引用方式： 在代码中：通过 R.资源所在最近文件夹.资源名称，如 R.string.hellp_world 在 xml 中：通过 @资源所在最近文件夹/资源名称，如 @string/hello_wrold AndroidManifest.xml 是整个 Android 项目的配置文件，四大组件都要在此注册，这个文件给应用程序添加权限声明。 test 里用来编写 Unit Test 测试用例，是自动化测试的另一种方式。 build.gradle 是 app 模块的 gradle 构建脚本。 proguard-rules.pro 用于指定项目代码的混淆规则。 app 里的 build.gradleAndroid 的日志工具 Log Log.v() Log.d() Log.i() :important，分析用户行为的数据。 Log.w() Log.e() 1 级别最低，5 级别最高。每次打印日志时，会把此级别以及此级别以上的日志显示出来，使用关键字过滤，支持正则表达式。 Log.d() 方法会传入 2 个参数，第一个是 tag ，一般传入当前类名，用于打印信息过滤，第二个是 msg ，即要打印的具体内容。 AS 快捷键： 在 onCreate() 方法的外面，输入 logt + tab ，生成一个以当前类名作为值的 TAG 常量； logd + tab logi + tab logw + tab loge + tab logt + tab Chapter 2 活动活动的注册在活动中使用 Toast在活动中添加 Menu P38销毁活动 finish（）使用 Intent Intent 是各组件之间进行交互的重要方式。它有两个作用： 指明当前组件想要执行的动作。即意图，如：启动活动、服务、发送广播。 在不同组件之间传递数据。 Intent 有显式和隐式两种。 更多隐式 Intent 的用法 使用 Intent 显示网页 123Intent intent = new Intent(Intent.ACTION_VIEW);intent.setData(Uri.parse("http://www.wangzhuningecnu.github.io"));startActivity(intent); 使用 Intent 指定其他协议，如 geo 地理位置，tel 拨打电话 123Intent intent = new Intent(Intent.ACTION_DIAL);intent.setData(Uri.parse("tel:10000"));startActivity(intent);]]></content>
      <categories>
        <category>Android</category>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>第一行代码</tag>
        <tag>任务清单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective Java]]></title>
    <url>%2F2017%2F10%2F09%2FEffective-Java%2F</url>
    <content type="text"><![CDATA[Chapter 1本书基本原则 清晰性、简洁性：模块的用户永远不应被模块的行为迷惑 模块要尽可能小，但又不能太小（模块 Module 是指任何可重用的组件，包括单个方法，到多个包的复杂系统） 代码应该被重用，而不是被拷贝 模块之间的依赖性应该尽可能降到最小 错误应该尽早被检测出来，最好是在编译时 写出清晰、正确、可用、健壮、灵活和可维护的程序来。如果你能做到这一点，那么获得所需的性能就比较简单了。]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
      </categories>
      <tags>
        <tag>任务清单</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Primary Question]]></title>
    <url>%2F2017%2F10%2F08%2FJava-Primary-Question%2F</url>
    <content type="text"><![CDATA[引用数组的赋值问题元素对象为 Student 类，数组元素对象为什么不能这样声明： 123Student[] arrStudent = new Student[]&#123;&#123;"D",90&#125; , &#123;"C",100&#125; , &#123;"B",95&#125; , &#123;"A",95&#125;&#125;;Student[] arrStudent = new Student[]()&#123;&#123;"D",90&#125; , &#123;"C",100&#125; , &#123;"B",95&#125; , &#123;"A",95&#125;&#125;; Integer 的包装类就可以这样声明： 1234567891011121314151617181920212223//测试 IntegerInteger arrInteger[] = &#123;10,8,9,7,4,6,5,3,2,1&#125;;SelectionSort.selectionSort(arrInteger);for (Integer i : arrInteger )&#123; System.out.print(i + " ");&#125;System.out.println();//测试 DoubleDouble arrDouble[] = &#123;4.3,4.2,3.3,2.1,1.0&#125;;SelectionSort.selectionSort(arrDouble);for (Double double1 : arrDouble) &#123; System.out.print(double1 + " ");&#125;System.out.println();//测试 StringString[] arrString = &#123;"D","C","B","A"&#125;;SelectionSort.selectionSort(arrString);for (String string : arrString) &#123; System.out.print(string+" ");&#125;System.out.println(); 引用类型的数组不可以在声明时赋值吗？ 引用类型数组怎么定义的？ assert 是保证什么的东东，不是类，也不是静态方法，那应该是Object里的,但是没有1assert randomLeft &lt;= randomRight; 这句能保证的是，randomLeft 的值 如果大于 randomRight 的值，则会把他们两个调换。不会报 true 或 false ，也不会报错，程序还是能运行。 泛型泛型啊Foreach 用法注意若是给数组赋值，则不能用 Foreach ，因为 foreach 只是把值拷贝给一个临时变量，并不会赋值给数组本身。 错误示例： 123for (Integer integer : arr) &#123; integer = new Integer((int)(Math.random()*(randomRight-randomLeft+1)+randomLeft)); &#125; 确实生成了随机数给 integer,但并没有给数组。 Java的反射机制]]></content>
      <categories>
        <category>Java</category>
        <category>Java 问题贴</category>
      </categories>
      <tags>
        <tag>Java 问题贴</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sortAlgorithm]]></title>
    <url>%2F2017%2F10%2F07%2FsortAlgorithm%2F</url>
    <content type="text"><![CDATA[最简单的 — 选择排序 选择排序：每次选择剩余元素中的最小的那个，与当前位置互换。 选择排序不能中断，插入排序根据条件可能中断 选择排序动态图 选择排序示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class SelectionSort &#123; private SelectionSort()&#123;&#125;//此算法类不允许产生实例 public static void selectionSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; //找到剩余元素（下标为 [i，arr.length)中的元素）中最小元素的下标 int min = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) &#123; min = j; &#125; &#125; swap(arr, min, i);//将选择出的最小元素与当前位置元素 arr[i] 交换 for (int n : arr) &#123; System.out.print(n +" "); &#125; System.out.println(); &#125; &#125; public static void swap(int arr[],int n,int m) &#123; int temp = arr[n]; arr[n] = arr[m]; arr[m] = temp; &#125; public static void main(String[] args) &#123; int arr[] = &#123;10,8,9,7,4,6,5,3,2,1&#125;; SelectionSort.selectionSort(arr); for (int i : arr) &#123; System.out.print(i + " "); &#125; System.out.println(); &#125;&#125;输出：1 8 9 7 4 6 5 3 2 10 1 2 9 7 4 6 5 3 8 10 1 2 3 7 4 6 5 9 8 10 1 2 3 4 7 6 5 9 8 10 1 2 3 4 5 6 7 9 8 10 1 2 3 4 5 6 7 9 8 10 1 2 3 4 5 6 7 9 8 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 加了泛型的选择排序123456789101112131415161718192021222324252627282930313233343536package com.ning;public class Student implements Comparable&lt;Student&gt;&#123; private String name; private int grade; public Student(String name,int grade) &#123; // TODO Auto-generated constructor stub this.name = name; this.grade = grade; &#125; public Student() &#123; // TODO Auto-generated constructor stub &#125; // 定义Student的compareTo函数 // 如果分数相等，则按照名字的字母序排序 // 如果分数不等，则分数高的靠前 @Override public int compareTo(Student o) &#123; // TODO Auto-generated method stub if (this.grade &gt; o.grade) &#123; return 1; &#125;else if (this.grade &lt; o.grade) &#123; return -1; &#125;else &#123; return this.name.compareTo(o.name); &#125; &#125; @Override public String toString() &#123; // TODO Auto-generated method stub return "Student: " + this.name + " " + this.grade; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.ning;import java.lang.management.MemoryManagerMXBean;public class SelectionSort &#123; private SelectionSort()&#123;&#125;//算法类不允许产生实例 public static void selectionSort(Comparable[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; //找到 [i，arr.length)中 最小元素的下标 int min = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; //使用compareTo方法比较两个Comparable对象的大小 if (arr[j].compareTo(arr[min]) &lt; 0) &#123; min = j; &#125; &#125; swap(arr, min, i);//将选择出的最小元素与 i 交换 for (Object n : arr) &#123; System.out.print(n +" "); &#125; System.out.println(); &#125; &#125; public static void swap(Object arr[],int n,int m) &#123; Object temp = arr[n]; arr[n] = arr[m]; arr[m] = temp; &#125; public static void main(String[] args) &#123; //测试 Integer Integer arrInteger[] = &#123;10,8,9,7,4,6,5,3,2,1&#125;; SelectionSort.selectionSort(arrInteger); for (Integer i : arrInteger )&#123; System.out.print(i + " "); &#125; System.out.println(); //测试 Double Double arrDouble[] = &#123;4.3,4.2,3.3,2.1,1.0&#125;; SelectionSort.selectionSort(arrDouble); for (Double double1 : arrDouble) &#123; System.out.print(double1 + " "); &#125; System.out.println(); //测试 String String[] arrString = &#123;"D","C","B","A"&#125;; SelectionSort.selectionSort(arrString); for (String string : arrString) &#123; System.out.print(string+" "); &#125; System.out.println(); //测试自定义的 Student 类 Student[] arrStudent = new Student[3]; arrStudent[0] = new Student("wang",100); arrStudent[1] = new Student("zhang",98); arrStudent[2] = new Student("xiang",79); SelectionSort.selectionSort(arrStudent); for (Student student : arrStudent) &#123; System.out.print(student + " "); &#125; System.out.println(); &#125;&#125;输出结果：1 8 9 7 4 6 5 3 2 10 1 2 9 7 4 6 5 3 8 10 1 2 3 7 4 6 5 9 8 10 1 2 3 4 7 6 5 9 8 10 1 2 3 4 5 6 7 9 8 10 1 2 3 4 5 6 7 9 8 10 1 2 3 4 5 6 7 9 8 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1.0 4.2 3.3 2.1 4.3 1.0 2.1 3.3 4.2 4.3 1.0 2.1 3.3 4.2 4.3 1.0 2.1 3.3 4.2 4.3 1.0 2.1 3.3 4.2 4.3 1.0 2.1 3.3 4.2 4.3 A C B D A B C D A B C D A B C D A B C D Student: xiang 79 Student: zhang 98 Student: wang 100 Student: xiang 79 Student: zhang 98 Student: wang 100 Student: xiang 79 Student: zhang 98 Student: wang 100 Student: xiang 79 Student: zhang 98 Student: wang 100 随机生成算法测试用例的 SortTestHelper 类1234567891011121314151617181920212223242526package com.ning;public class SortTestHelper &#123; //SortTestHelper 不允许产生任何实例 private SortTestHelper() &#123;&#125; //生成 n 个元素的随机数组，每个随机数的范围是【randomLeft，randomRight】 public static Integer[] generateRandomArray(int n,int randomLeft,int randomRight) &#123; assert randomLeft &lt;= randomRight; Integer[] arr = new Integer[n]; for (int i = 0 ; i &lt; arr.length ; i++) &#123; arr[i] = new Integer((int)(Math.random()*(randomRight-randomLeft+1)+randomLeft));// System.out.println(arr[i]); &#125; SortTestHelper.printArray(arr); return arr; &#125; public static void printArray(Object[] arr) &#123; for (Object o : arr) &#123; System.out.print(o + " "); &#125; System.out.println(); &#125;&#125; 注意：数组赋值的时候，不能使用 foreach 写法，否则只是赋值给了局部变量，并没有赋值给数组本身。 SortTestHelper 类的使用： 12345//测试 Integer int n = 10000; Integer arrInteger[] = SortTestHelper.generateRandomArray(n, 0, n); SelectionSort.selectionSort(arrInteger); SortTestHelper.printArray(arrInteger); 在 SortTestHelper 类中加入测试算法的性能的代码SortTestHelper 类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package bobo.algo;import java.lang.reflect.Method;import java.lang.Class;public class SortTestHelper &#123; //······ // 判断arr数组是否有序 public static boolean isSorted(Comparable[] arr)&#123; for( int i = 0 ; i &lt; arr.length - 1 ; i ++ ) //这里一定是arr.length - 1，否则越界 if( arr[i].compareTo(arr[i+1]) &gt; 0 ) return false; return true; &#125; // 测试sortClassName所对应的排序算法排序arr数组所得到结果的正确性和算法运行时间 public static void testSort(String sortClassName, Comparable[] arr)&#123; // 通过Java的反射机制，通过排序的类名，运行排序函数 // * 依然是，使用反射机制并不是这个课程的重点, 大家也完全可以使用自己的方式书写代码, 最终只要能够测试出自己书写的算法的效率即可 // * 推荐大家阅读我在问答区向大家分享的一个学习心得: 【学习心得分享】请大家抓大放小，不要纠结于C++语言的语法细节 // * 链接: http://coding.imooc.com/learn/questiondetail/4100.html try&#123; // 通过sortClassName获得排序函数的Class对象 Class sortClass = Class.forName(sortClassName); // 通过排序函数的Class对象获得排序方法 Method sortMethod = sortClass.getMethod("sort",new Class[]&#123;Comparable[].class&#125;); // 排序参数只有一个，是可比较数组arr Object[] params = new Object[]&#123;arr&#125;; long startTime = System.currentTimeMillis(); // 调用排序函数 sortMethod.invoke(null,params); long endTime = System.currentTimeMillis(); assert isSorted( arr ); System.out.println( sortClass.getSimpleName()+ " : " + (endTime-startTime) + "ms" ); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 客户端： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package bobo.algo;import java.util.*;public class SelectionSort&#123; // 我们的算法类不允许产生任何实例 private SelectionSort()&#123;&#125; public static void sort(Comparable[] arr)&#123; int n = arr.length; for( int i = 0 ; i &lt; n ; i ++ )&#123; // 寻找[i, n)区间里的最小值的索引 int minIndex = i; for( int j = i + 1 ; j &lt; n ; j ++ ) // 使用compareTo方法比较两个Comparable对象的大小 if( arr[j].compareTo( arr[minIndex] ) &lt; 0 ) minIndex = j; swap( arr , i , minIndex); &#125; &#125; private static void swap(Object[] arr, int i, int j) &#123; Object t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125; public static void main(String[] args) &#123; // 测试排序算法辅助函数 int N = 10000; Integer[] arr = SortTestHelper.generateRandomArray(N, 0, N); SortTestHelper.testSort("bobo.algo.SelectionSort", arr); return; &#125;&#125;输出结果：N = 100 时，排序数...SelectionSort: 1msN = 1000 时，排序数...SelectionSort: 12msN = 10000 时，排序数..SelectionSort: 140msN = 100000 时，排序数.SelectionSort: 11577ms 同样 n² 的 — 插入排序 插入排序：把后面的元素，一个位置一个位置的往前，插入到合适的位置 插入排序像是一边摸牌，一边码牌；选择排序像是发牌完毕后，再码牌 插入排序动态图 插入排序示例代码123456789101112131415161718192021222324package com.ning;public class InsertionSort &#123; // 我们的算法类不允许产生任何实例 private InsertionSort()&#123;&#125; public static void sort(Comparable arr[]) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; // 寻找元素arr[i]合适的插入位置 for (int j = i; j &gt;= 1 ; j--) &#123; if (arr[j].compareTo(arr[j-1])&lt;0) &#123; swap(arr,j,j-1); &#125;else &#123; break; &#125; &#125; &#125; &#125; private static void swap(Object[] a,int n,int m) &#123; Object temp = a[m]; a[m] = a[n]; a[n] = temp; &#125;&#125; 插入排序与选择排序的比较123456789101112 int n = 100000; Integer[] arr1 = SortTestHelper.generateRandomArray(n, 0, n); Integer[] arr2 = Arrays.copyOf(arr1, arr1.length); //Java 中有赋值数组的方法，C++ 中没有 /*SelectionSort.selectionSort(arrInteger); SortTestHelper.printArray(arrInteger);*/ SortTestHelper.testSort("com.ning.SelectionSort", arr1); SortTestHelper.testSort("com.ning.InsertionSort", arr2);结果：SelectionSort: 14086msInsertionSort: 15634ms 比较 SelectionSort 和 InsertionSort 两种排序算法的性能效率 此时，插入排序比选择排序性能略低 插入排序的优化 插入排序在元素本就在该位置时，会结束本次比较，按理说比不能中断的选择排序要快，但并非如此，为何？ 因为插入排序在遍历的同时，也在不停交换，交换操作比比较更耗时，每次交换都有三次赋值的操作。 插入排序优化示意图 插入排序优化示例代码冒泡排序12345678910111213141516171819202122232425262728293031323334353637package com.ning;//这是冒泡排序public class BubbleSort &#123; private BubbleSort() &#123; &#125; public static void sort(Comparable[] array) &#123; for (int i = 0; i &lt; array.length; i++) &#123; for (int j = 1+i; j &lt; array.length; j++) &#123; if (array[j].compareTo(array[i]) &lt; 0) &#123; Comparable temp = array[j]; array[j] = array[i]; array[i] = temp; &#125; &#125; &#125; &#125;&#125;输出结果：11 14 9 16 7 19 1 9 15 5 1 14 11 16 9 19 7 9 15 5 1 5 14 16 11 19 9 9 15 7 1 5 7 16 14 19 11 9 15 9 1 5 7 9 16 19 14 11 15 9 1 5 7 9 9 19 16 14 15 11 1 5 7 9 9 11 19 16 15 14 1 5 7 9 9 11 14 19 16 15 1 5 7 9 9 11 14 15 19 16 1 5 7 9 9 11 14 15 16 19 1 5 7 9 9 11 14 15 16 19 1 5 7 9 9 11 14 15 16 19]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>Java 算法与数据结构（慕课网）</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TaskList：SAIC MAXUS]]></title>
    <url>%2F2017%2F10%2F04%2FTaskList%EF%BC%9ASAIC-MAXUS%2F</url>
    <content type="text"><![CDATA[数据库实现手机验证码滚动广告搜索智能推荐购买支付语音]]></content>
      <categories>
        <category>上汽大通</category>
      </categories>
      <tags>
        <tag>任务清单</tag>
        <tag>上汽大通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Writing specifications]]></title>
    <url>%2F2017%2F10%2F02%2FWriting-specifications%2F</url>
    <content type="text"><![CDATA[摘自： stormzhang 的博客：每个人都需要的中文排版指南 空格 中英文之间需要加空格 eg. 大家可以搜索公众号 AndroidDeveloper 或者 googdev 关注我。 中文与数字之间需要加空格 eg. 不知不觉，我都快 30 岁了。 数字与单位之间需要加空格 eg. 我有一块 20 TB 的硬盘，鬼知道我是怎么用完的。 完整的英文整句时标点与单词之间需要加空格 eg. Stay hungry, stay foolish. 但是也有一些例外。 度的标志、百分号不加空格 eg. 今天气温有 30° 的高温。 eg. 据统计，关注公众号 AndroidDeveloper 的读者中有 80% 是长得好看的。 全角标点与其他字符之间不加空格 eg. 大家好，我是 stormzhang，请多多关照。 标点全角和半角是英文和中文的编码规范不同遗留下的问题，简单来说，全角占两个字节，半角占一个字节，你可以理解成中文汉字是全角，英文字母是半角，不过半角全角主要是针对标点符号来说的，中文标点占两个字节，英文标点占一个字节。体现在排版上的差异就是，全角字符屏幕打印宽度是两个，而半角字符屏幕打印宽度是一个，如中文逗号和英文逗号他们的显示分别是「，」和「,」。 使用全角中文标点 中文排版中所有的标点都应该使用中文全角中文标点 eg. 大家好，我是 stormzhang。 遇到英文整句、特殊名词时使用半角标点。 eg. 乔布斯说过：「Stay hungry, stay foolish.」 eg. Facebook, Inc. 使用直角引号 我国国家标准要求弯引号，但是个人建议在新媒体排版时使用直角引号。 eg. 你竟然不知道「帅比张」？ 如果引号再使用引号使用直角双引号。 eg. 我质问他，「你难道忘记『帅比张』了么？」 其他除以上之外，还有一些其他标准推荐大家使用的。 英文名词首字母尽量大写 eg. Google、Android、Facebook 专有名词使用正确的大小写 eg. GitHub、iOS、iPhone 6s、MacBook Pro 首行不要缩进 大家一般都采用「空出一行」进行自然段与自然段之间的区分，这种写作方式非常省事，而且很整齐。 ​]]></content>
      <categories>
        <category>stormzhang</category>
        <category>Blog 书写规范</category>
      </categories>
      <tags>
        <tag>stormzhang</tag>
        <tag>中文排版指南</tag>
        <tag>书写规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BookList]]></title>
    <url>%2F2017%2F09%2F30%2FBookList%2F</url>
    <content type="text"><![CDATA[过去完成时 Head First Java： 8 - 9 月 现在进行时 Android 第一行代码：10 月 Java 算法与数据结构（慕课网）：10 - 11 月 15 日，每天一小部分，你努力时，全世界都会给你让路。 Head First Java 总结：10月 。每晚补一点。 Head First 设计模式：10 - 11 月 15 日，和慕课网的视频结合着一起看。 CET - 6（10 月 - 11月 15日）：考研单词一天背一单元；一周看一次语法视频。 将来时]]></content>
      <categories>
        <category>书单</category>
      </categories>
      <tags>
        <tag>任务清单</tag>
        <tag>书单</tag>
        <tag>Head First Java</tag>
        <tag>Effective Java</tag>
        <tag>Thinking in Java</tag>
        <tag>Android 第一行代码</tag>
        <tag>Head First 设计模式</tag>
        <tag>CET - 6</tag>
        <tag>Java 算法与数据结构（慕课网）</tag>
        <tag>玩转算法面试 LeetCode 题库分门别类详细解析（慕课网）</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub + Hexo + NexT 主题 免费搭建博客-参考链接收集]]></title>
    <url>%2F2017%2F09%2F30%2FFreeBlog%EF%BC%9AGitHub-Hexo%2F</url>
    <content type="text"><![CDATA[博客搭建 GitHub 官网：https://github.com/ Hexo 官网：https://hexo.io/zh-cn/ 部署博客 NexT 主题官网：http://theme-next.iissnan.com/ 美化博客 NexT 源码地址：用于失误修改next文件夹里的文件，可以参考源码还原 最适合新手的 GitHub + Hexo 「大话」博客搭建教程 建立博客系列（三）：Hexo 安装配置 建立博客系列（四）：NexT 主题相关配置 建立博客系列（五）：发布第一篇文章 记录第一次搭建 Hexo 一些错误的解决方案 解决 Hexo 神烦的 DTraceProviderBindings MODULE_NOT_FOUND Mac 快速显示或隐藏“隐藏”文件 Mac 设置文件权限问题 博客主题 NexT 参考 Jark’s Blog 随风丶亮 主题 NexT 美化 NexT 主题里用到的所有图标 网站 icon 下载地址 NexT 主题配置及优化-动态背景等大全 Hexo 的 NexT 主题个性化教程:打造炫酷网站 NexT 主题添加腾讯空间404公益页面 Hexo 文章管理和写文章 Hexo 使用攻略：（四）Hexo 的分类和标签设置 分类和标签有什么区别和关联? Front - matter | Hexo 官网关于文章分类的解释 Markdown 官网 认识与入门 Markdown Markdown 语法手册 （完整整理版） Mac 下好用的 Markdown 编辑器– Mou Mac 下好用的 Markdown 编辑器—Typora Mac 下好用的图床工具 CloudApp（科学上网 + 软件收费 + 14天试用） 如何利用 GitHub 在 Markdown 中优雅地插入图片 Hexo-设置阅读全文 注意 修改文件之前先行备份，以防更改失败； 找不到的信息，结合官网查询。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F09%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
